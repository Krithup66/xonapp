//@version=5
strategy("Xon - Swing Trading", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100, initial_capital=10000, currency=currency.USD, commission_type=strategy.commission.percent, commission_value=0.1, pyramiding=1, close_entries_rule="ANY", process_orders_on_close=true, dynamic_requests=true)

// ============================================================================
// GLOBAL VARIABLES (à¸ªà¸³à¸«à¸£à¸±à¸š helper functions)
// ============================================================================
var float hlPrice = na
var int hlIndex = na
var int hlFirstCandleIndex = na
var float hlFirstCandleOpen = na
var bool isSubWave = false
var bool rsiTested30 = false
var float prevRSI = na
var bool tp1Exited = false
var string exitReason = ""
var float exitPercent = 0.0
// Scale-in Entry Tracking - à¹€à¸à¹‡à¸šà¸§à¹ˆà¸²à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¸—à¸µà¹ˆ Fib level à¹„à¸«à¸™à¹à¸¥à¹‰à¸§
var bool entry382Filled = false  // à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¸—à¸µà¹ˆ Fib 0.382 à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡
var bool entry50Filled = false  // à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¸—à¸µà¹ˆ Fib 0.50 à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡
var bool entry618Filled = false  // à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¸—à¸µà¹ˆ Fib 0.618 à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡
var bool entry786Filled = false  // à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¸—à¸µà¹ˆ Fib 0.786 à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡

// à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸à¸²à¸£à¹€à¸‚à¹‰à¸²à¸‹à¹‰à¸³à¹ƒà¸™à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡ Major Wave à¹€à¸”à¸µà¸¢à¸§à¸à¸±à¸™
var int lastMajorWaveEntryBar = na  // à¸šà¸±à¸™à¸—à¸¶à¸ bar à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¸„à¸£à¸±à¹‰à¸‡à¸¥à¹ˆà¸²à¸ªà¸¸à¸”
var float lastMajorWaveHL = na  // à¸šà¸±à¸™à¸—à¸¶à¸ HL/LL à¸‚à¸­à¸‡ Major Wave à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¹„à¸›à¹à¸¥à¹‰à¸§
var float lastMajorWaveHH = na  // à¸šà¸±à¸™à¸—à¸¶à¸ HH/LL à¸‚à¸­à¸‡ Major Wave à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¹„à¸›à¹à¸¥à¹‰à¸§
var string lastEntryWaveType = ""  // à¹€à¸à¹‡à¸š wave type à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¹„à¸›à¹à¸¥à¹‰à¸§ ("WaveA", "WaveB", etc.)
var bool majorWaveCompleted = false  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² Major Wave à¸ˆà¸šà¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡

// ============================================================================
// INPUT SETTINGS (à¸•à¹‰à¸­à¸‡à¸›à¸£à¸°à¸à¸²à¸¨à¸à¹ˆà¸­à¸™ Helper Functions)
// ============================================================================

// Discord Webhook Settings
enableDiscord = input.bool(false, "Enable Discord Webhook", group="Discord Notifications")
discordWebhookURL = input.string("", "Discord Webhook URL", group="Discord Notifications", tooltip="Paste your Discord webhook URL here")
sendEntrySignals = input.bool(true, "Send Entry Signals", group="Discord Notifications")
sendExitSignals = input.bool(true, "Send Exit Signals", group="Discord Notifications")
sendAIData = input.bool(true, "Send AI-Formatted Data", group="Discord Notifications", tooltip="Include structured data for AI model processing")

// ============================================================================
// HELPER FUNCTIONS (à¸¥à¸” local scopes)
// ============================================================================

// Function: à¸•à¸±à¹‰à¸‡ Stop Loss à¹à¸¥à¸° Take Profit
setExitOrders(string exitId, string entryId, float sl, float tp1Val, float tp2Val, float tp3Val) =>
    if not na(tp3Val) and not na(tp2Val) and not na(tp1Val)
        strategy.exit(exitId, entryId, stop=sl, limit=tp3Val, qty_percent=100, comment="TP3")
    else if not na(tp2Val) and not na(tp1Val)
        strategy.exit(exitId, entryId, stop=sl, limit=tp2Val, qty_percent=100, comment="TP2")
    else if not na(tp1Val)
        strategy.exit(exitId, entryId, stop=sl, limit=tp1Val, qty_percent=100, comment="TP1")
    else
        strategy.exit(exitId + "_SL", entryId, stop=sl)

// Function: à¸„à¸³à¸™à¸§à¸“ TP à¸•à¸²à¸¡ Elliott Wave Structure (Major Wave)
// à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡à¹ƒà¸«à¹‰à¸£à¸­à¸‡à¸£à¸±à¸š Flat patterns à¹à¸¥à¸° Extended waves
calculateElliottTP(float entryPrice, float wave1Low, float wave1High, int currentWave, bool isImpulse, bool wave3Ext) =>
    float tp1 = na, float tp2 = na, float tp3 = na
    
    if not na(wave1Low) and not na(wave1High) and wave1High > wave1Low
        float wave1Range = wave1High - wave1Low
        
        if isImpulse and currentWave == 2
            // Wave 2 â†’ Wave 3: à¹ƒà¸Šà¹‰ Fibonacci Extension
            // Wave 3 à¸¡à¸±à¸à¸ˆà¸° extended (1.618 à¸«à¸£à¸·à¸­ 2.618 à¸‚à¸­à¸‡ Wave 1)
            if wave3Ext
                // Wave 3 Extended: TP à¹ƒà¸Šà¹‰ 2.618 à¹à¸¥à¸° 4.236
                tp1 := entryPrice + (wave1Range * 2.618)
                tp2 := entryPrice + (wave1Range * 4.236)
                tp3 := entryPrice + (wave1Range * 6.854)
            else
                // Wave 3 Normal: TP à¹ƒà¸Šà¹‰ 1.618 à¹à¸¥à¸° 2.618
                tp1 := entryPrice + (wave1Range * 1.618)
                tp2 := entryPrice + (wave1Range * 2.618)
                tp3 := entryPrice + (wave1Range * 4.236)
        else if isImpulse and currentWave == 4
            // Wave 4 â†’ Wave 5: à¹ƒà¸Šà¹‰ Fibonacci Extension
            if wave3Ext
                // Wave 3 Extended: Wave 5 à¸¡à¸±à¸à¸ˆà¸°à¹€à¸—à¹ˆà¸²à¸à¸±à¸š Wave 1 à¸«à¸£à¸·à¸­ 0.618 à¸‚à¸­à¸‡ Wave 3
                tp1 := entryPrice + (wave1Range * 1.0)
                tp2 := entryPrice + (wave1Range * 1.618)
            else
                // Wave 3 Normal: Wave 5 à¸¡à¸±à¸à¸ˆà¸° 1.618 à¸«à¸£à¸·à¸­ 2.618 à¸‚à¸­à¸‡ Wave 1
                tp1 := entryPrice + (wave1Range * 1.618)
                tp2 := entryPrice + (wave1Range * 2.618)
                tp3 := entryPrice + (wave1Range * 4.236)
        else if not isImpulse
            // Correction Wave (ABC): à¹ƒà¸Šà¹‰ Fibonacci Extension
            // Wave C à¸¡à¸±à¸à¸ˆà¸° 1.0 à¸«à¸£à¸·à¸­ 1.618 à¸‚à¸­à¸‡ Wave A
            tp1 := entryPrice + (wave1Range * 1.0)
            tp2 := entryPrice + (wave1Range * 1.618)
            tp3 := entryPrice + (wave1Range * 2.618)
    
    [tp1, tp2, tp3]

// Function: à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œ Elliott Wave Pattern (Flat, Extended, Zigzag)
// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Flat pattern, Extended wave, à¹à¸¥à¸° Zigzag pattern
analyzeElliottWavePattern(float waveALow, float waveAHigh, float waveBLow, float waveBHigh, float waveCLow, float waveCHigh) =>
    bool isFlatPattern = false
    bool isExtendedWave = false
    bool isZigzagPattern = false
    
    if not na(waveALow) and not na(waveAHigh) and waveAHigh > waveALow
        float waveARange = waveAHigh - waveALow
        
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Wave B (à¸–à¹‰à¸²à¸¡à¸µ)
        if not na(waveBLow) and not na(waveBHigh) and waveBHigh > waveBLow
            float waveBRange = waveBHigh - waveBLow
            float waveBRatio = waveARange > 0 ? waveBRange / waveARange : 0
            
            // Flat Pattern: Wave B à¹€à¸à¸´à¸™ 100% à¸‚à¸­à¸‡ Wave A (à¹à¸•à¹ˆà¹„à¸¡à¹ˆà¹€à¸à¸´à¸™ 138.2%)
            // Flat = Wave B à¸à¸¥à¸±à¸šà¸¡à¸²à¸—à¸µà¹ˆ 100-138.2% à¸‚à¸­à¸‡ Wave A
            isFlatPattern := waveBRatio >= 1.0 and waveBRatio <= 1.382
            
            // Zigzag Pattern: Wave B à¸•à¹ˆà¸³à¸à¸§à¹ˆà¸² 61.8% à¸‚à¸­à¸‡ Wave A
            // Zigzag = Wave B retracement à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸² 61.8%
            isZigzagPattern := waveBRatio < 0.618
        
        // Extended Wave: Wave C à¸¢à¸²à¸§à¸¡à¸²à¸ (à¹€à¸à¸´à¸™ 2.618 à¸‚à¸­à¸‡ Wave A)
        // à¸«à¸£à¸·à¸­ Wave 3/Wave 5 à¸¢à¸²à¸§à¸¡à¸²à¸ (à¸ªà¸³à¸«à¸£à¸±à¸š Impulse)
        if not na(waveCLow) and not na(waveCHigh) and waveCHigh > waveCLow
            float waveCRange = waveCHigh - waveCLow
            float waveCRatio = waveARange > 0 ? waveCRange / waveARange : 0
            isExtendedWave := waveCRatio >= 2.618
    
    [isFlatPattern, isExtendedWave, isZigzagPattern]

// Function: à¸ªà¸£à¹‰à¸²à¸‡ JSON data à¸ªà¸³à¸«à¸£à¸±à¸š AI Model
createAIData(string action, string waveType, float entry, float sl, float tp1, float tp2, float tp3, int wave, bool impulse, string macdTrend, float rsi, float atr) =>
    string waveStr = impulse ? "Impulse-" + str.tostring(wave) : "Correction-" + str.tostring(wave)
    string rrRatio = not na(tp1) and not na(sl) ? str.tostring((tp1 - entry) / (entry - sl), "#.##") : "N/A"
    string json = '{"action":"' + action + '","symbol":"' + syminfo.ticker + '","timeframe":"' + timeframe.period + '"'
    json := json + ',"timestamp":' + str.tostring(time) + ',"wave_type":"' + waveType + '","wave_structure":"' + waveStr + '"'
    json := json + ',"entry_price":' + str.tostring(entry, "#.##") + ',"stop_loss":' + str.tostring(sl, "#.##")
    json := json + ',"take_profit_1":' + str.tostring(tp1, "#.##") + ',"take_profit_2":' + str.tostring(tp2, "#.##")
    json := json + ',"take_profit_3":' + str.tostring(tp3, "#.##") + ',"risk_reward":"' + rrRatio + '"'
    json := json + ',"current_price":' + str.tostring(close, "#.##") + ',"macd_trend":"' + macdTrend + '"'
    json := json + ',"rsi_value":' + str.tostring(rsi, "#.##") + ',"atr_value":' + str.tostring(atr, "#.##") + '}'
    json

// Function: à¸ªà¹ˆà¸‡ Discord Alert à¸žà¸£à¹‰à¸­à¸¡ AI Data
sendDiscordAlert(string title, string description, string color, string aiData) =>
    if enableDiscord and discordWebhookURL != ""
        string webhook = '{"embeds":[{"title":"' + title + '","description":"' + description + '","color":' + color
        webhook := webhook + ',"timestamp":"' + str.format("{0,date,yyyy-MM-dd'T'HH:mm:ss'Z'}", time) + '"'
        webhook := webhook + ',"footer":{"text":"Elliott Wave Strategy"},"fields":[{"name":"AI Data","value":"```json\\n'
        webhook := webhook + aiData + '\\n```","inline":false}]}]}'
        alert(webhook, alert.freq_once_per_bar)

// Function: Execute Long Entry for Wave A
executeLongWaveAEntry(float ewEntryPrice, int currentWaveForEntry, float ewStopLoss, float ewTP1, float ewTP2, float ewTP3, float fibRetracement618, float fibLL, float fibHH, float firstWaveLL, float firstWaveHH) =>
    bool useEWEntry = not na(ewEntryPrice) and currentWaveForEntry > 0
    // à¹ƒà¸Šà¹‰ low à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¹à¸•à¸° Fib level à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸‚à¹‰à¸²à¹„à¸”à¹‰à¸—à¸µà¹ˆà¸›à¸¥à¸²à¸¢ wick (à¹€à¸£à¹‡à¸§à¸‚à¸¶à¹‰à¸™)
    float entry = useEWEntry ? ewEntryPrice : (not na(fibRetracement618) ? math.min(low, fibRetracement618) : low)
    
    // Stop Loss: à¹ƒà¸Šà¹‰ LL à¸‚à¸­à¸‡à¸ªà¸§à¸´à¸‡ (fibLL) à¹€à¸žà¸·à¹ˆà¸­à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¸¢à¸«à¸²à¸¢à¹€à¸¡à¸·à¹ˆà¸­à¸«à¸¥à¸¸à¸”à¸ªà¸§à¸´à¸‡
    float sl = na
    if useEWEntry and not na(ewStopLoss)
        sl := ewStopLoss
    else if not na(fibLL)
        // à¹ƒà¸Šà¹‰ LL à¸‚à¸­à¸‡à¸ªà¸§à¸´à¸‡à¹€à¸›à¹‡à¸™ SL (à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¸¢à¸«à¸²à¸¢à¹€à¸¡à¸·à¹ˆà¸­à¸«à¸¥à¸¸à¸”à¸ªà¸§à¸´à¸‡)
        sl := fibLL
    else
        sl := entry * 0.99  // Fallback: 1% below entry
    
    // à¸„à¸³à¸™à¸§à¸“ TP à¸•à¸²à¸¡à¸à¸Ž Elliott Wave à¸ˆà¸²à¸ MAJOR WAVE (1H)
    float tp1 = na, float tp2 = na, float tp3 = na
    if useEWEntry
        tp1 := not na(ewTP1) ? ewTP1 : na
        tp2 := not na(ewTP2) ? ewTP2 : na
        tp3 := not na(ewTP3) ? ewTP3 : na
    else if not na(firstWaveLL) and not na(firstWaveHH)
        float majorWave1Range = firstWaveHH - firstWaveLL
        tp1 := entry + (majorWave1Range * 1.618)
        tp2 := entry + (majorWave1Range * 2.618)
        tp3 := entry + (majorWave1Range * 4.236)
    else if not na(fibLL) and not na(fibHH)
        float longRange = fibHH - fibLL
        tp1 := entry + (longRange * 1.618)
        tp2 := entry + (longRange * 2.618)
        tp3 := entry + (longRange * 4.236)
    
    [entry, sl, tp1, tp2, tp3]

// Function: Execute Long Entry for Wave B
executeLongWaveBEntry(float fibRetracement618, float firstWaveLL, float firstWaveHH, float fibLL, float fibHH, float wave1Low, float wave1High, int currentMajorWave, bool isImpulseWave, bool wave3Extended) =>
    // à¹ƒà¸Šà¹‰ low à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¹à¸•à¸° Fib level à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸‚à¹‰à¸²à¹„à¸”à¹‰à¸—à¸µà¹ˆà¸›à¸¥à¸²à¸¢ wick (à¹€à¸£à¹‡à¸§à¸‚à¸¶à¹‰à¸™)
    float entry = not na(fibRetracement618) ? math.min(low, fibRetracement618) : low
    
    // Stop Loss: à¹ƒà¸Šà¹‰ LL à¸‚à¸­à¸‡à¸ªà¸§à¸´à¸‡ (fibLL) à¹€à¸žà¸·à¹ˆà¸­à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¸¢à¸«à¸²à¸¢à¹€à¸¡à¸·à¹ˆà¸­à¸«à¸¥à¸¸à¸”à¸ªà¸§à¸´à¸‡
    float sl = na
    if not na(fibLL)
        // à¹ƒà¸Šà¹‰ LL à¸‚à¸­à¸‡à¸ªà¸§à¸´à¸‡à¹€à¸›à¹‡à¸™ SL (à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¸¢à¸«à¸²à¸¢à¹€à¸¡à¸·à¹ˆà¸­à¸«à¸¥à¸¸à¸”à¸ªà¸§à¸´à¸‡)
        sl := fibLL
    else if not na(firstWaveLL)
        // Fallback: à¹ƒà¸Šà¹‰ firstWaveLL
        sl := firstWaveLL
    else
        sl := entry * 0.99  // Fallback: 1% below entry
    
    // TP calculation
    float tp1 = na, float tp2 = na, float tp3 = na
    if not na(firstWaveLL) and not na(firstWaveHH)
        float waveARange = firstWaveHH - firstWaveLL
        tp1 := math.max(firstWaveHH, entry + (waveARange * 0.618))
        tp2 := entry + (waveARange * 1.618)
        tp3 := entry + (waveARange * 2.618)
    else if not na(wave1Low) and not na(wave1High)
        [tp1, tp2, tp3] = calculateElliottTP(entry, wave1Low, wave1High, currentMajorWave, isImpulseWave, wave3Extended)
    else if not na(fibLL) and not na(fibHH)
        float longRange = fibHH - fibLL
        tp1 := entry + (longRange * 1.0)
        tp2 := entry + (longRange * 1.618)
        tp3 := entry + (longRange * 2.618)
    
    [entry, sl, tp1, tp2, tp3]

// Function: Execute Long Entry for Fallback
executeLongFallbackEntry(float fibRetracement618, float fibLL, float fibHH) =>
    // à¹ƒà¸Šà¹‰ low à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¹à¸•à¸° Fib level à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸‚à¹‰à¸²à¹„à¸”à¹‰à¸—à¸µà¹ˆà¸›à¸¥à¸²à¸¢ wick (à¹€à¸£à¹‡à¸§à¸‚à¸¶à¹‰à¸™)
    float entry = not na(fibRetracement618) ? math.min(low, fibRetracement618) : low
    // Stop Loss: à¹ƒà¸Šà¹‰ LL à¸‚à¸­à¸‡à¸ªà¸§à¸´à¸‡ (fibLL) à¹€à¸žà¸·à¹ˆà¸­à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¸¢à¸«à¸²à¸¢à¹€à¸¡à¸·à¹ˆà¸­à¸«à¸¥à¸¸à¸”à¸ªà¸§à¸´à¸‡
    float sl = not na(fibLL) ? fibLL : entry * 0.99
    
    float tp1 = na, float tp2 = na
    if not na(fibLL) and not na(fibHH)
        float longRange = fibHH - fibLL
        tp1 := entry + (longRange * 1.618)
        tp2 := entry + (longRange * 2.618)
    else
        tp1 := entry * 1.02
        tp2 := entry * 1.05
    
    [entry, sl, tp1, tp2]

// Function: Execute Long Entry for Major Wave B
executeLongMajorWaveBEntry(float fibRetracement382, float fibHL, float firstWaveLL, float fibLL, float wave1Low, float wave1High, int currentMajorWave, bool isImpulseWave, bool wave3Extended, float firstWaveHH) =>
    // à¹ƒà¸Šà¹‰ low à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¹à¸•à¸° Fib level à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸‚à¹‰à¸²à¹„à¸”à¹‰à¸—à¸µà¹ˆà¸›à¸¥à¸²à¸¢ wick (à¹€à¸£à¹‡à¸§à¸‚à¸¶à¹‰à¸™)
    float entry = not na(fibRetracement382) ? math.min(low, fibRetracement382) : low
    
    // Stop Loss à¹ƒà¸Šà¹‰ HL (Higher Low) à¸‚à¸­à¸‡ Major Wave B
    float sl = na
    if not na(fibHL)
        sl := fibHL
    else if not na(firstWaveLL)
        sl := firstWaveLL
    else
        sl := not na(fibLL) ? fibLL : entry
    
    // TP à¹ƒà¸Šà¹‰ Major Wave Structure (Elliott Wave Impulse/Correction)
    float tp1 = na, float tp2 = na, float tp3 = na
    if not na(wave1Low) and not na(wave1High)
        int waveForTP = currentMajorWave == 3 ? 4 : 2
        [tp1, tp2, tp3] = calculateElliottTP(entry, wave1Low, wave1High, waveForTP, isImpulseWave, wave3Extended)
    else if not na(firstWaveLL) and not na(firstWaveHH)
        float majorWaveRange = firstWaveHH - firstWaveLL
        tp1 := entry + (majorWaveRange * 1.0)
        tp2 := entry + (majorWaveRange * 1.618)
        tp3 := entry + (majorWaveRange * 2.618)
    
    [entry, sl, tp1, tp2, tp3]

// Function: Execute Short Entry for Wave A
executeShortWaveAEntry(float ewEntryPrice, int currentWaveForEntry, int trendFromCHOCH_1H, float ewStopLoss, float ewTP1, float ewTP2, float ewTP3, float fibRetracement618, float fibHH, float fibLL, float firstWaveHH, float firstWaveLL) =>
    bool useEWEntry_Short = not na(ewEntryPrice) and currentWaveForEntry > 0 and trendFromCHOCH_1H < 0
    // à¹ƒà¸Šà¹‰ high à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¹à¸•à¸° Fib level à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸‚à¹‰à¸²à¹„à¸”à¹‰à¸—à¸µà¹ˆà¸›à¸¥à¸²à¸¢ wick (à¹€à¸£à¹‡à¸§à¸‚à¸¶à¹‰à¸™)
    float entry = useEWEntry_Short ? ewEntryPrice : (not na(fibRetracement618) ? math.max(high, fibRetracement618) : high)
    
    // Stop Loss: Wave A Short à¹ƒà¸Šà¹‰ Fib 0.786
    float sl = na
    if useEWEntry_Short and not na(ewStopLoss)
        sl := ewStopLoss
    else if not na(fibHH) and not na(fibLL)
        float waveRange_Short = fibHH - fibLL
        sl := fibLL + (waveRange_Short * 0.786)
    else
        sl := not na(fibHH) ? fibHH : entry * 1.01
    
    // à¸„à¸³à¸™à¸§à¸“ TP à¸ªà¸³à¸«à¸£à¸±à¸š Short
    float tp1 = na, float tp2 = na, float tp3 = na
    if useEWEntry_Short and not na(ewTP1)
        tp1 := entry - math.abs(ewTP1 - entry)
        tp2 := not na(ewTP2) ? entry - math.abs(ewTP2 - entry) : na
        tp3 := not na(ewTP3) ? entry - math.abs(ewTP3 - entry) : na
    else if not na(firstWaveHH) and not na(firstWaveLL)
        float majorWave1Range_Short = firstWaveHH - firstWaveLL
        tp1 := entry - (majorWave1Range_Short * 1.618)
        tp2 := entry - (majorWave1Range_Short * 2.618)
        tp3 := entry - (majorWave1Range_Short * 4.236)
    else if not na(fibHH) and not na(fibLL)
        float shortRange = fibHH - fibLL
        tp1 := entry - (shortRange * 1.618)
        tp2 := entry - (shortRange * 2.618)
        tp3 := entry - (shortRange * 4.236)
    
    [entry, sl, tp1, tp2, tp3]

// Function: Execute Short Entry for Wave B
executeShortWaveBEntry(float fibRetracement618, float firstWaveHH, float firstWaveLL, float fibHH, float fibLL) =>
    // à¹ƒà¸Šà¹‰ high à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¹à¸•à¸° Fib level à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸‚à¹‰à¸²à¹„à¸”à¹‰à¸—à¸µà¹ˆà¸›à¸¥à¸²à¸¢ wick (à¹€à¸£à¹‡à¸§à¸‚à¸¶à¹‰à¸™)
    float entry = not na(fibRetracement618) ? math.max(high, fibRetracement618) : high
    
    // Stop Loss: Wave B Short à¹ƒà¸Šà¹‰ Fib 0.5
    float sl = na
    if not na(firstWaveHH) and not na(firstWaveLL)
        float waveARange_Short = firstWaveHH - firstWaveLL
        sl := firstWaveLL + (waveARange_Short * 0.5)
    else if not na(fibHH) and not na(fibLL)
        float swingRange_Short = fibHH - fibLL
        sl := fibLL + (swingRange_Short * 0.5)
    else
        sl := entry * 1.01
    
    // TP à¸•à¸²à¸¡à¸à¸Ž Elliott Wave: Wave C = 1.0-1.618 Ã— Wave A
    float tp1 = na, float tp2 = na, float tp3 = na
    if not na(firstWaveHH) and not na(firstWaveLL)
        float wave1Range_Short = firstWaveHH - firstWaveLL
        tp1 := entry - (wave1Range_Short * 1.0)
        tp2 := entry - (wave1Range_Short * 1.618)
        tp3 := entry - (wave1Range_Short * 2.618)
    else
        float shortRange = not na(fibHH) and not na(fibLL) ? fibHH - fibLL : entry * 0.03
        tp1 := entry - (shortRange * 1.0)
        tp2 := entry - (shortRange * 1.618)
        tp3 := entry - (shortRange * 2.618)
    
    [entry, sl, tp1, tp2, tp3]

// Function: Execute Short Entry for Fallback
executeShortFallbackEntry(float fibRetracement618, float fibHH, float fibLL) =>
    // à¹ƒà¸Šà¹‰ high à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¹à¸•à¸° Fib level à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸‚à¹‰à¸²à¹„à¸”à¹‰à¸—à¸µà¹ˆà¸›à¸¥à¸²à¸¢ wick (à¹€à¸£à¹‡à¸§à¸‚à¸¶à¹‰à¸™)
    float entry = not na(fibRetracement618) ? math.max(high, fibRetracement618) : high
    float sl = not na(fibHH) ? fibHH : entry * 1.01
    
    float tp1 = na, float tp2 = na
    if not na(fibHH) and not na(fibLL)
        float shortRange = fibHH - fibLL
        tp1 := entry - (shortRange * 1.618)
        tp2 := entry - (shortRange * 2.618)
    else
        tp1 := entry * 0.98
        tp2 := entry * 0.95
    
    [entry, sl, tp1, tp2]

// Function: Calculate Short Exit Conditions
calculateShortExitConditions(float stopLoss, float fibTP1, float fibTP2, float fibTP3, bool isUptrend, float slowSMA, bool detectRejection, bool atSupport, bool bullishRejection, bool checkSupportResistance) =>
    bool tp1Reached = not na(fibTP1) and low <= fibTP1
    bool tp2Reached = not na(fibTP2) and low <= fibTP2
    bool tp3Reached = not na(fibTP3) and low <= fibTP3
    bool rejectionAtSupport = detectRejection and atSupport and bullishRejection
    bool exitShort = (close > stopLoss) or (isUptrend and ta.crossover(close, slowSMA)) or tp2Reached or tp3Reached or rejectionAtSupport or (atSupport and checkSupportResistance)
    [exitShort, tp1Reached, tp2Reached, tp3Reached, rejectionAtSupport]

// Function: Calculate Long Exit Conditions
calculateLongExitConditions(float stopLoss, float fibTP1, float fibTP2, float fibTP3, float entryPrice, float wave1High, float wave1Low, float fibHH, int trendFromCHOCH_5M, int trendFromCHOCH_15M, bool detectRejection, bool atResistance, bool bearishRejection, float rejectionWickRatio, bool isDowntrend, float slowSMA, bool enableMACD, bool macdTrendHold_1H, bool macdTrendHold_4H, bool isStrongUptrend, bool checkSupportResistance, float hlFirstCandleOpen) =>
    bool tp1Reached = not na(fibTP1) and high >= fibTP1
    bool tp2Reached = not na(fibTP2) and high >= fibTP2
    bool tp3Reached = not na(fibTP3) and high >= fibTP3
    float wave1Range = not na(wave1High) and not na(wave1Low) ? wave1High - wave1Low : entryPrice * 0.03
    bool nearTarget = not na(fibTP2) and math.abs(high - fibTP2) < (wave1Range * 0.1)
    bool hasChochDown = trendFromCHOCH_5M < 0 or trendFromCHOCH_15M < 0
    bool priceRejectedAtHH = not na(fibHH) and high >= fibHH * 0.99 and close < fibHH
    float bodySize = math.abs(close - open)
    float upperWick = high - math.max(close, open)
    float totalRange = high - low
    bool hasInvertedHammer = upperWick > (bodySize * 2.0) and upperWick > (totalRange * 0.5) and close < open and bodySize < (totalRange * 0.3)
    bool rejectionAtM5 = false
    if detectRejection
        float close_5M = request.security(syminfo.tickerid, "5", close, lookahead=barmerge.lookahead_off)
        float high_5M = request.security(syminfo.tickerid, "5", high, lookahead=barmerge.lookahead_off)
        float low_5M = request.security(syminfo.tickerid, "5", low, lookahead=barmerge.lookahead_off)
        float open_5M = request.security(syminfo.tickerid, "5", open, lookahead=barmerge.lookahead_off)
        float bodySize_5M = math.abs(close_5M - open_5M)
        float upperWick_5M = high_5M - math.max(close_5M, open_5M)
        float totalRange_5M = high_5M - low_5M
        rejectionAtM5 := atResistance and (upperWick_5M > (bodySize_5M * rejectionWickRatio) or (bodySize_5M < (totalRange_5M * 0.1) and close_5M < open_5M))
    bool rejectionAtResistance = (detectRejection and atResistance and bearishRejection) or rejectionAtM5
    bool priceActionExit = (tp1Reached or tp2Reached) and close < high[1] and (bearishRejection or (high - close > close - low))
    bool smartExitSignal = nearTarget and hasChochDown and priceRejectedAtHH and hasInvertedHammer
    bool shouldHoldByMACD = enableMACD and macdTrendHold_1H and macdTrendHold_4H
    bool exitByStop = close < stopLoss and not shouldHoldByMACD
    bool exitByTrend = isDowntrend and ta.crossunder(close, slowSMA) and not shouldHoldByMACD
    bool exitByTP = tp2Reached or tp3Reached
    bool hasRejectionAtResistance = rejectionAtResistance or (atResistance and checkSupportResistance)
    bool exitByRejection = hasRejectionAtResistance and not shouldHoldByMACD and not isStrongUptrend
    bool exitLong = smartExitSignal or exitByStop or exitByTrend or exitByTP or exitByRejection
    if not na(fibHH) and high > fibHH and not na(hlFirstCandleOpen)
        exitLong := exitLong or (close < hlFirstCandleOpen)
    if close < stopLoss
        exitLong := true
    [exitLong, tp1Reached, tp2Reached, tp3Reached, rejectionAtResistance, priceActionExit, smartExitSignal, hasRejectionAtResistance, nearTarget]

// Function: Execute Long Entry (à¸£à¸§à¸¡ entry logic à¹€à¸žà¸·à¹ˆà¸­à¸¥à¸” scopes)
executeLongEntry(string entryId, string waveType, string alertTitle, string discordTitle, float ewEntryPrice, int currentWaveForEntry, float ewStopLoss, float ewTP1, float ewTP2, float ewTP3, float fibRetracement618, float fibRetracement382, float fibLL, float fibHH, float fibHL, float firstWaveLL, float firstWaveHH, float wave1Low, float wave1High, int currentMajorWave, bool isImpulseWave, bool wave3Extended, int trendFromCHOCH_1H, bool isMajorWaveB, bool enableAlerts, bool sendEntrySignals, float macdLine, float signalLine, float rsiValue, float atrValue) =>
    float entry = na, float sl = na, float tp1 = na, float tp2 = na, float tp3 = na
    if waveType == "WaveA"
        [entry, sl, tp1, tp2, tp3] = executeLongWaveAEntry(ewEntryPrice, currentWaveForEntry, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibLL, fibHH, firstWaveLL, firstWaveHH)
    else if waveType == "WaveB"
        [entry, sl, tp1, tp2, tp3] = executeLongWaveBEntry(fibRetracement618, firstWaveLL, firstWaveHH, fibLL, fibHH, wave1Low, wave1High, currentMajorWave, isImpulseWave, wave3Extended)
    else if waveType == "MajorWaveB"
        [entry, sl, tp1, tp2, tp3] = executeLongMajorWaveBEntry(fibRetracement382, fibHL, firstWaveLL, fibLL, wave1Low, wave1High, currentMajorWave, isImpulseWave, wave3Extended, firstWaveHH)
    else if waveType == "Fallback"
        [entry, sl, tp1, tp2] = executeLongFallbackEntry(fibRetracement618, fibLL, fibHH)
        tp3 := na  // Fallback à¹„à¸¡à¹ˆà¸¡à¸µ tp3
    
    if not na(entry) and not na(sl)
        // à¹ƒà¸Šà¹‰ limit order à¹€à¸žà¸·à¹ˆà¸­à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¸—à¸µà¹ˆà¸£à¸²à¸„à¸²à¸—à¸µà¹ˆà¸à¸³à¸«à¸™à¸” (à¸›à¸¥à¸²à¸¢ wick) à¹à¸—à¸™ market order
        strategy.entry(entryId, strategy.long, limit=entry, comment=waveType + " Entry")
        setExitOrders(entryId + "_Exit", entryId, sl, tp1, tp2, tp3)
        if enableAlerts
            string tpInfo = (not na(tp1) ? " TP1: " + str.tostring(tp1) : "") + (not na(tp2) ? " TP2: " + str.tostring(tp2) : "") + (not na(tp3) ? " TP3: " + str.tostring(tp3) : "")
            alert(alertTitle + ": " + syminfo.ticker + " Entry: " + str.tostring(entry) + " SL: " + str.tostring(sl) + tpInfo, alert.freq_once_per_bar)
        if sendEntrySignals
            string macdTrend = macdLine > signalLine ? "Bullish" : "Bearish"
            string aiData = createAIData("BUY", waveType, entry, sl, tp1, tp2, tp3, currentMajorWave, isImpulseWave, macdTrend, rsiValue, atrValue)
            string desc = "**Entry:** " + str.tostring(entry, "#.##") + "\n**SL:** " + str.tostring(sl, "#.##") + "\n**TP1:** " + str.tostring(tp1, "#.##") + "\n**TP2:** " + str.tostring(tp2, "#.##") + (not na(tp3) ? "\n**TP3:** " + str.tostring(tp3, "#.##") : "") + "\n**Wave:** " + str.tostring(currentMajorWave) + "/5"
            sendDiscordAlert(discordTitle + " - " + syminfo.ticker, desc, "3066993", aiData)
    [entry, sl, tp1, tp2, tp3]

// Function: Execute Short Entry (à¸£à¸§à¸¡ entry logic à¹€à¸žà¸·à¹ˆà¸­à¸¥à¸” scopes)
executeShortEntry(string entryId, string waveType, string alertTitle, string discordTitle, float ewEntryPrice, int currentWaveForEntry, int trendFromCHOCH_1H, float ewStopLoss, float ewTP1, float ewTP2, float ewTP3, float fibRetracement618, float fibHH, float fibLL, float firstWaveHH, float firstWaveLL, bool enableAlerts, bool sendEntrySignals, float macdLine, float signalLine, float rsiValue, float atrValue) =>
    float entry = na, float sl = na, float tp1 = na, float tp2 = na, float tp3 = na
    if waveType == "WaveA"
        [entry, sl, tp1, tp2, tp3] = executeShortWaveAEntry(ewEntryPrice, currentWaveForEntry, trendFromCHOCH_1H, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibHH, fibLL, firstWaveHH, firstWaveLL)
    else if waveType == "WaveB"
        [entry, sl, tp1, tp2, tp3] = executeShortWaveBEntry(fibRetracement618, firstWaveHH, firstWaveLL, fibHH, fibLL)
    else if waveType == "Fallback"
        [entry, sl, tp1, tp2] = executeShortFallbackEntry(fibRetracement618, fibHH, fibLL)
        tp3 := na  // Fallback à¹„à¸¡à¹ˆà¸¡à¸µ tp3
    
    if not na(entry) and not na(sl)
        // à¹ƒà¸Šà¹‰ limit order à¹€à¸žà¸·à¹ˆà¸­à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¸—à¸µà¹ˆà¸£à¸²à¸„à¸²à¸—à¸µà¹ˆà¸à¸³à¸«à¸™à¸” (à¸›à¸¥à¸²à¸¢ wick) à¹à¸—à¸™ market order
        strategy.entry(entryId, strategy.short, limit=entry, comment=waveType + " Sell")
        if not na(tp2)
            strategy.exit(entryId + "_Exit", entryId, stop=sl, limit=tp2, qty_percent=100, comment="TP2")
        else if not na(tp1)
            strategy.exit(entryId + "_Exit", entryId, stop=sl, limit=tp1, qty_percent=100, comment="TP1")
        else
            strategy.exit(entryId + "_SL", entryId, stop=sl)
        if enableAlerts
            alert(alertTitle + ": " + syminfo.ticker + " Entry: " + str.tostring(entry) + " SL: " + str.tostring(sl), alert.freq_once_per_bar)
        if sendEntrySignals
            string macdTrend = macdLine > signalLine ? "Bullish" : "Bearish"
            string aiData = createAIData("SELL", waveType, entry, sl, tp1, tp2, na, 0, false, macdTrend, rsiValue, atrValue)
            string desc = "**Entry:** " + str.tostring(entry, "#.##") + "\n**SL:** " + str.tostring(sl, "#.##") + "\n**TP1:** " + str.tostring(tp1, "#.##") + "\n**TP2:** " + str.tostring(tp2, "#.##")
            sendDiscordAlert(discordTitle + " - " + syminfo.ticker, desc, "15158332", aiData)
    [entry, sl, tp1, tp2, tp3]

// Function: Execute Scale-in Entry at specific Fib level
executeScaleInEntry(string fibLevel, float fibRetracement, float fibLL, float fibHH, float firstWaveLL, float firstWaveHH, float positionPercent, bool waveAEntryCondition, bool waveBEntryCondition, bool fallbackEntryCondition, bool enableAlerts, string entryIdSuffix) =>
    float scaleInEntry = math.min(low, fibRetracement)
    float scaleInSL = not na(fibLL) ? fibLL : scaleInEntry * 0.99
    
    float scaleInTP1 = na, float scaleInTP2 = na, float scaleInTP3 = na
    if not na(firstWaveLL) and not na(firstWaveHH)
        float scaleInRange = firstWaveHH - firstWaveLL
        scaleInTP1 := scaleInEntry + (scaleInRange * 1.618)
        scaleInTP2 := scaleInEntry + (scaleInRange * 2.618)
        scaleInTP3 := scaleInEntry + (scaleInRange * 4.236)
    else if not na(fibLL) and not na(fibHH)
        float scaleInRange = fibHH - fibLL
        scaleInTP1 := scaleInEntry + (scaleInRange * 1.618)
        scaleInTP2 := scaleInEntry + (scaleInRange * 2.618)
        scaleInTP3 := scaleInEntry + (scaleInRange * 4.236)
    
    if not na(scaleInEntry) and not na(scaleInSL)
        // à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¸•à¸²à¸¡ Entry Signal Type
        if waveAEntryCondition
            strategy.entry("Long_WaveA_" + entryIdSuffix, strategy.long, limit=scaleInEntry, qty=positionPercent, comment="Scale-in " + fibLevel)
        else if waveBEntryCondition
            strategy.entry("Long_WaveB_" + entryIdSuffix, strategy.long, limit=scaleInEntry, qty=positionPercent, comment="Scale-in " + fibLevel)
        else if fallbackEntryCondition
            strategy.entry("Long_Fallback_" + entryIdSuffix, strategy.long, limit=scaleInEntry, qty=positionPercent, comment="Scale-in " + fibLevel)
        
        // Set exit orders
        string scaleInEntryId = waveAEntryCondition ? "Long_WaveA_" + entryIdSuffix : (waveBEntryCondition ? "Long_WaveB_" + entryIdSuffix : "Long_Fallback_" + entryIdSuffix)
        setExitOrders("ScaleIn_" + entryIdSuffix + "_Exit", scaleInEntryId, scaleInSL, scaleInTP1, scaleInTP2, scaleInTP3)
        
        if enableAlerts
            alert("ðŸŸ¡ Scale-in Entry " + fibLevel + " (" + str.tostring(positionPercent) + "%): " + syminfo.ticker + " @ " + str.tostring(scaleInEntry), alert.freq_once_per_bar)
    
    [scaleInEntry, scaleInSL, scaleInTP1, scaleInTP2, scaleInTP3]


// Function: Update Dashboard Entry Signal Info
updateDashboardEntrySignal(table marketDashboard, bool waveAEntryCondition, bool waveBEntryCondition, bool majorWaveBEntryCondition, bool fallbackEntryCondition, bool waveAShortEntryCondition, bool waveBShortEntryCondition, bool fallbackShortEntryCondition, float ewEntryPrice, int currentWaveForEntry, float ewStopLoss, float ewTP1, float ewTP2, float ewTP3, float fibRetracement618, float fibRetracement382, float fibLL, float fibHH, float fibHL, float firstWaveLL, float firstWaveHH, float wave1Low, float wave1High, int currentMajorWave, bool isImpulseWave, bool wave3Extended, int trendFromCHOCH_1H) =>
    int entrySignalRow = 17  // à¹€à¸žà¸´à¹ˆà¸¡à¸ˆà¸²à¸ 15 à¹€à¸›à¹‡à¸™ 17 à¹€à¸žà¸£à¸²à¸°à¹€à¸žà¸´à¹ˆà¸¡ M1 à¹à¸¥à¹‰à¸§
    bool hasEntrySignal = (waveAEntryCondition or waveBEntryCondition or majorWaveBEntryCondition or fallbackEntryCondition or waveAShortEntryCondition or waveBShortEntryCondition or fallbackShortEntryCondition) and strategy.position_size == 0
    
    if hasEntrySignal
        // Header
        table.cell(marketDashboard, 0, entrySignalRow, "Entry Signal", bgcolor=color.new(color.green, 20), text_color=color.white, text_size=size.small, text_halign=text.align_center)
        table.cell(marketDashboard, 1, entrySignalRow, "ACTIVE", bgcolor=color.new(color.green, 20), text_color=color.white, text_size=size.small, text_halign=text.align_center)
        
        // à¸£à¸°à¸šà¸¸à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¸­à¸¢à¸¹à¹ˆ
        string entryConditionText = ""
        if waveAEntryCondition
            entryConditionText := "Wave A Long"
        else if waveBEntryCondition
            entryConditionText := "Wave B Long"
        else if majorWaveBEntryCondition
            entryConditionText := "Major Wave B Long"
        else if fallbackEntryCondition
            entryConditionText := "Fallback Long"
        else if waveAShortEntryCondition
            entryConditionText := "Wave A Short"
        else if waveBShortEntryCondition
            entryConditionText := "Wave B Short"
        else if fallbackShortEntryCondition
            entryConditionText := "Fallback Short"
        
        table.cell(marketDashboard, 0, entrySignalRow + 1, "Condition", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        table.cell(marketDashboard, 1, entrySignalRow + 1, entryConditionText, bgcolor=color.new(color.green, 50), text_color=color.white, text_size=size.small)
        
        // à¸„à¸³à¸™à¸§à¸“ Entry Price, SL, TP
        float calcEntryPrice = na
        float calcSL = na
        float calcTP1 = na
        float calcTP2 = na
        float calcTP3 = na
        
        if waveAEntryCondition
            [calcEntryPrice, calcSL, calcTP1, calcTP2, calcTP3] = executeLongWaveAEntry(ewEntryPrice, currentWaveForEntry, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibLL, fibHH, firstWaveLL, firstWaveHH)
        else if waveBEntryCondition
            [calcEntryPrice, calcSL, calcTP1, calcTP2, calcTP3] = executeLongWaveBEntry(fibRetracement618, firstWaveLL, firstWaveHH, fibLL, fibHH, wave1Low, wave1High, currentMajorWave, isImpulseWave, wave3Extended)
        else if majorWaveBEntryCondition
            [calcEntryPrice, calcSL, calcTP1, calcTP2, calcTP3] = executeLongMajorWaveBEntry(fibRetracement382, fibHL, firstWaveLL, fibLL, wave1Low, wave1High, currentMajorWave, isImpulseWave, wave3Extended, firstWaveHH)
        else if fallbackEntryCondition
            [calcEntryPrice, calcSL, calcTP1, calcTP2] = executeLongFallbackEntry(fibRetracement618, fibLL, fibHH)
        else if waveAShortEntryCondition
            [calcEntryPrice, calcSL, calcTP1, calcTP2, calcTP3] = executeShortWaveAEntry(ewEntryPrice, currentWaveForEntry, trendFromCHOCH_1H, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibHH, fibLL, firstWaveHH, firstWaveLL)
        else if waveBShortEntryCondition
            [calcEntryPrice, calcSL, calcTP1, calcTP2, calcTP3] = executeShortWaveBEntry(fibRetracement618, firstWaveHH, firstWaveLL, fibHH, fibLL)
        else if fallbackShortEntryCondition
            [calcEntryPrice, calcSL, calcTP1, calcTP2] = executeShortFallbackEntry(fibRetracement618, fibHH, fibLL)
        
        // à¹à¸ªà¸”à¸‡ Entry Price
        table.cell(marketDashboard, 0, entrySignalRow + 2, "Entry", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        string entryPriceDisplay = not na(calcEntryPrice) ? str.tostring(calcEntryPrice, "#.##") : "N/A"
        table.cell(marketDashboard, 1, entrySignalRow + 2, entryPriceDisplay, bgcolor=color.new(color.blue, 50), text_color=color.white, text_size=size.small)
        
        // à¹à¸ªà¸”à¸‡ Stop Loss
        table.cell(marketDashboard, 0, entrySignalRow + 3, "SL", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        string slDisplay = not na(calcSL) ? str.tostring(calcSL, "#.##") : "N/A"
        table.cell(marketDashboard, 1, entrySignalRow + 3, slDisplay, bgcolor=color.new(color.red, 50), text_color=color.white, text_size=size.small)
        
        // à¹à¸ªà¸”à¸‡ Take Profit
        string tpDisplay = ""
        if not na(calcTP1)
            tpDisplay := "TP1: " + str.tostring(calcTP1, "#.##")
            if not na(calcTP2)
                tpDisplay := tpDisplay + " | TP2: " + str.tostring(calcTP2, "#.##")
            if not na(calcTP3)
                tpDisplay := tpDisplay + " | TP3: " + str.tostring(calcTP3, "#.##")
        else
            tpDisplay := "N/A"
        
        table.cell(marketDashboard, 0, entrySignalRow + 4, "TP", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        table.cell(marketDashboard, 1, entrySignalRow + 4, tpDisplay, bgcolor=color.new(color.green, 50), text_color=color.white, text_size=size.small)
    else
        // à¸‹à¹ˆà¸­à¸™ Entry Signal Info à¹€à¸¡à¸·à¹ˆà¸­à¹„à¸¡à¹ˆà¸¡à¸µà¸ªà¸±à¸à¸à¸²à¸“
        table.cell(marketDashboard, 0, entrySignalRow, "", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        table.cell(marketDashboard, 1, entrySignalRow, "", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 60), text_size=size.small)
        table.cell(marketDashboard, 0, entrySignalRow + 1, "", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        table.cell(marketDashboard, 1, entrySignalRow + 1, "", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 60), text_size=size.small)
        table.cell(marketDashboard, 0, entrySignalRow + 2, "", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        table.cell(marketDashboard, 1, entrySignalRow + 2, "", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 60), text_size=size.small)
        table.cell(marketDashboard, 0, entrySignalRow + 3, "", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        table.cell(marketDashboard, 1, entrySignalRow + 3, "", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 60), text_size=size.small)
        table.cell(marketDashboard, 0, entrySignalRow + 4, "", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        table.cell(marketDashboard, 1, entrySignalRow + 4, "", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 60), text_size=size.small)

// ============================================================================
// DIRECTION CONSTANTS (Pine Script v5 uses strategy.long and strategy.short)
// ============================================================================
// No need for constants - use strategy.long and strategy.short directly

// à¸à¸³à¸«à¸™à¸”à¸£à¸°à¸¢à¸°à¹€à¸§à¸¥à¸²à¸‚à¸­à¸‡ SMA
fastLength = input.int(7, "Fast SMA Length (Short-term)", minval=1, group="SMA Settings", tooltip="SMA 7 à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸ªà¸±à¹‰à¸™")
slowLength = input.int(21, "Slow SMA Length (Short-term)", minval=1, group="SMA Settings", tooltip="SMA 21 à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸ªà¸±à¹‰à¸™")
longSMA1 = input.int(99, "Long SMA 1 (Long-term)", minval=1, group="SMA Settings", tooltip="SMA 99 à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸¢à¸²à¸§ (H1, H4, Daily)")
longSMA2 = input.int(200, "Long SMA 2 (Long-term)", minval=1, group="SMA Settings", tooltip="SMA 200 à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸¢à¸²à¸§ (H1, H4, Daily)")

// Elliott Wave Settings
showElliottWave = input.bool(false, "Show Elliott Wave", group="Elliott Wave")  // à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹€à¸›à¹‡à¸™ false à¹€à¸žà¸·à¹ˆà¸­à¸¥à¸” main body
ewLength = input.int(15, "Elliott Wave Pivot Length", minval=1, maxval=50, group="Elliott Wave", tooltip="à¸„à¹ˆà¸²à¹ƒà¸«à¸à¹ˆà¸‚à¸¶à¹‰à¸™ = à¸ªà¸§à¸´à¸‡à¹ƒà¸«à¸à¹ˆà¸‚à¸¶à¹‰à¸™ (à¹à¸™à¸°à¸™à¸³: 10-20 à¸ªà¸³à¸«à¸£à¸±à¸šà¸ªà¸§à¸´à¸‡à¹ƒà¸«à¸à¹ˆ)")
showWaveCount = input.bool(false, "Show Wave Count Labels", group="Elliott Wave", tooltip="à¹à¸ªà¸”à¸‡à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£/à¸•à¸±à¸§à¹€à¸¥à¸‚ wave")  // à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹€à¸›à¹‡à¸™ false
showWaveInfo = input.bool(false, "Show Wave Info in Dashboard", group="Elliott Wave")  // à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹€à¸›à¹‡à¸™ false

// Signal Settings
atrLength = input.int(14, "ATR Length", minval=1, group="Signal Settings")
atrMultiplier = input.float(0.5, "ATR Multiplier for Sideways", minval=0.1, maxval=2.0, step=0.1, group="Signal Settings")

// Dashboard Settings
showDashboard = input.bool(true, "Show Dashboard", group="Dashboard")  // à¹à¸ªà¸”à¸‡ Dashboard à¹‚à¸”à¸¢ default
dashboardPosition = input.string("top_right", "Dashboard Position", options=["top_left", "top_right", "bottom_left", "bottom_right"], group="Dashboard")

// Alert Settings
enableAlerts = input.bool(true, "Enable Alerts", group="Alerts")

// Exit Settings
detectRejection = input.bool(true, "Detect Rejection Candles for Exit", group="Exit Settings", tooltip="Exit when rejection candle appears at support/resistance")
rejectionWickRatio = input.float(2.0, "Rejection Wick Ratio", minval=1.0, maxval=5.0, step=0.1, group="Exit Settings", tooltip="Wick must be X times the body size")
checkSupportResistance = input.bool(true, "Check Support/Resistance Levels", group="Exit Settings", tooltip="Exit when price reaches support/resistance zones")

// Fibonacci Trading System Settings
enableFibonacci = input.bool(true, "Enable Fibonacci Trading System", group="Fibonacci Trading")
showFibonacci = input.bool(false, "Show Fibonacci Levels", group="Fibonacci Trading")  // à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹€à¸›à¹‡à¸™ false à¹€à¸žà¸·à¹ˆà¸­à¸¥à¸” main body
showFibonacciTimeZone = input.bool(false, "Show Fibonacci Time Zone", group="Fibonacci Trading", tooltip="à¹à¸ªà¸”à¸‡ Fibonacci Time Zone à¸—à¸µà¹ˆà¸£à¸°à¸”à¸±à¸š 0.3 à¸ˆà¸²à¸à¸ªà¸§à¸´à¸‡à¹à¸£à¸ (LL à¹„à¸› HH)")  // à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹€à¸›à¹‡à¸™ false
showLimitEntryPoint = input.bool(true, "Show Limit Entry Point at Fib 61.8", group="Fibonacci Trading", tooltip="à¹à¸ªà¸”à¸‡à¸ˆà¸¸à¸”à¹€à¸‚à¹‰à¸²à¹à¸šà¸š Limit Order à¸—à¸µà¹ˆ Fib 61.8 à¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µ HH/LL à¹à¸¥à¸° CHOCH à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡")
fibLineColor = input.color(color.new(#FFD700, 0), "Fibonacci Line Color", group="Fibonacci Trading", tooltip="à¸ªà¸µà¹€à¸ªà¹‰à¸™ Fibonacci (à¸ªà¸µà¸—à¸­à¸‡/à¹€à¸«à¸¥à¸·à¸­à¸‡à¸ˆà¸°à¸Šà¸±à¸”à¹€à¸ˆà¸™)")
fibLabelColor = input.color(color.new(#FFD700, 0), "Fibonacci Label Color", group="Fibonacci Trading", tooltip="à¸ªà¸µà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡ Fibonacci")
fibTimeZoneColor = input.color(color.new(#FF8C00, 0), "Fibonacci Time Zone Color", group="Fibonacci Trading", tooltip="à¸ªà¸µà¹€à¸ªà¹‰à¸™ Fibonacci Time Zone (à¸£à¸°à¸”à¸±à¸š 0.3)")
fibEntryLevel = input.float(0.618, "Entry Fibonacci Level", minval=0.0, maxval=1.0, step=0.01, group="Fibonacci Trading", tooltip="Entry at this retracement level (0.618 = 61.8%)")
tp1Level = input.float(1.0, "TP1 Fibonacci Extension", minval=0.0, maxval=2.0, step=0.01, group="Fibonacci Trading", tooltip="First Take Profit at this extension level (POI1 = 100%)")
tp2Level = input.float(1.618, "TP2 Fibonacci Extension", minval=0.0, maxval=3.0, step=0.01, group="Fibonacci Trading", tooltip="Second Take Profit at this extension level (POI2 = 1.618%)")
useCHOCH = input.bool(true, "Require CHOCH for Entry", group="Fibonacci Trading", tooltip="Only enter after Change of Character confirmation")
stopLossATR = input.float(2.0, "Stop Loss (ATR Multiplier)", minval=0.5, maxval=5.0, step=0.1, group="Fibonacci Trading", tooltip="Stop Loss = Entry Price - (ATR * multiplier)")

// Scale-in Entry Settings (Position Sizing)
enableScaleInEntry = input.bool(true, "Enable Scale-in Entry", group="Fibonacci Trading", tooltip="à¹à¸šà¹ˆà¸‡ Position à¹€à¸‚à¹‰à¸²à¸—à¸µà¹ˆ Fib levels à¸•à¹ˆà¸²à¸‡à¹† (0.382=10%, 0.50=80%, 0.618=100%)")
fib382PositionPercent = input.float(10.0, "Fib 0.382 Position %", minval=0.0, maxval=100.0, step=1.0, group="Fibonacci Trading", tooltip="% à¸‚à¸­à¸‡ Position à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¸—à¸µà¹ˆ Fib 0.382")
fib50PositionPercent = input.float(70.0, "Fib 0.50 Position % (à¹€à¸žà¸´à¹ˆà¸¡)", minval=0.0, maxval=100.0, step=1.0, group="Fibonacci Trading", tooltip="% à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¹€à¸žà¸´à¹ˆà¸¡à¸—à¸µà¹ˆ Fib 0.50 (à¸£à¸§à¸¡à¸à¸±à¸š 0.382 = 80%)")
fib618PositionPercent = input.float(20.0, "Fib 0.618 Position % (à¹€à¸žà¸´à¹ˆà¸¡)", minval=0.0, maxval=100.0, step=1.0, group="Fibonacci Trading", tooltip="% à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¹€à¸žà¸´à¹ˆà¸¡à¸—à¸µà¹ˆ Fib 0.618 (à¸£à¸§à¸¡à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸” = 100%)")
fib786PositionPercent = input.float(0.0, "Fib 0.786 Position % (à¹€à¸žà¸´à¹ˆà¸¡)", minval=0.0, maxval=50.0, step=1.0, group="Fibonacci Trading", tooltip="% à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¹€à¸žà¸´à¹ˆà¸¡à¸—à¸µà¹ˆ Fib 0.786 (à¸–à¹‰à¸²à¸£à¸²à¸„à¸²à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸«à¸¥à¸¸à¸” LL, 0 = à¹„à¸¡à¹ˆà¹€à¸‚à¹‰à¸²)")

// Backtest Settings (for Strategy Tester)
commissionType = input.string("Percent", "Commission Type", options=["Percent", "Currency per Contract"], group="Backtest Settings", tooltip="Type of commission calculation")
commissionValue = input.float(0.1, "Commission (%)", minval=0.0, maxval=1.0, step=0.01, group="Backtest Settings", tooltip="Commission percentage per trade (0.1% = typical crypto exchange)")
commissionPerContract = input.float(0.0, "Commission (Currency)", minval=0.0, group="Backtest Settings", tooltip="Commission per contract in currency (e.g., USD)")
slippagePoints = input.int(2, "Slippage (Points)", minval=0, maxval=10, group="Backtest Settings", tooltip="Slippage in points for realistic backtesting")

// RSI Settings
rsiLength = input.int(14, "RSI Length", minval=1, group="RSI Settings")
rsiOversold = input.int(30, "RSI Oversold Level", minval=0, maxval=50, group="RSI Settings", tooltip="RSI level for buy signal (oversold)")
rsiOverbought = input.int(70, "RSI Overbought Level", minval=50, maxval=100, group="RSI Settings", tooltip="RSI level for sell signal (overbought)")

// MACD Settings
// MACD à¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¹€à¸—à¸£à¸”à¸•à¸²à¸¡à¹€à¸—à¸£à¸™à¸„à¸§à¸²à¸¡à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡ (à¹„à¸¡à¹ˆà¹à¸ªà¸”à¸‡à¸ªà¸±à¸à¸à¸²à¸“à¸šà¸™ chart)
// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: MACD line à¸•à¸±à¸”à¸‚à¸¶à¹‰à¸™à¹€à¸«à¸™à¸·à¸­ signal line à¹à¸¥à¸° MACD > 0 = à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¸—à¸µà¹ˆà¹à¸‚à¹‡à¸‡à¹à¸£à¸‡
enableMACD = input.bool(true, "Enable MACD", group="MACD Settings", tooltip="Enable MACD as trend strength condition (not signal)")
showMACD = input.bool(false, "Show MACD on Chart", group="MACD Settings", tooltip="Display MACD signals on chart (disabled by default - MACD is used as condition only)")
macdFastLength = input.int(12, "MACD Fast Length", minval=1, group="MACD Settings")
macdSlowLength = input.int(26, "MACD Slow Length", minval=1, group="MACD Settings")
macdSignalSmooth = input.int(9, "MACD Signal Smooth", minval=1, group="MACD Settings")
macdSource = input.source(close, "MACD Source", group="MACD Settings")
// useMACDCross à¹à¸¥à¸° requireMACDAboveZero à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰à¹à¸¥à¹‰à¸§ - à¹ƒà¸Šà¹‰à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: MACD à¸•à¸±à¸”à¸‚à¸¶à¹‰à¸™ + MACD > 0

// Advanced Entry Conditions
requireFVG = input.bool(true, "Require FVG before Entry", group="Advanced Entry", tooltip="Require Fair Value Gap before entry")
requireEngulfingOB = input.bool(true, "Require Engulfing Order Block", group="Advanced Entry", tooltip="Require Engulfing pattern in Order Block")
lookbackBars = input.int(50, "Lookback Bars for FVG/OB", minval=10, maxval=200, group="Advanced Entry", tooltip="Number of bars to look back for FVG and OB")
requireRejection = input.bool(false, "Require Rejection Candle at 61.8", group="Advanced Entry", tooltip="Require rejection candle at Fibonacci 61.8 level")
requireSupport = input.bool(false, "Require Support at 61.8", group="Advanced Entry", tooltip="Require FVG or OB support at Fibonacci 61.8 level")
requireSMAAbove = input.bool(false, "Require SMA Above Price", group="Advanced Entry", tooltip="Require SMA7/21 above price for retest")

// Divergence Settings (converted from v4 to v5)
enableDivergence = input.bool(true, "Enable Divergence Detection", group="Divergence", tooltip="Enable divergence detection for entry confirmation")
showDivergence = input.bool(false, "Show Divergence on Chart", group="Divergence", tooltip="Display divergence points on chart (disabled by default - divergence is used as condition only)")
divergencePivotPeriod = input.int(5, "Divergence Pivot Period", minval=1, maxval=50, group="Divergence")
divergenceType = input.string("Regular/Hidden", "Divergence Type", options=["Regular", "Hidden", "Regular/Hidden"], group="Divergence")
minDivergenceCount = input.int(1, "Minimum Divergence Count", minval=1, maxval=11, group="Divergence", tooltip="Minimum number of divergences required for signal")
maxPivotPoints = input.int(10, "Max Pivot Points to Check", minval=1, maxval=20, group="Divergence")
maxBarsDivergence = input.int(100, "Max Bars to Check", minval=30, maxval=200, group="Divergence")
requireDivergence = input.bool(false, "Require Divergence for Entry", group="Divergence", tooltip="Require divergence confirmation for entry")

// Divergence Indicator Settings
calcDivMACD = input.bool(true, "MACD Divergence", group="Divergence Indicators")
calcDivMACDHist = input.bool(true, "MACD Histogram Divergence", group="Divergence Indicators")
calcDivRSI = input.bool(true, "RSI Divergence", group="Divergence Indicators")
calcDivStoch = input.bool(false, "Stochastic Divergence", group="Divergence Indicators")
calcDivCCI = input.bool(false, "CCI Divergence", group="Divergence Indicators")
calcDivMOM = input.bool(false, "Momentum Divergence", group="Divergence Indicators")
calcDivOBV = input.bool(false, "OBV Divergence", group="Divergence Indicators")

// Divergence Visual Settings (à¹à¸ªà¸”à¸‡à¹€à¸‰à¸žà¸²à¸°à¸ˆà¸¸à¸” - à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¹€à¸ªà¹‰à¸™)
divRegDivColor = input.color(color.new(color.yellow, 50), "Regular Divergence Color", group="Divergence Visual")
divHidDivColor = input.color(color.new(color.lime, 50), "Hidden Divergence Color", group="Divergence Visual")
// showDivLines à¸–à¸¹à¸à¸¥à¸šà¸­à¸­à¸à¹à¸¥à¹‰à¸§ - à¹„à¸¡à¹ˆà¸¡à¸µà¸à¸²à¸£à¸§à¸²à¸”à¹€à¸ªà¹‰à¸™ divergence
showDivLabels = input.bool(false, "Show Divergence Labels", group="Divergence Visual")  // false à¹€à¸žà¸·à¹ˆà¸­à¸¥à¸” main body


// à¸„à¸³à¸™à¸§à¸“à¸„à¹ˆà¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¹€à¸„à¸¥à¸·à¹ˆà¸­à¸™à¸—à¸µà¹ˆ SMA à¹ƒà¸™ Timeframe 
fastSMA_1M = request.security(syminfo.tickerid, "1", ta.sma(close, fastLength)) // Corrected to "1" for 1-minute
slowSMA_1M = request.security(syminfo.tickerid, "1", ta.sma(close, slowLength))
fastSMA_5M = request.security(syminfo.tickerid, "5", ta.sma(close, fastLength)) // Corrected to "5" for 5-minute
slowSMA_5M = request.security(syminfo.tickerid, "5", ta.sma(close, slowLength))
fastSMA_15M = request.security(syminfo.tickerid, "15", ta.sma(close, fastLength)) // Corrected to "15" for 15-minute
slowSMA_15M = request.security(syminfo.tickerid, "15", ta.sma(close, slowLength))
fastSMA_30M = request.security(syminfo.tickerid, "30", ta.sma(close, fastLength)) // Corrected to "30" for 30-minute
slowSMA_30M = request.security(syminfo.tickerid, "30", ta.sma(close, slowLength))
// à¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸ªà¸±à¹‰à¸™: à¹ƒà¸Šà¹‰ SMA 7 à¹à¸¥à¸° SMA 21
fastSMA_1H = request.security(syminfo.tickerid, "60", ta.sma(close, fastLength)) // SMA 7 à¸ªà¸³à¸«à¸£à¸±à¸š 1H
slowSMA_1H = request.security(syminfo.tickerid, "60", ta.sma(close, slowLength)) // SMA 21 à¸ªà¸³à¸«à¸£à¸±à¸š 1H
// à¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸¢à¸²à¸§: à¹ƒà¸Šà¹‰ SMA 99 à¹à¸¥à¸° SMA 200 à¸ªà¸³à¸«à¸£à¸±à¸š H1, H4
longSMA99_1H = request.security(syminfo.tickerid, "60", ta.sma(close, longSMA1)) // SMA 99 à¸ªà¸³à¸«à¸£à¸±à¸š 1H
longSMA200_1H = request.security(syminfo.tickerid, "60", ta.sma(close, longSMA2)) // SMA 200 à¸ªà¸³à¸«à¸£à¸±à¸š 1H
longSMA99_4H = request.security(syminfo.tickerid, "240", ta.sma(close, longSMA1)) // SMA 99 à¸ªà¸³à¸«à¸£à¸±à¸š 4H
longSMA200_4H = request.security(syminfo.tickerid, "240", ta.sma(close, longSMA2)) // SMA 200 à¸ªà¸³à¸«à¸£à¸±à¸š 4H
// à¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸¢à¸²à¸§: à¹ƒà¸Šà¹‰ SMA 99 à¹à¸¥à¸° SMA 200 à¸ˆà¸²à¸ Daily
longSMA99_1D = request.security(syminfo.tickerid, "D", ta.sma(close, longSMA1)) // SMA 99 à¸ªà¸³à¸«à¸£à¸±à¸š Daily
longSMA200_1D = request.security(syminfo.tickerid, "D", ta.sma(close, longSMA2)) // SMA 200 à¸ªà¸³à¸«à¸£à¸±à¸š Daily
fastSMA_4H = request.security(syminfo.tickerid, "240", ta.sma(close, fastLength)) // SMA 7 à¸ªà¸³à¸«à¸£à¸±à¸š 4H
slowSMA_4H = request.security(syminfo.tickerid, "240", ta.sma(close, slowLength)) // SMA 21 à¸ªà¸³à¸«à¸£à¸±à¸š 4H
fastSMA_1D = request.security(syminfo.tickerid, "D", ta.sma(close, fastLength)) // SMA 7 à¸ªà¸³à¸«à¸£à¸±à¸š Daily
slowSMA_1D = request.security(syminfo.tickerid, "D", ta.sma(close, slowLength)) // SMA 21 à¸ªà¸³à¸«à¸£à¸±à¸š Daily
fastSMA_1W = request.security(syminfo.tickerid, "W", ta.sma(close, fastLength)) // Corrected to "W" for weekly
slowSMA_1W = request.security(syminfo.tickerid, "W", ta.sma(close, slowLength))

// à¸„à¸³à¸™à¸§à¸“à¸„à¹ˆà¸²à¹€à¸‰à¸¥à¸µà¹ˆà¸¢à¹€à¸„à¸¥à¸·à¹ˆà¸­à¸™à¸—à¸µà¹ˆ SMA à¹ƒà¸™ Timeframe à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™ (30M)
fastSMA_30minutes = ta.sma(close, fastLength)
slowSMA_30minutes = ta.sma(close, slowLength)
fastSMA = fastSMA_30minutes
slowSMA = slowSMA_30minutes

// à¸„à¸³à¸™à¸§à¸“ RSI (à¹ƒà¸Šà¹‰à¸ªà¸³à¸«à¸£à¸±à¸š entry timing à¸ˆà¸²à¸ TF 15M à¹à¸¥à¸° 30M)
rsiValue = ta.rsi(close, rsiLength)
rsiValue_15M = request.security(syminfo.tickerid, "15", ta.rsi(close, rsiLength))
rsiValue_30M = request.security(syminfo.tickerid, "30", ta.rsi(close, rsiLength))

// à¸„à¸³à¸™à¸§à¸“ MACD (à¹ƒà¸Šà¹‰à¸ªà¸³à¸«à¸£à¸±à¸š trend confirmation à¸ˆà¸²à¸ TF 1H à¹à¸¥à¸° 4H)
[macdLine, signalLine, macdHistogram] = ta.macd(macdSource, macdFastLength, macdSlowLength, macdSignalSmooth)
[macdLine_1H, signalLine_1H, macdHistogram_1H] = request.security(syminfo.tickerid, "60", ta.macd(close, macdFastLength, macdSlowLength, macdSignalSmooth))
[macdLine_4H, signalLine_4H, macdHistogram_4H] = request.security(syminfo.tickerid, "240", ta.macd(close, macdFastLength, macdSlowLength, macdSignalSmooth))

// MACD Conditions - à¹ƒà¸Šà¹‰à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¹€à¸—à¸£à¸”à¸•à¸²à¸¡à¹€à¸—à¸£à¸™à¸„à¸§à¸²à¸¡à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡ (à¸ˆà¸²à¸ TF 1H à¹à¸¥à¸° 4H)
// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: MACD line à¸•à¸±à¸”à¸‚à¸¶à¹‰à¸™à¹€à¸«à¸™à¸·à¸­ signal line à¹à¸¥à¸° MACD > 0 = à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¸—à¸µà¹ˆà¹à¸‚à¹‡à¸‡à¹à¸£à¸‡
macdBullishCross = ta.crossover(macdLine, signalLine)  // MACD line crosses above signal line (TF à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™)
macdBearishCross = ta.crossunder(macdLine, signalLine)  // MACD line crosses below signal line (TF à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™)
macdAboveZero = macdLine > 0  // MACD line above zero (bullish momentum)
macdBelowZero = macdLine < 0  // MACD line below zero (bearish momentum)

// MACD à¸ˆà¸²à¸ TF 1H à¹à¸¥à¸° 4H (à¹ƒà¸Šà¹‰à¸ªà¸³à¸«à¸£à¸±à¸š trend confirmation à¹à¸¥à¸° hold position)
macdBullishCross_1H = ta.crossover(macdLine_1H, signalLine_1H)  // MACD line crosses above signal line (TF 1H)
macdBearishCross_1H = ta.crossunder(macdLine_1H, signalLine_1H)  // MACD line crosses below signal line (TF 1H)
macdAboveZero_1H = macdLine_1H > 0  // MACD line above zero (TF 1H)
macdBullishCross_4H = ta.crossover(macdLine_4H, signalLine_4H)  // MACD line crosses above signal line (TF 4H)
macdBearishCross_4H = ta.crossunder(macdLine_4H, signalLine_4H)  // MACD line crosses below signal line (TF 4H)
macdAboveZero_4H = macdLine_4H > 0  // MACD line above zero (TF 4H)

// MACD Bullish Condition (simplified)
bool macdCrossedUp = macdBullishCross or (macdLine > signalLine and macdLine[1] <= signalLine[1])
bool macdBullishCondition = enableMACD ? (macdCrossedUp and macdAboveZero) : true

// MACD Trend Hold (simplified)
bool macdTrendHold_1H = enableMACD ? (not na(macdLine_1H) and not na(signalLine_1H) and macdLine_1H >= signalLine_1H) : true
bool macdTrendHold_4H = enableMACD ? (not na(macdLine_4H) and not na(signalLine_4H) and macdLine_4H >= signalLine_4H) : true

// ============================================================================
// DIVERGENCE DETECTION (converted from Pine Script v4 to v5)
// ============================================================================
// à¹ƒà¸Šà¹‰ pivot points à¸ˆà¸²à¸ swings_calc à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¹à¸¥à¹‰à¸§ (length = 50)
// à¹à¸›à¸¥à¸‡à¹‚à¸„à¹‰à¸” Divergence à¸ˆà¸²à¸ v4 à¹€à¸›à¹‡à¸™ v5 à¹à¸¥à¸°à¸œà¸ªà¸²à¸™à¹€à¸‚à¹‰à¸²à¸à¸±à¸šà¸£à¸°à¸šà¸š Elliott Wave + Fibonacci

// Divergence Variables - à¹€à¸à¹‡à¸š pivot points à¹à¸¥à¸° indicator values
var array<int> divPivotHighPositions = array.new<int>(maxPivotPoints, 0)
var array<int> divPivotLowPositions = array.new<int>(maxPivotPoints, 0)
var array<float> divPivotHighValues = array.new<float>(maxPivotPoints, 0.)
var array<float> divPivotLowValues = array.new<float>(maxPivotPoints, 0.)
var array<float> divRSIAtPivotHigh = array.new<float>(maxPivotPoints, 0.)
var array<float> divRSIAtPivotLow = array.new<float>(maxPivotPoints, 0.)
var array<float> divMACDAtPivotHigh = array.new<float>(maxPivotPoints, 0.)
var array<float> divMACDAtPivotLow = array.new<float>(maxPivotPoints, 0.)
var array<float> divMACDHistAtPivotHigh = array.new<float>(maxPivotPoints, 0.)
var array<float> divMACDHistAtPivotLow = array.new<float>(maxPivotPoints, 0.)

// Divergence Detection Flags (à¸›à¸£à¸°à¸à¸²à¸¨à¸•à¸±à¸§à¹à¸›à¸£ - logic à¸ˆà¸°à¸–à¸¹à¸à¸¢à¹‰à¸²à¸¢à¹„à¸›à¹„à¸§à¹‰à¸«à¸¥à¸±à¸‡ swings_calc)
// à¹à¸ªà¸”à¸‡à¹€à¸‰à¸žà¸²à¸°à¸ˆà¸¸à¸” divergence - à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¹€à¸ªà¹‰à¸™: à¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µ LL à¹à¸£à¸ â†’ à¸£à¸²à¸„à¸²à¹€à¸”à¹‰à¸‡à¸‚à¸¶à¹‰à¸™ â†’ à¸ªà¸£à¹‰à¸²à¸‡ LL à¹ƒà¸«à¸¡à¹ˆ = divergence à¹€à¸à¸´à¸”
var bool hasPositiveRegularDivergence = false  // Bullish divergence (price lower low, indicator higher) - LL à¹à¸£à¸ â†’ à¸£à¸²à¸„à¸²à¹€à¸”à¹‰à¸‡à¸‚à¸¶à¹‰à¸™ â†’ à¸ªà¸£à¹‰à¸²à¸‡ LL à¹ƒà¸«à¸¡à¹ˆ
var bool hasNegativeRegularDivergence = false  // Bearish divergence (price higher, indicator lower) - HH à¹à¸£à¸ â†’ à¸£à¸²à¸„à¸²à¹€à¸”à¹‰à¸‡à¸¥à¸‡ â†’ à¸ªà¸£à¹‰à¸²à¸‡ HH à¹ƒà¸«à¸¡à¹ˆ
var bool hasPositiveHiddenDivergence = false  // Bullish hidden divergence (price higher, indicator lower)
var bool hasNegativeHiddenDivergence = false  // Bearish hidden divergence (price lower, indicator higher)

// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: Divergence Detection Logic à¸ˆà¸°à¸–à¸¹à¸à¸¢à¹‰à¸²à¸¢à¹„à¸›à¹„à¸§à¹‰à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ [top, btm] = swings_calc(length)
// à¹€à¸žà¸£à¸²à¸° btm à¹à¸¥à¸° top à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¸—à¸µà¹ˆà¸ªà¹ˆà¸§à¸™à¸™à¸±à¹‰à¸™

// ============================================================================
// REJECTION CANDLE DETECTION
// ============================================================================
// à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸š Rejection Candles (Pin Bar, Doji, Hammer, Shooting Star)
bodySize = math.abs(close - open)
upperWick = high - math.max(close, open)
lowerWick = math.min(close, open) - low
totalRange = high - low

// Pin Bar (Rejection) - Upper wick à¸«à¸£à¸·à¸­ lower wick à¸¢à¸²à¸§à¸¡à¸²à¸
upperPinBar = upperWick > (bodySize * rejectionWickRatio) and upperWick > (totalRange * 0.6)
lowerPinBar = lowerWick > (bodySize * rejectionWickRatio) and lowerWick > (totalRange * 0.6)

// Doji - Body à¹€à¸¥à¹‡à¸à¸¡à¸²à¸
doji = bodySize < (totalRange * 0.1)

// Hammer - Lower wick à¸¢à¸²à¸§, upper wick à¸ªà¸±à¹‰à¸™, body à¸­à¸¢à¸¹à¹ˆà¸”à¹‰à¸²à¸™à¸šà¸™
hammer = lowerWick > (bodySize * rejectionWickRatio) and upperWick < (bodySize * 0.5) and close > open

// Shooting Star - Upper wick à¸¢à¸²à¸§, lower wick à¸ªà¸±à¹‰à¸™, body à¸­à¸¢à¸¹à¹ˆà¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡
shootingStar = upperWick > (bodySize * rejectionWickRatio) and lowerWick < (bodySize * 0.5) and close < open

// Bearish Rejection (à¸ªà¸³à¸«à¸£à¸±à¸š Long exit) - Upper pin bar, Shooting star, à¸«à¸£à¸·à¸­ Doji à¸—à¸µà¹ˆ resistance
bearishRejection = upperPinBar or shootingStar or (doji and close < open)

// Bullish Rejection (à¸ªà¸³à¸«à¸£à¸±à¸š Short exit) - Lower pin bar, Hammer, à¸«à¸£à¸·à¸­ Doji à¸—à¸µà¹ˆ support
bullishRejection = lowerPinBar or hammer or (doji and close > open)

// à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸šà¹à¸™à¸§à¹‚à¸™à¹‰à¸¡à¹ƒà¸™ TF(à¸‚à¸¶à¹‰à¸™à¸«à¸£à¸·à¸­à¸¥à¸‡) - à¸£à¸­à¸‡à¸£à¸±à¸šà¸—à¸±à¹‰à¸‡ SMA à¹à¸¥à¸° EMA
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: Structure method à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹„à¸”à¹‰ implement (à¸•à¹‰à¸­à¸‡à¸„à¸³à¸™à¸§à¸“ structure trend à¹à¸¢à¸à¹ƒà¸™à¹à¸•à¹ˆà¸¥à¸° timeframe)
// à¸ªà¸³à¸«à¸£à¸±à¸šà¸•à¸­à¸™à¸™à¸µà¹‰ Structure à¸ˆà¸°à¹ƒà¸Šà¹‰ SMA à¹€à¸›à¹‡à¸™à¸„à¹ˆà¸²à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™
bool isUptrend_1M = close > fastSMA_1M and fastSMA_1M > slowSMA_1M
bool isDowntrend_1M = close < fastSMA_1M and fastSMA_1M < slowSMA_1M
bool isUptrend_5M = close > fastSMA_5M and fastSMA_5M > slowSMA_5M
bool isDowntrend_5M = close < fastSMA_5M and fastSMA_5M < slowSMA_5M
bool isUptrend_15M = close > fastSMA_15M and fastSMA_15M > slowSMA_15M
bool isDowntrend_15M = close < fastSMA_15M and fastSMA_15M < slowSMA_15M
bool isUptrend_30M = close > fastSMA_30M and fastSMA_30M > slowSMA_30M
bool isDowntrend_30M = close < fastSMA_30M and fastSMA_30M < slowSMA_30M
bool isUptrend_1H = close > fastSMA_1H and fastSMA_1H > slowSMA_1H
bool isDowntrend_1H = close < fastSMA_1H and fastSMA_1H < slowSMA_1H
bool isUptrend_4H = close > fastSMA_4H and fastSMA_4H > slowSMA_4H
bool isDowntrend_4H = close < fastSMA_4H and fastSMA_4H < slowSMA_4H
bool isUptrend_1D = close > fastSMA_1D and fastSMA_1D > slowSMA_1D
bool isDowntrend_1D = close < fastSMA_1D and fastSMA_1D < slowSMA_1D
bool isUptrend_1W = close > fastSMA_1W and fastSMA_1W > slowSMA_1W
bool isDowntrend_1W = close < fastSMA_1W and fastSMA_1W < slowSMA_1W

// à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸šà¸à¸²à¸£à¸•à¸±à¸”à¸à¸±à¸™à¸‚à¸­à¸‡ SMA 7 à¹à¸¥à¸° SMA 21 à¹ƒà¸™ TF 1H
// buySignal à¹à¸¥à¸° sellSignal - à¸›à¸´à¸”à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™ (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰à¸à¸²à¸£à¸•à¸±à¸”à¸à¸±à¸™à¸‚à¸­à¸‡à¹€à¸ªà¹‰à¸™ SMA)
// buySignal = ta.crossover(fastSMA_30minutes, slowSMA_30minutes)
// sellSignal = ta.crossunder(fastSMA_30minutes, slowSMA_30minutes)

// ATR à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰à¹à¸¥à¹‰à¸§ - à¸¥à¸šà¸­à¸­à¸à¸ˆà¸²à¸à¸£à¸°à¸šà¸š
atrValue = 0.0

// à¸„à¸³à¸™à¸§à¸“à¸à¸²à¸£à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹à¸›à¸¥à¸‡à¸‚à¸­à¸‡à¸£à¸²à¸„à¸²
smaDifference = math.abs(fastSMA_30minutes - slowSMA_30minutes)

// à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸šà¸à¸²à¸£à¹„à¸‹à¹€à¸§à¸¢à¹Œ (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰ ATR à¹à¸¥à¹‰à¸§)
// à¹ƒà¸Šà¹‰ isSidewaysMarket à¹à¸—à¸™ (à¸ˆà¸°à¸›à¸£à¸°à¸à¸²à¸¨à¸‚à¹‰à¸²à¸‡à¸¥à¹ˆà¸²à¸‡)

// à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Price Action à¸ªà¸³à¸«à¸£à¸±à¸šà¹à¸™à¸§à¹‚à¸™à¹‰à¸¡à¸‚à¸¶à¹‰à¸™à¹à¸¥à¸°à¸¥à¸‡
isUptrend = close > fastSMA_30minutes and fastSMA_30minutes > slowSMA_30minutes
isDowntrend = close < fastSMA_30minutes and fastSMA_30minutes < slowSMA_30minutes

// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡: 1H + 30M + à¸£à¸²à¸„à¸²à¸›à¸´à¸” > SMA 21 (SMA 21 = slowSMA_30minutes)
// à¸–à¹‰à¸²à¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡ â†’ à¹„à¸¡à¹ˆà¹à¸ªà¸”à¸‡ Short signals, à¸‹à¹ˆà¸­à¸™à¹à¸™à¸§à¸•à¹‰à¸²à¸™
bool isStrongUptrend = isUptrend_1H and isUptrend_30M and close > slowSMA_30minutes

// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹€à¸—à¸£à¸™à¸‚à¸²à¸¥à¸‡à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡: 1H + 30M + à¸£à¸²à¸„à¸²à¸›à¸´à¸” < SMA 21
// à¸–à¹‰à¸²à¹€à¸—à¸£à¸™à¸‚à¸²à¸¥à¸‡à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡ â†’ à¹„à¸¡à¹ˆà¹à¸ªà¸”à¸‡ Long signals, à¸‹à¹ˆà¸­à¸™à¹à¸™à¸§à¸£à¸±à¸š
bool isStrongDowntrend = isDowntrend_1H and isDowntrend_30M and close < slowSMA_30minutes

// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š sideways: à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡à¹à¸¥à¸°à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¹€à¸—à¸£à¸™à¸‚à¸²à¸¥à¸‡à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡
// à¸Šà¹ˆà¸§à¸‡ sideways = à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µà¹€à¸—à¸£à¸™à¸”à¹Œà¸Šà¸±à¸”à¹€à¸ˆà¸™
bool isSidewaysMarket = not isStrongUptrend and not isStrongDowntrend

// à¹ƒà¸Šà¹‰ isSidewaysMarket à¸ªà¸³à¸«à¸£à¸±à¸š sideways detection
isSideways = isSidewaysMarket

// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¸‹à¸·à¹‰à¸­à¹à¸¥à¸°à¸‚à¸²à¸¢à¸•à¸²à¸¡à¹à¸™à¸§à¹‚à¸™à¹‰à¸¡ (à¹€à¸à¹‡à¸šà¹„à¸§à¹‰à¸ªà¸³à¸«à¸£à¸±à¸š compatibility)
// buyCondition à¹à¸¥à¸° sellCondition - à¸›à¸´à¸”à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™ (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰à¸à¸²à¸£à¸•à¸±à¸”à¸à¸±à¸™à¸‚à¸­à¸‡à¹€à¸ªà¹‰à¸™ SMA)
// buyCondition = buySignal and isUptrend
// sellCondition = sellSignal and isDowntrend

// ============================================================================
// ELLIOTT WAVE DETECTION & COUNTING
// ============================================================================
var int waveCount = 0
var float lastPivotHigh = na
var float lastPivotLow = na
var int lastPivotHighIndex = na
var int lastPivotLowIndex = na
var array<float> pivotHighs = array.new<float>()
var array<float> pivotLows = array.new<float>()
var array<int> pivotHighIndices = array.new<int>()
var array<int> pivotLowIndices = array.new<int>()

// Elliott Wave Counting Variables
var int currentWave = 0  // 1-5 à¸ªà¸³à¸«à¸£à¸±à¸š impulse, A-C à¸ªà¸³à¸«à¸£à¸±à¸š correction
var string wavePattern = ""  // "Impulse" à¸«à¸£à¸·à¸­ "Correction"
var bool isImpulseWave = true  // true = impulse (1-5), false = correction (A-C)
var int impulseWaveCount = 0  // à¸™à¸±à¸š impulse waves (1-5)
var int correctionWaveCount = 0  // à¸™à¸±à¸š correction waves (A-C)

// Elliott Wave Structure Tracking (à¸ªà¸³à¸«à¸£à¸±à¸šà¸„à¸³à¸™à¸§à¸“ TP)
var int currentMajorWave = 1  // à¸•à¸´à¸”à¸•à¸²à¸¡ wave à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™ (1-5 à¸ªà¸³à¸«à¸£à¸±à¸š Impulse, 1-3 à¸ªà¸³à¸«à¸£à¸±à¸š Correction)
var bool wave3Extended = false  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² Wave 3 à¹€à¸›à¹‡à¸™ extended wave à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ

// Major Wave (à¹€à¸§à¸Ÿà¹ƒà¸«à¸à¹ˆ) à¹à¸¥à¸° Minor Wave (à¹€à¸§à¸Ÿà¹€à¸¥à¹‡à¸)
var int majorImpulseCount = 0  // Major Impulse: I, II, III, IV, V
var int majorCorrectionCount = 0  // Major Correction: A, B, C
var int minorImpulseCount = 0  // Minor Impulse: 1, 2, 3, 4, 5 (à¸ à¸²à¸¢à¹ƒà¸™ Major Wave)
var int minorCorrectionCount = 0  // Minor Correction: a, b, c (à¸ à¸²à¸¢à¹ƒà¸™ Major Wave)
var bool isMajorWave = true  // true = Major Wave, false = Minor Wave
var int majorWaveCycle = 0  // à¸™à¸±à¸šà¸£à¸­à¸š Major Wave (à¹€à¸¡à¸·à¹ˆà¸­à¸ˆà¸š 5 waves = 1 cycle)

// à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¹à¸›à¸¥à¸‡à¸•à¸±à¸§à¹€à¸¥à¸‚à¹€à¸›à¹‡à¸™à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£à¸à¸³à¸à¸±à¸š Major Wave
getMajorWaveLabel(waveNum, isImpulse) =>
    if isImpulse
        waveNum == 1 ? "I" : waveNum == 2 ? "II" : waveNum == 3 ? "III" : waveNum == 4 ? "IV" : waveNum == 5 ? "V" : str.tostring(waveNum)
    else
        waveNum == 1 ? "A" : waveNum == 2 ? "B" : waveNum == 3 ? "C" : str.tostring(waveNum)

// à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¹à¸›à¸¥à¸‡à¸•à¸±à¸§à¹€à¸¥à¸‚à¹€à¸›à¹‡à¸™à¸•à¸±à¸§à¸­à¸±à¸à¸©à¸£à¸à¸³à¸à¸±à¸š Minor Wave
getMinorWaveLabel(waveNum, isImpulse) =>
    if isImpulse
        str.tostring(waveNum)
    else
        waveNum == 1 ? "a" : waveNum == 2 ? "b" : waveNum == 3 ? "c" : str.tostring(waveNum)

var bool lastWasHigh = false  // à¹€à¸à¹‡à¸šà¸§à¹ˆà¸² pivot à¸¥à¹ˆà¸²à¸ªà¸¸à¸”à¹€à¸›à¹‡à¸™ high à¸«à¸£à¸·à¸­ low
bool shouldAddHigh = true  // à¸•à¸±à¸§à¹à¸›à¸£à¸ªà¸³à¸«à¸£à¸±à¸šà¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸„à¸§à¸£à¹€à¸žà¸´à¹ˆà¸¡ pivot high à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
bool shouldAddLow = true  // à¸•à¸±à¸§à¹à¸›à¸£à¸ªà¸³à¸«à¸£à¸±à¸šà¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸„à¸§à¸£à¹€à¸žà¸´à¹ˆà¸¡ pivot low à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
string waveText = ""  // à¸•à¸±à¸§à¹à¸›à¸£à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸à¹‡à¸šà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡ wave label (Major-Minor format)
color labelColor = na  // à¸•à¸±à¸§à¹à¸›à¸£à¸ªà¸³à¸«à¸£à¸±à¸šà¸ªà¸µ label
color lineColor = na  // à¸•à¸±à¸§à¹à¸›à¸£à¸ªà¸³à¸«à¸£à¸±à¸šà¸ªà¸µà¹€à¸ªà¹‰à¸™
color boxColor = na  // à¸•à¸±à¸§à¹à¸›à¸£à¸ªà¸³à¸«à¸£à¸±à¸šà¸ªà¸µ box

// Elliott Wave Structure Storage - à¹€à¸à¹‡à¸š wave values à¸ªà¸³à¸«à¸£à¸±à¸šà¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸Ž Elliott Wave
var float wave1High = na
var float wave1Low = na
var float wave2Low = na
var float wave3High = na
var float wave3Low = na
var float wave4Low = na
var float wave5High = na
var float wave5Low = na
var int wave1HighIndex = na
var int wave1LowIndex = na
var int wave2LowIndex = na
var int wave3HighIndex = na
var int wave3LowIndex = na
var int wave4LowIndex = na
var int wave5HighIndex = na
var int wave5LowIndex = na

// Elliott Wave Validation Flags - à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸Ž Elliott Wave
bool ewRule1Valid = true  // Rule 1: Wave 2 à¹„à¸¡à¹ˆà¸„à¸§à¸£à¸•à¹ˆà¸³à¸à¸§à¹ˆà¸² Wave 1 (à¹ƒà¸™ uptrend)
bool ewRule2Valid = true  // Rule 2: Wave 4 à¹„à¸¡à¹ˆà¸„à¸§à¸£à¸—à¸±à¸š Wave 1 (à¹ƒà¸™ uptrend)
bool ewRule3Valid = true  // Rule 3: Wave 3 à¹„à¸¡à¹ˆà¸„à¸§à¸£à¸ªà¸±à¹‰à¸™à¸—à¸µà¹ˆà¸ªà¸¸à¸”
bool ewFibValid = true  // Fibonacci ratios à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ waves
bool ewStructureValid = true  // Wave structure (5-3-5, 3-3-5)

// Wave tracking
var int lastWaveBar = na
var float lastWavePrice = na

// Elliott Wave Counting - à¹ƒà¸Šà¹‰ TF 1H à¸ªà¸³à¸«à¸£à¸±à¸šà¸„à¸¥à¸·à¹ˆà¸™à¸«à¸¥à¸±à¸ (Major Structure)
// à¸™à¸±à¸šà¸„à¸¥à¸·à¹ˆà¸™à¸«à¸¥à¸±à¸à¸—à¸µà¹ˆ 1H à¹€à¸žà¸·à¹ˆà¸­à¸£à¸°à¸šà¸¸à¸§à¹ˆà¸²à¸•à¸­à¸™à¸™à¸µà¹‰à¸­à¸¢à¸¹à¹ˆà¸„à¸¥à¸·à¹ˆà¸™à¹ƒà¸«à¸à¹ˆà¸£à¸­à¸šà¹„à¸«à¸™ (à¹€à¸Šà¹ˆà¸™ Wave 2 à¹ƒà¸«à¸à¹ˆ à¹€à¸žà¸·à¹ˆà¸­à¸£à¸­ Wave 3)
ewPivotHigh_1H = request.security(syminfo.tickerid, "60", ta.pivothigh(high, ewLength, ewLength), lookahead=barmerge.lookahead_off)
ewPivotLow_1H = request.security(syminfo.tickerid, "60", ta.pivotlow(low, ewLength, ewLength), lookahead=barmerge.lookahead_off)

// à¹ƒà¸Šà¹‰ pivot à¸ˆà¸²à¸ TF 1H à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¸™à¸±à¸šà¸„à¸¥à¸·à¹ˆà¸™à¸«à¸¥à¸±à¸
ewPivotHigh = ewPivotHigh_1H
ewPivotLow = ewPivotLow_1H

// Store pivot highs
if not na(ewPivotHigh)
    pivotHighValue = ewPivotHigh
    pivotHighBar = bar_index - ewLength
    
    // à¹€à¸žà¸´à¹ˆà¸¡à¸—à¸¸à¸ pivot high à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸«à¹‡à¸™à¹€à¸ªà¹‰à¸™à¹à¸¥à¸° boxes
    shouldAddHigh := true
    if shouldAddHigh
        array.unshift(pivotHighs, pivotHighValue)
        array.unshift(pivotHighIndices, pivotHighBar)
        lastPivotHigh := pivotHighValue
        lastPivotHighIndex := pivotHighBar
        
        // Elliott Wave Counting Logic
        // Impulse: 1(up), 2(down), 3(up), 4(down), 5(up)
        // Correction: A(down), B(up), C(down)
        // Pivot High = Wave 1, 3, 5, B
        waveText = ""
        bool isValidWave = true  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸œà¹ˆà¸²à¸™à¸à¸Ž Elliott Wave à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
        
        if isImpulseWave
            // Impulse: High = 1, 3, 5 (odd numbers) - à¸™à¸±à¸š wave à¸—à¸µà¹ˆà¸ˆà¸¸à¸”à¸à¸¥à¸±à¸šà¸•à¸±à¸§à¸—à¸¸à¸à¸ˆà¸¸à¸”
            // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸„à¸§à¸£à¹€à¸›à¹‡à¸™ wave à¹„à¸«à¸™ (1, 3, à¸«à¸£à¸·à¸­ 5)
            if impulseWaveCount == 0 or impulseWaveCount == 2 or impulseWaveCount == 4
                int newWaveNumber = impulseWaveCount + 1
                
                // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸Ž Elliott Wave à¸à¹ˆà¸­à¸™à¸¢à¸­à¸¡à¸£à¸±à¸š wave (à¸ªà¸³à¸«à¸£à¸±à¸š validation)
                if newWaveNumber == 1
                    wave1High := pivotHighValue
                    wave1HighIndex := pivotHighBar
                    ewRule1Valid := true
                    ewRule2Valid := true
                    ewRule3Valid := true
                    ewFibValid := true
                    ewStructureValid := true
                else if newWaveNumber == 3 and not na(wave1Low) and not na(wave2Low) and not na(wave1High)
                    float wave1Length = wave1High - wave1Low
                    float wave3Length = pivotHighValue - wave2Low
                    ewRule1Valid := wave2Low >= wave1Low
                    ewRule3Valid := wave3Length >= wave1Length * 0.618
                    float wave3Ratio = wave3Length / wave1Length
                    ewFibValid := (wave3Ratio >= 1.0 and wave3Ratio <= 3.0)
                    int recentPivotCount = array.size(pivotLows) + array.size(pivotHighs)
                    ewStructureValid := recentPivotCount >= 5 or wave3Length >= wave1Length
                    wave3High := pivotHighValue
                    wave3HighIndex := pivotHighBar
                else if newWaveNumber == 5 and not na(wave4Low) and not na(wave1High) and not na(wave1Low) and not na(wave3High) and not na(wave3Low)
                    ewRule2Valid := wave4Low >= wave1High
                    float wave1Length = wave1High - wave1Low
                    float wave5Length = pivotHighValue - wave4Low
                    float wave5Ratio = wave5Length / wave1Length
                    ewFibValid := (wave5Ratio >= 0.5 and wave5Ratio <= 2.0)
                    float wave3Length = wave3High - wave3Low
                    ewStructureValid := wave5Length <= wave3Length * 1.5
                    wave5High := pivotHighValue
                    wave5HighIndex := pivotHighBar
                
                // à¸™à¸±à¸š wave à¸—à¸µà¹ˆà¸ˆà¸¸à¸”à¸à¸¥à¸±à¸šà¸•à¸±à¸§à¸—à¸¸à¸à¸ˆà¸¸à¸” (à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸œà¹ˆà¸²à¸™ validation)
                impulseWaveCount := newWaveNumber
                
                // à¹„à¸¡à¹ˆ reset wave counting - à¹ƒà¸«à¹‰à¸™à¸±à¸šà¸•à¹ˆà¸­à¹€à¸™à¸·à¹ˆà¸­à¸‡à¸•à¸±à¹‰à¸‡à¹à¸•à¹ˆà¹€à¸£à¸´à¹ˆà¸¡à¸à¸£à¸²à¸Ÿ
                // à¹à¸•à¹ˆà¸–à¹‰à¸²à¹€à¸à¸´à¸™ 5 à¹ƒà¸«à¹‰à¸§à¸™à¸à¸¥à¸±à¸šà¹„à¸›à¹€à¸£à¸´à¹ˆà¸¡à¹ƒà¸«à¸¡à¹ˆ (1-5) à¹à¸¥à¸°à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹€à¸›à¹‡à¸™ Correction
                if impulseWaveCount > 5
                    impulseWaveCount := 1
                    isImpulseWave := false
                    correctionWaveCount := 0
                    wave1High := na
                    wave1Low := na
                    wave2Low := na
                    wave3High := na
                    wave3Low := na
                    wave4Low := na
                    wave5High := na
                    wave5Low := na
                
                currentWave := impulseWaveCount
                wavePattern := "Impulse"
                waveText := str.tostring(impulseWaveCount)
                isValidWave := true
        else if correctionWaveCount == 1
            // à¸™à¸±à¸š wave à¸—à¸µà¹ˆà¸ˆà¸¸à¸”à¸à¸¥à¸±à¸šà¸•à¸±à¸§à¸—à¸¸à¸à¸ˆà¸¸à¸” (à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸œà¹ˆà¸²à¸™ validation)
            correctionWaveCount := 2
            currentWave := correctionWaveCount
            wavePattern := "Correction"
            // à¹à¸ªà¸”à¸‡ Wave letter: B (à¸•à¸²à¸¡à¸—à¸¤à¸©à¸Žà¸µ Elliott Wave - Correction Wave B)
            waveText := "B"
            isValidWave := true
        
        lastWasHigh := true
        
        // à¹à¸ªà¸”à¸‡ label à¸—à¸µà¹ˆà¸ˆà¸¸à¸”à¸à¸¥à¸±à¸šà¸•à¸±à¸§ (pivot high) - à¹à¸ªà¸”à¸‡à¸—à¸¸à¸à¸ˆà¸¸à¸”à¸—à¸µà¹ˆà¸•à¸£à¸§à¸ˆà¸žà¸š pivot
        if showElliottWave and showWaveCount and waveText != "" and not na(pivotHighBar) and not na(pivotHighValue)
            // à¹à¸ªà¸”à¸‡ label à¸—à¸µà¹ˆà¸ˆà¸¸à¸”à¸à¸¥à¸±à¸šà¸•à¸±à¸§à¸—à¸¸à¸à¸ˆà¸¸à¸”
            labelColor := color.new(color.blue, 70)
            waveLabel = label.new(pivotHighBar, pivotHighValue, text=waveText, style=label.style_label_down, color=labelColor, textcolor=color.blue, size=size.normal, tooltip="Elliott Wave " + waveText)
        
        // à¸­à¸±à¸›à¹€à¸”à¸• last wave position (à¹€à¸‰à¸žà¸²à¸° wave à¸—à¸µà¹ˆà¸œà¹ˆà¸²à¸™à¸à¸Ž Elliott Wave)
        if isValidWave
            lastWaveBar := pivotHighBar
            lastWavePrice := pivotHighValue
        
        // Keep only last 10 pivots
        if array.size(pivotHighs) > 10
            array.pop(pivotHighs)
            array.pop(pivotHighIndices)

// Store pivot lows
if not na(ewPivotLow)
    pivotLowValue = ewPivotLow
    pivotLowBar = bar_index - ewLength
    
    // à¹€à¸žà¸´à¹ˆà¸¡à¸—à¸¸à¸ pivot low à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸«à¹‡à¸™à¹€à¸ªà¹‰à¸™à¹à¸¥à¸° boxes
    shouldAddLow := true
    if shouldAddLow
        array.unshift(pivotLows, pivotLowValue)
        array.unshift(pivotLowIndices, pivotLowBar)
        lastPivotLow := pivotLowValue
        lastPivotLowIndex := pivotLowBar
        
        // Elliott Wave Counting Logic
        // Impulse: 1(up), 2(down), 3(up), 4(down), 5(up)
        // Correction: A(down), B(up), C(down)
        // Pivot Low = Wave 2, 4, A, C
        waveText = ""
        bool isValidWaveLow = true  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸œà¹ˆà¸²à¸™à¸à¸Ž Elliott Wave à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
        
        if isImpulseWave
            // Impulse: Low = 2, 4 (even numbers after odd) - à¸™à¸±à¸š wave à¸—à¸µà¹ˆà¸ˆà¸¸à¸”à¸à¸¥à¸±à¸šà¸•à¸±à¸§à¸—à¸¸à¸à¸ˆà¸¸à¸”
            if impulseWaveCount == 1 or impulseWaveCount == 3
                int newWaveNumber = impulseWaveCount + 1
                
                // à¸™à¸±à¸š wave à¸—à¸µà¹ˆà¸ˆà¸¸à¸”à¸à¸¥à¸±à¸šà¸•à¸±à¸§à¸—à¸¸à¸à¸ˆà¸¸à¸” (à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸œà¹ˆà¸²à¸™ validation)
                impulseWaveCount := newWaveNumber
                currentWave := impulseWaveCount
                wavePattern := "Impulse"
                waveText := str.tostring(impulseWaveCount)
                isValidWaveLow := true
                
                // à¸­à¸±à¸›à¹€à¸”à¸• wave storage à¸ªà¸³à¸«à¸£à¸±à¸šà¹ƒà¸Šà¹‰à¹ƒà¸™à¸à¸²à¸£à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸Ž (à¸–à¹‰à¸²à¸œà¹ˆà¸²à¸™ validation)
                if newWaveNumber == 2 and not na(wave1High) and not na(wave1Low)
                    float wave1Length = wave1High - wave1Low
                    float wave2Retracement = wave1High - pivotLowValue
                    ewRule1Valid := pivotLowValue >= wave1Low
                    ewFibValid := (wave2Retracement / wave1Length >= 0.236 and wave2Retracement / wave1Length <= 0.786)
                    ewStructureValid := (array.size(pivotLows) + array.size(pivotHighs)) >= 3
                    if ewRule1Valid and ewFibValid and ewStructureValid
                        wave2Low := pivotLowValue
                        wave2LowIndex := pivotLowBar
                else if newWaveNumber == 4 and not na(wave1High) and not na(wave3High) and not na(wave3Low)
                    float wave3Length = wave3High - wave3Low
                    float wave4Retracement = wave3High - pivotLowValue
                    ewRule2Valid := pivotLowValue >= wave1High
                    ewFibValid := (wave4Retracement / wave3Length >= 0.236 and wave4Retracement / wave3Length <= 0.618)
                    ewStructureValid := (array.size(pivotLows) + array.size(pivotHighs)) >= 3
                    if ewRule2Valid and ewFibValid and ewStructureValid
                        wave4Low := pivotLowValue
                        wave4LowIndex := pivotLowBar
        else
            // Correction: Low = A, C (downward in correction)
            if correctionWaveCount == 0
                // Wave A: à¹€à¸£à¸´à¹ˆà¸¡ correction wave
                correctionWaveCount := 1
                currentWave := correctionWaveCount
                wavePattern := "Correction"
                // à¹à¸ªà¸”à¸‡ Wave letter: A (à¸•à¸²à¸¡à¸—à¸¤à¸©à¸Žà¸µ Elliott Wave - Correction Wave A)
                waveText := "A"
                isValidWaveLow := true
            else if correctionWaveCount == 2
                bool isValidWaveC = true
                if array.size(pivotLows) >= 1 and array.size(pivotHighs) >= 1
                    float waveAHigh = array.size(pivotHighs) > 1 ? array.get(pivotHighs, 1) : na
                    float waveALow = array.size(pivotLows) > 1 ? array.get(pivotLows, 1) : na
                    float waveBHigh = array.size(pivotHighs) > 0 ? array.get(pivotHighs, 0) : na
                    if not na(waveAHigh) and not na(waveALow) and not na(waveBHigh)
                        float waveALength = waveAHigh - waveALow
                        float waveCLength = waveBHigh - pivotLowValue
                        isValidWaveC := (waveCLength / waveALength >= 0.618 and waveCLength / waveALength <= 2.618)
                // à¸™à¸±à¸š wave à¸—à¸µà¹ˆà¸ˆà¸¸à¸”à¸à¸¥à¸±à¸šà¸•à¸±à¸§à¸—à¸¸à¸à¸ˆà¸¸à¸” (à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸œà¹ˆà¸²à¸™ validation)
                correctionWaveCount := 3
                
                // à¹€à¸¡à¸·à¹ˆà¸­ Minor Correction à¸ˆà¸š 3 waves (A-B-C) à¹ƒà¸«à¹‰à¸à¸¥à¸±à¸šà¹„à¸› Impulse
                if correctionWaveCount > 3
                    correctionWaveCount := 0
                    isImpulseWave := true
                    impulseWaveCount := 0
                    wave1High := na
                    wave1Low := na
                    wave2Low := na
                    wave3High := na
                    wave3Low := na
                    wave4Low := na
                    wave5High := na
                    wave5Low := na
                
                currentWave := correctionWaveCount
                wavePattern := "Correction"
                // à¹à¸ªà¸”à¸‡ Wave letter: C (à¸•à¸²à¸¡à¸—à¸¤à¸©à¸Žà¸µ Elliott Wave - Correction Wave C)
                waveText := "C"
                isValidWaveLow := true
        
        lastWasHigh := false
        
        // à¹€à¸à¹‡à¸š Wave 1 low, Wave 3 low, Wave 5 low à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸«à¸¡à¸²à¸°à¸ªà¸¡ (à¸ªà¸³à¸«à¸£à¸±à¸šà¹ƒà¸Šà¹‰à¹ƒà¸™à¸à¸²à¸£à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸Ž)
        // à¹ƒà¸™ Elliott Wave: Wave 1 = LL â†’ HH (uptrend) à¸«à¸£à¸·à¸­ HH â†’ LL (downtrend)
        // à¸ªà¸³à¸«à¸£à¸±à¸š uptrend: Wave 1 low à¸„à¸§à¸£à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸à¹ˆà¸­à¸™ Wave 1 high
        // à¹€à¸à¹‡à¸š Wave 1 low à¸ˆà¸²à¸ pivot low à¸—à¸µà¹ˆà¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸à¹ˆà¸­à¸™à¸«à¸£à¸·à¸­à¹ƒà¸™à¸Šà¹ˆà¸§à¸‡à¹€à¸”à¸µà¸¢à¸§à¸à¸±à¸š Wave 1 high
        if not na(wave1HighIndex) and na(wave1Low) and pivotLowBar <= wave1HighIndex
            // Wave 1 low: à¹€à¸à¹‡à¸š low à¸—à¸µà¹ˆà¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸à¹ˆà¸­à¸™à¸«à¸£à¸·à¸­à¸žà¸£à¹‰à¸­à¸¡à¸à¸±à¸š Wave 1 high (à¸ªà¸³à¸«à¸£à¸±à¸š uptrend)
            wave1Low := pivotLowValue
            wave1LowIndex := pivotLowBar
        // à¹€à¸à¹‡à¸š Wave 3 low à¹à¸¥à¸° Wave 5 low à¸ªà¸³à¸«à¸£à¸±à¸šà¹ƒà¸Šà¹‰à¹ƒà¸™à¸à¸²à¸£à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸Ž (à¸–à¹‰à¸²à¸¡à¸µ)
        if not na(wave3HighIndex) and na(wave3Low) and impulseWaveCount == 3 and pivotLowBar <= wave3HighIndex
            // Wave 3 low: à¹€à¸à¹‡à¸š low à¸—à¸µà¹ˆà¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸à¹ˆà¸­à¸™à¸«à¸£à¸·à¸­à¸žà¸£à¹‰à¸­à¸¡à¸à¸±à¸š Wave 3 high
            wave3Low := pivotLowValue
            wave3LowIndex := pivotLowBar
        if not na(wave5HighIndex) and na(wave5Low) and impulseWaveCount == 5 and pivotLowBar <= wave5HighIndex
            // Wave 5 low: à¹€à¸à¹‡à¸š low à¸—à¸µà¹ˆà¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸à¹ˆà¸­à¸™à¸«à¸£à¸·à¸­à¸žà¸£à¹‰à¸­à¸¡à¸à¸±à¸š Wave 5 high
            wave5Low := pivotLowValue
            wave5LowIndex := pivotLowBar
        
        // à¹à¸ªà¸”à¸‡ label à¸—à¸µà¹ˆà¸ˆà¸¸à¸”à¸à¸¥à¸±à¸šà¸•à¸±à¸§ (pivot low) - à¹à¸ªà¸”à¸‡à¸—à¸¸à¸à¸ˆà¸¸à¸”à¸—à¸µà¹ˆà¸•à¸£à¸§à¸ˆà¸žà¸š pivot
        if showElliottWave and showWaveCount and waveText != "" and not na(pivotLowBar) and not na(pivotLowValue)
            // à¹à¸ªà¸”à¸‡ label à¸—à¸µà¹ˆà¸ˆà¸¸à¸”à¸à¸¥à¸±à¸šà¸•à¸±à¸§à¸—à¸¸à¸à¸ˆà¸¸à¸”
            labelColor := color.new(color.orange, 70)
            waveLabel = label.new(pivotLowBar, pivotLowValue, text=waveText, style=label.style_label_up, color=labelColor, textcolor=color.orange, size=size.normal, tooltip="Elliott Wave " + waveText)
        
        // à¸­à¸±à¸›à¹€à¸”à¸• last wave position (à¹€à¸‰à¸žà¸²à¸° wave à¸—à¸µà¹ˆà¸œà¹ˆà¸²à¸™à¸à¸Ž Elliott Wave)
        if isValidWaveLow
            lastWaveBar := pivotLowBar
            lastWavePrice := pivotLowValue
        
        // Keep only last 10 pivots
        if array.size(pivotLows) > 10
            array.pop(pivotLows)
            array.pop(pivotLowIndices)

// Elliott Wave Trend Detection - Higher highs and higher lows = uptrend
ewUptrend = false
ewDowntrend = false

if array.size(pivotHighs) >= 2 and array.size(pivotLows) >= 2
    recentHigh = array.get(pivotHighs, 0)
    previousHigh = array.get(pivotHighs, 1)
    recentLow = array.get(pivotLows, 0)
    previousLow = array.get(pivotLows, 1)
    
    // Uptrend: Higher highs and higher lows
    ewUptrend := recentHigh > previousHigh and recentLow > previousLow
    
    // Downtrend: Lower highs and lower lows
    ewDowntrend := recentHigh < previousHigh and recentLow < previousLow

// ============================================================================
// SWING TRADING CONDITIONS
// ============================================================================
// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸ªà¸³à¸«à¸£à¸±à¸š Swing Trading: à¸•à¹‰à¸­à¸‡à¸¡à¸µà¹à¸™à¸§à¹‚à¸™à¹‰à¸¡à¸—à¸µà¹ˆà¸Šà¸±à¸”à¹€à¸ˆà¸™à¹ƒà¸™à¸«à¸¥à¸²à¸¢ Timeframe
trendAlignment = 0
if isUptrend_15M and isUptrend_30M and isUptrend_1H
    trendAlignment := 1
else if isDowntrend_15M and isDowntrend_30M and isDowntrend_1H
    trendAlignment := -1

// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¸‹à¸·à¹‰à¸­à¸ªà¸³à¸«à¸£à¸±à¸š Swing Trading
// à¹ƒà¸Šà¹‰ Elliott Wave trend à¸–à¹‰à¸²à¸¡à¸µà¸‚à¹‰à¸­à¸¡à¸¹à¸¥ (array.size >= 2) à¹„à¸¡à¹ˆà¸‡à¸±à¹‰à¸™à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚
hasElliottWaveData = array.size(pivotHighs) >= 2 and array.size(pivotLows) >= 2
swingBuyCondition = false  // à¸›à¸´à¸”à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™ - à¹ƒà¸Šà¹‰à¹€à¸‰à¸žà¸²à¸° fibBuyCondition (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰à¸à¸²à¸£à¸•à¸±à¸”à¸à¸±à¸™à¸‚à¸­à¸‡à¹€à¸ªà¹‰à¸™ SMA)
swingSellCondition = false  // à¸›à¸´à¸”à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™

// Re-entry conditions for swing trading
reEntryBuy = isUptrend and ta.crossover(close, fastSMA_30minutes) and trendAlignment >= 0 and not isSideways
reEntrySell = isDowntrend and ta.crossunder(close, fastSMA_30minutes) and trendAlignment <= 0 and not isSideways

// à¸ªà¸±à¸à¸à¸²à¸“à¹„à¸‹à¹€à¸§à¸¢à¹Œ - à¸ªà¸µà¸¡à¸´à¸™à¸´à¸¡à¸­à¸¥
bgcolor(isSideways ? color.new(color.gray, 98) : na, title="Sideways Market")

// ============================================================================
// STRATEGY VARIABLES (à¸›à¸£à¸°à¸à¸²à¸¨à¸à¹ˆà¸­à¸™à¹ƒà¸Šà¹‰à¸‡à¸²à¸™)
// ============================================================================
// Exit conditions for Swing Trading (à¹ƒà¸Šà¹‰ trailing stop à¹à¸¥à¸° exit à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸—à¸£à¸™à¸”à¹Œà¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™)
var float highestPrice = na
var float lowestPrice = na
var bool justEnteredLong = false
var bool justEnteredShort = false
var float entryPrice = na  // à¹€à¸à¹‡à¸šà¸£à¸²à¸„à¸²à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸” (Fibonacci level) à¹€à¸žà¸·à¹ˆà¸­à¸„à¸³à¸™à¸§à¸“ % 
var int entryTime = na  // à¹€à¸à¹‡à¸šà¹€à¸§à¸¥à¸²à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”
var int entryIndex = na  // à¹€à¸à¹‡à¸š bar index à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”
var bool atResistance = false  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸­à¸¢à¸¹à¹ˆà¸—à¸µà¹ˆà¹à¸™à¸§à¸•à¹‰à¸²à¸™à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (à¸ˆà¸°à¸–à¸¹à¸à¸­à¸±à¸›à¹€à¸”à¸•à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Order Blocks)
var bool atSupport = false  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸­à¸¢à¸¹à¹ˆà¸—à¸µà¹ˆà¹à¸™à¸§à¸£à¸±à¸šà¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
bool exitLong = false  // à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¸­à¸­à¸à¸ˆà¸²à¸ Long position
bool exitShort = false  // à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¸­à¸­à¸à¸ˆà¸²à¸ Short position
bool rejectionAtResistance = false  // Rejection candle à¸—à¸µà¹ˆà¹à¸™à¸§à¸•à¹‰à¸²à¸™
bool rejectionAtSupport = false  // Rejection candle à¸—à¸µà¹ˆà¹à¸™à¸§à¸£à¸±à¸š
float stopLoss = na  // Stop Loss price
bool tp1Reached = false  // TP1 à¸–à¸¶à¸‡à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
bool tp2Reached = false  // TP2 à¸–à¸¶à¸‡à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
bool priceActionExit = false  // Price Action exit pattern
bool subWaveDetected = false  // Sub-wave detected à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
var float stopLossPrice = na  // à¹€à¸à¹‡à¸š Stop Loss price à¸—à¸µà¹ˆà¸•à¸±à¹‰à¸‡à¹„à¸§à¹‰à¸•à¸­à¸™à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”
var bool tp1HitAlert = false  // à¸ªà¸³à¸«à¸£à¸±à¸š alert condition TP1
var bool tp2HitAlert = false  // à¸ªà¸³à¸«à¸£à¸±à¸š alert condition TP2
var float m5BearishLow = na  // à¹€à¸à¹‡à¸š low à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡ M5 à¸ªà¸³à¸«à¸£à¸±à¸š Trailing Stop
var float m15OBHigh = na  // à¹€à¸à¹‡à¸š high à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡ M15 à¸ªà¸³à¸«à¸£à¸±à¸š OB zone Trailing Stop
var int m15OBBarIndex = na  // à¹€à¸à¹‡à¸š bar index à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡ M15
var bool rejectionPartialExited = false  // à¹€à¸à¹‡à¸šà¸ªà¸–à¸²à¸™à¸°à¸§à¹ˆà¸² partial exit à¸ˆà¸²à¸ rejection à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡

// Sideways Detection à¹à¸¥à¸° Breakout/Retest
var float sidewaysHigh = na  // à¹€à¸à¹‡à¸š high à¸‚à¸­à¸‡à¸Šà¹ˆà¸§à¸‡ sideways
var float sidewaysLow = na  // à¹€à¸à¹‡à¸š low à¸‚à¸­à¸‡à¸Šà¹ˆà¸§à¸‡ sideways
var bool sidewaysBreakoutUp = false  // à¸«à¸¥à¸¸à¸” sideways à¸‚à¸¶à¹‰à¸™
var bool sidewaysBreakoutDown = false  // à¸«à¸¥à¸¸à¸” sideways à¸¥à¸‡
var float breakoutLevel = na  // à¸£à¸°à¸”à¸±à¸šà¸—à¸µà¹ˆà¸«à¸¥à¸¸à¸” (à¹à¸™à¸§à¸£à¸±à¸šà¸«à¸£à¸·à¸­à¹à¸™à¸§à¸•à¹‰à¸²à¸™)
var bool isRetestingBreakout = false  // à¸à¸³à¸¥à¸±à¸‡à¸—à¸”à¸ªà¸­à¸šà¸£à¸°à¸”à¸±à¸šà¸—à¸µà¹ˆà¸«à¸¥à¸¸à¸”
var bool bosComplete = false  // BOS à¸—à¸µà¹ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ (à¸¡à¸µ retest à¹à¸¥à¹‰à¸§)

// Wave Entry Conditions
bool isWaveA = false  // Wave A (Wave 1 - CHOCH à¹à¸£à¸)
bool isWaveB = false  // Wave B (Sub-wave)

// à¸•à¸±à¸§à¹à¸›à¸£à¸•à¸´à¸”à¸•à¸²à¸¡à¸à¸²à¸£à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”
var bool swingEntryUsed = false

// à¹€à¸à¹‡à¸šà¸„à¹ˆà¸²à¸‹à¸´à¸à¹à¸™à¸¥à¹€à¸à¹ˆà¸² (Entry Signals History) - à¸–à¸¹à¸à¸¢à¹‰à¸²à¸¢à¹„à¸›à¹„à¸§à¹‰à¸—à¸µà¹ˆ GLOBAL VARIABLES à¹à¸¥à¹‰à¸§

// Wave 1 completion tracking
var bool wave1Completed = false
var bool waveAReached100Percent = false  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² Wave A à¸§à¸´à¹ˆà¸‡à¹„à¸› >= 100% à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡
var bool waveCCompleted = false  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² Wave C (1.618) à¸ˆà¸šà¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡
var float waveAHighestPrice = na  // à¸£à¸²à¸„à¸²à¸ªà¸¹à¸‡à¸ªà¸¸à¸”à¸‚à¸­à¸‡ Wave A (à¸ªà¸³à¸«à¸£à¸±à¸šà¸„à¸³à¸™à¸§à¸“ % gain)

// Multi-Timeframe CHOCH Detection - à¸ªà¸³à¸«à¸£à¸±à¸š Dashboard
// à¹ƒà¸Šà¹‰ CHOCH à¹€à¸žà¸·à¹ˆà¸­à¸¢à¸·à¸™à¸¢à¸±à¸™à¹€à¸—à¸£à¸™à¹ƒà¸™à¹à¸•à¹ˆà¸¥à¸° timeframe
var bool chochDetected_5M = false  // à¹€à¸à¹‡à¸šà¸§à¹ˆà¸²à¹€à¸à¸´à¸” CHOCH à¹à¸¥à¹‰à¸§à¹ƒà¸™ TF 5M
var bool chochDetected_15M = false  // à¹€à¸à¹‡à¸šà¸§à¹ˆà¸²à¹€à¸à¸´à¸” CHOCH à¹à¸¥à¹‰à¸§à¹ƒà¸™ TF 15M
var bool chochDetected_1H = false  // à¹€à¸à¹‡à¸šà¸§à¹ˆà¸²à¹€à¸à¸´à¸” CHOCH à¹à¸¥à¹‰à¸§à¹ƒà¸™ TF 1H
var bool chochDetected_4H = false  // à¹€à¸à¹‡à¸šà¸§à¹ˆà¸²à¹€à¸à¸´à¸” CHOCH à¹à¸¥à¹‰à¸§à¹ƒà¸™ TF 4H
var bool chochDetected_1D = false  // à¹€à¸à¹‡à¸šà¸§à¹ˆà¸²à¹€à¸à¸´à¸” CHOCH à¹à¸¥à¹‰à¸§à¹ƒà¸™ TF 1D
var bool chochDetected_30M = false  // à¹€à¸à¹‡à¸šà¸§à¹ˆà¸²à¹€à¸à¸´à¸” CHOCH à¹à¸¥à¹‰à¸§à¹ƒà¸™ TF 30M
var float chochPrice_5M = na
var float chochPrice_15M = na
var float chochPrice_1H = na
var float chochPrice_4H = na
var float chochPrice_1D = na
var float chochPrice_30M = na
var int chochIndex_5M = na
var int chochIndex_15M = na
var int chochIndex_1H = na
var int chochIndex_4H = na
var int chochIndex_1D = na
var int chochIndex_30M = na

// à¸•à¸±à¸§à¹à¸›à¸£à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸à¹‡à¸š trend à¸ˆà¸²à¸ CHOCH à¹ƒà¸™à¹à¸•à¹ˆà¸¥à¸° timeframe (1: bullish, -1: bearish, 0: sideways)
// à¹ƒà¸Šà¹‰à¹€à¸‰à¸žà¸²à¸° TF 1H, 4H, 15M, à¹à¸¥à¸° 5M à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¸™à¸±à¸šà¹€à¸§à¸Ÿ
var int trendFromCHOCH_5M = 0
var int trendFromCHOCH_15M = 0
var int trendFromCHOCH_1H = 0
var int trendFromCHOCH_4H = 0
var int trendFromCHOCH_1D = 0
var int trendFromCHOCH_30M = 0

// Wave Structure Tracking - à¸›à¸£à¸°à¸à¸²à¸¨à¸à¹ˆà¸­à¸™ Dashboard à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸Šà¹‰à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Dashboard
// à¹à¸¢à¸à¸Šà¸±à¹‰à¸™à¸‚à¸­à¸‡à¹€à¸§à¸Ÿà¸ˆà¸²à¸ TF à¹ƒà¸«à¸à¹ˆ â†’ Sub à¹€à¸§à¸Ÿà¹ƒà¸™ TF à¹€à¸¥à¹‡à¸
var string currentWaveTF = "N/A"  // Wave structure à¸ˆà¸²à¸ TF à¹ƒà¸«à¸à¹ˆ
var string currentSubWaveTF = "N/A"  // Sub wave structure à¸ˆà¸²à¸ TF à¹€à¸¥à¹‡à¸ (5M)

// ============================================================================
// MINIMAL DASHBOARD
// ============================================================================
var table marketDashboard = na

if showDashboard
    tablePosition = dashboardPosition == "top_left" ? position.top_left : 
                   dashboardPosition == "top_right" ? position.top_right :
                   dashboardPosition == "bottom_left" ? position.bottom_left : 
                   position.bottom_right
    
    if na(marketDashboard)
        // à¹€à¸žà¸´à¹ˆà¸¡à¸ˆà¸³à¸™à¸§à¸™à¹à¸–à¸§à¹€à¸›à¹‡à¸™ 22 à¹€à¸žà¸·à¹ˆà¸­à¸£à¸­à¸‡à¸£à¸±à¸š M1 à¹à¸¥à¸° Entry Signal Info (17-21)
        // Rows: 0=Header, 1-4=Major Structure, 5-7=Entry Timing, 8-10=Confirm & Risk (M1/M5), 11-12=Signal/Sideways, 13-14=Wave/Entry Price, 15-16=Exit/MACD, 17-21=Entry Signal Info
        marketDashboard := table.new(tablePosition, 2, 22, bgcolor=color.new(color.white, 98), border_width=1, border_color=color.new(color.gray, 50))
    
    // Header
    table.cell(marketDashboard, 0, 0, "TF", bgcolor=color.new(color.gray, 30), text_color=color.white, text_size=size.small)
    table.cell(marketDashboard, 1, 0, "Trend", bgcolor=color.new(color.gray, 30), text_color=color.white, text_size=size.small)
    
    // ============================================================================
    // MAJOR STRUCTURE (à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¸«à¸¥à¸±à¸) - 1H, 4H, 1D
    // à¹ƒà¸Šà¹‰à¸£à¸°à¸šà¸¸à¸§à¹ˆà¸²à¸•à¸­à¸™à¸™à¸µà¹‰à¸­à¸¢à¸¹à¹ˆà¸„à¸¥à¸·à¹ˆà¸™à¹ƒà¸«à¸à¹ˆà¸£à¸­à¸šà¹„à¸«à¸™ (à¹€à¸Šà¹ˆà¸™ Wave 2 à¹ƒà¸«à¸à¹ˆ à¹€à¸žà¸·à¹ˆà¸­à¸£à¸­ Wave 3)
    // à¸Šà¹ˆà¸§à¸¢à¸¥à¸”à¸ªà¸±à¸à¸à¸²à¸“à¸«à¸¥à¸­à¸
    // ============================================================================
    table.cell(marketDashboard, 0, 1, "Major Structure", bgcolor=color.new(color.blue, 20), text_color=color.white, text_size=size.small, text_halign=text.align_center)
    table.cell(marketDashboard, 1, 1, "1H/4H/1D", bgcolor=color.new(color.blue, 20), text_color=color.white, text_size=size.small, text_halign=text.align_center)
    
    // 1H (à¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸¢à¸²à¸§: à¹ƒà¸Šà¹‰ SMA 99 à¹à¸¥à¸° SMA 200)
    // à¸‚à¸²à¸‚à¸¶à¹‰à¸™: close > SMA 99 à¹à¸¥à¸° SMA 99 > SMA 200
    float close_1H = request.security(syminfo.tickerid, "60", close, lookahead=barmerge.lookahead_off)
    bool trend_1H = not na(longSMA99_1H) and not na(longSMA200_1H) and not na(close_1H) and close_1H > longSMA99_1H and longSMA99_1H > longSMA200_1H
    table.cell(marketDashboard, 0, 2, "1H (SMA99/200)", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
    table.cell(marketDashboard, 1, 2, trend_1H ? "â†‘" : "â†“", bgcolor=color.new(color.white, 100), text_color=trend_1H ? color.new(color.green, 20) : color.new(color.red, 20), text_size=size.small)
    
    // 4H (à¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸¢à¸²à¸§: à¹ƒà¸Šà¹‰ SMA 99 à¹à¸¥à¸° SMA 200)
    // à¸‚à¸²à¸‚à¸¶à¹‰à¸™: close > SMA 99 à¹à¸¥à¸° SMA 99 > SMA 200
    float close_4H = request.security(syminfo.tickerid, "240", close, lookahead=barmerge.lookahead_off)
    bool trend_4H = not na(longSMA99_4H) and not na(longSMA200_4H) and not na(close_4H) and close_4H > longSMA99_4H and longSMA99_4H > longSMA200_4H
    table.cell(marketDashboard, 0, 3, "4H (SMA99/200)", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
    table.cell(marketDashboard, 1, 3, trend_4H ? "â†‘" : "â†“", bgcolor=color.new(color.white, 100), text_color=trend_4H ? color.new(color.green, 20) : color.new(color.red, 20), text_size=size.small)
    
    // 1D (à¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸¢à¸²à¸§: à¹ƒà¸Šà¹‰ SMA 99 à¹à¸¥à¸° SMA 200 à¸ˆà¸²à¸ Daily)
    // à¸‚à¸²à¸‚à¸¶à¹‰à¸™: close > SMA 99 à¹à¸¥à¸° SMA 99 > SMA 200
    float close_1D = request.security(syminfo.tickerid, "D", close, lookahead=barmerge.lookahead_off)
    bool trend_1D = not na(longSMA99_1D) and not na(longSMA200_1D) and not na(close_1D) and close_1D > longSMA99_1D and longSMA99_1D > longSMA200_1D
    table.cell(marketDashboard, 0, 4, "1D (SMA99/200)", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
    table.cell(marketDashboard, 1, 4, trend_1D ? "â†‘" : "â†“", bgcolor=color.new(color.white, 100), text_color=trend_1D ? color.new(color.green, 20) : color.new(color.red, 20), text_size=size.small)
    
    // ============================================================================
    // ENTRY TIMING (à¸ˆà¸¸à¸”à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”) - M15, M30
    // à¹ƒà¸Šà¹‰à¸”à¸¹à¸„à¸¥à¸·à¹ˆà¸™à¸¢à¹ˆà¸­à¸¢ (subwaves) à¸ à¸²à¸¢à¹ƒà¸™à¸„à¸¥à¸·à¹ˆà¸™à¹ƒà¸«à¸à¹ˆ
    // à¸«à¸²à¸ˆà¸¸à¸”à¸à¸¥à¸±à¸šà¸•à¸±à¸§à¸—à¸µà¹ˆà¸Šà¸±à¸”à¹€à¸ˆà¸™ (CHOCH à¸«à¸£à¸·à¸­à¸à¸²à¸£à¹€à¸ªà¸µà¸¢à¸—à¸£à¸‡à¸‚à¸­à¸‡à¸„à¸¥à¸·à¹ˆà¸™à¸¢à¹ˆà¸­à¸¢)
    // ============================================================================
    table.cell(marketDashboard, 0, 5, "Entry Timing", bgcolor=color.new(color.orange, 20), text_color=color.white, text_size=size.small, text_halign=text.align_center)
    table.cell(marketDashboard, 1, 5, "M15/M30", bgcolor=color.new(color.orange, 20), text_color=color.white, text_size=size.small, text_halign=text.align_center)
    
    // M15 (à¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸ªà¸±à¹‰à¸™: à¹ƒà¸Šà¹‰ SMA 7 à¹à¸¥à¸° SMA 21)
    // à¸‚à¸²à¸‚à¸¶à¹‰à¸™: close > SMA 7 à¹à¸¥à¸° SMA 7 > SMA 21
    float close_15M = request.security(syminfo.tickerid, "15", close, lookahead=barmerge.lookahead_off)
    bool trend_15M = not na(fastSMA_15M) and not na(slowSMA_15M) and not na(close_15M) and close_15M > fastSMA_15M and fastSMA_15M > slowSMA_15M
    table.cell(marketDashboard, 0, 6, "M15 (SMA7/21)", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
    table.cell(marketDashboard, 1, 6, trend_15M ? "â†‘" : "â†“", bgcolor=color.new(color.white, 100), text_color=trend_15M ? color.new(color.green, 20) : color.new(color.red, 20), text_size=size.small)
    
    // M30 (à¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸ªà¸±à¹‰à¸™: à¹ƒà¸Šà¹‰ SMA 7 à¹à¸¥à¸° SMA 21)
    // à¸‚à¸²à¸‚à¸¶à¹‰à¸™: close > SMA 7 à¹à¸¥à¸° SMA 7 > SMA 21
    float close_30M = request.security(syminfo.tickerid, "30", close, lookahead=barmerge.lookahead_off)
    bool trend_30M = not na(fastSMA_30M) and not na(slowSMA_30M) and not na(close_30M) and close_30M > fastSMA_30M and fastSMA_30M > slowSMA_30M
    table.cell(marketDashboard, 0, 7, "M30 (SMA7/21)", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
    table.cell(marketDashboard, 1, 7, trend_30M ? "â†‘" : "â†“", bgcolor=color.new(color.white, 100), text_color=trend_30M ? color.new(color.green, 20) : color.new(color.red, 20), text_size=size.small)
    
    // ============================================================================
    // CONFIRMATION & RISK MANAGEMENT (à¸„à¸­à¸™à¹€à¸Ÿà¸´à¸£à¹Œà¸¡à¹à¸¥à¸°à¸„à¸¸à¸¡à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¹ˆà¸¢à¸‡) - M1, M5
    // à¸”à¸¹ Price Action à¸«à¸£à¸·à¸­à¸ªà¸±à¸à¸à¸²à¸“ RSI Divergence à¹ƒà¸™à¸ˆà¸±à¸‡à¸«à¸§à¸°à¸—à¸µà¹ˆà¸£à¸²à¸„à¸²à¹à¸•à¸°à¹‚à¸‹à¸™à¹€à¸‚à¹‰à¸²
    // à¸Šà¹ˆà¸§à¸¢à¹ƒà¸«à¹‰à¸¡à¸µ Stop Loss à¸—à¸µà¹ˆà¹à¸„à¸šà¸—à¸µà¹ˆà¸ªà¸¸à¸” à¹€à¸žà¸·à¹ˆà¸­à¹€à¸žà¸´à¹ˆà¸¡ Risk:Reward à¹ƒà¸«à¹‰à¸ªà¸¹à¸‡à¸‚à¸¶à¹‰à¸™
    // ============================================================================
    table.cell(marketDashboard, 0, 8, "Confirm & Risk", bgcolor=color.new(color.green, 20), text_color=color.white, text_size=size.small, text_halign=text.align_center)
    table.cell(marketDashboard, 1, 8, "M1/M5", bgcolor=color.new(color.green, 20), text_color=color.white, text_size=size.small, text_halign=text.align_center)
    
    // M1 (à¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸ªà¸±à¹‰à¸™: à¹ƒà¸Šà¹‰ SMA 7 à¹à¸¥à¸° SMA 21)
    // à¸‚à¸²à¸‚à¸¶à¹‰à¸™: close > SMA 7 à¹à¸¥à¸° SMA 7 > SMA 21
    float close_1M = request.security(syminfo.tickerid, "1", close, lookahead=barmerge.lookahead_off)
    bool trend_1M = not na(fastSMA_1M) and not na(slowSMA_1M) and not na(close_1M) and close_1M > fastSMA_1M and fastSMA_1M > slowSMA_1M
    table.cell(marketDashboard, 0, 9, "M1 (SMA7/21)", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
    table.cell(marketDashboard, 1, 9, trend_1M ? "â†‘" : "â†“", bgcolor=color.new(color.white, 100), text_color=trend_1M ? color.new(color.green, 20) : color.new(color.red, 20), text_size=size.small)
    
    // M5 (à¹€à¸—à¸£à¸™à¸”à¹Œà¸£à¸°à¸¢à¸°à¸ªà¸±à¹‰à¸™: à¹ƒà¸Šà¹‰ SMA 7 à¹à¸¥à¸° SMA 21)
    // à¸‚à¸²à¸‚à¸¶à¹‰à¸™: close > SMA 7 à¹à¸¥à¸° SMA 7 > SMA 21
    float close_5M = request.security(syminfo.tickerid, "5", close, lookahead=barmerge.lookahead_off)
    bool trend_5M = not na(fastSMA_5M) and not na(slowSMA_5M) and not na(close_5M) and close_5M > fastSMA_5M and fastSMA_5M > slowSMA_5M
    table.cell(marketDashboard, 0, 10, "M5 (SMA7/21)", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
    table.cell(marketDashboard, 1, 10, trend_5M ? "â†‘" : "â†“", bgcolor=color.new(color.white, 100), text_color=trend_5M ? color.new(color.green, 20) : color.new(color.red, 20), text_size=size.small)
    
    // ============================================================================
    // SIGNAL & STATUS
    // ============================================================================
    table.cell(marketDashboard, 0, 11, "Signal", bgcolor=color.new(color.gray, 40), text_color=color.white, text_size=size.small)
    // fibBuyCondition à¸ˆà¸°à¸–à¸¹à¸à¸„à¸³à¸™à¸§à¸“à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Fibonacci Trading System (à¸«à¸¥à¸±à¸‡à¸ªà¹ˆà¸§à¸™à¸™à¸µà¹‰)
    // à¹ƒà¸Šà¹‰à¸„à¹ˆà¸²à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸à¹ˆà¸­à¸™
    signalText = "WAIT"
    signalColor = color.new(color.gray, 60)
    table.cell(marketDashboard, 1, 11, signalText, bgcolor=signalColor, text_color=color.white, text_size=size.small)
    
    // à¹à¸ªà¸”à¸‡ Sideways à¸žà¸£à¹‰à¸­à¸¡à¸•à¸µà¸à¸£à¸­à¸šà¹€à¸¡à¸·à¹ˆà¸­à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™ Sideways
    // à¸–à¹‰à¸²à¸«à¸¥à¸¸à¸” Sideways à¹ƒà¸«à¹‰à¹à¸ªà¸”à¸‡à¹€à¸—à¸£à¸™ (à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¸«à¸£à¸·à¸­à¸‚à¸²à¸¥à¸‡)
    string sidewaysText = ""
    color sidewaysBgColor = color.new(color.white, 100)
    color sidewaysTextColor = color.new(color.gray, 10)
    
    if isSideways
        // à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™ Sideways = à¸•à¸µà¸à¸£à¸­à¸šà¸ªà¸µà¸ªà¹‰à¸¡/à¹€à¸«à¸¥à¸·à¸­à¸‡à¹ƒà¸«à¹‰à¹€à¸«à¹‡à¸™à¸Šà¸±à¸”
        sidewaysText := "SIDEWAYS"
        sidewaysBgColor := color.new(color.orange, 0)  // à¸ªà¸µà¸ªà¹‰à¸¡à¹€à¸‚à¹‰à¸¡ (à¸•à¸µà¸à¸£à¸­à¸š)
        sidewaysTextColor := color.white
    else if sidewaysBreakoutUp
        // à¸«à¸¥à¸¸à¸” Sideways à¸‚à¸¶à¹‰à¸™ = à¸‚à¸²à¸‚à¸¶à¹‰à¸™
        sidewaysText := "â†‘ UPTREND"
        sidewaysBgColor := color.new(color.green, 20)
        sidewaysTextColor := color.new(color.green, 0)
    else if sidewaysBreakoutDown
        // à¸«à¸¥à¸¸à¸” Sideways à¸¥à¸‡ = à¸‚à¸²à¸¥à¸‡
        sidewaysText := "â†“ DOWNTREND"
        sidewaysBgColor := color.new(color.red, 20)
        sidewaysTextColor := color.new(color.red, 0)
    else
        // à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ Sideways à¹à¸¥à¸°à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸«à¸¥à¸¸à¸” = à¹à¸ªà¸”à¸‡ "No"
        sidewaysText := "No"
        sidewaysBgColor := color.new(color.white, 100)
        sidewaysTextColor := color.new(color.gray, 10)
    
    table.cell(marketDashboard, 0, 12, "Sideways", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
    table.cell(marketDashboard, 1, 12, sidewaysText, bgcolor=sidewaysBgColor, text_color=sidewaysTextColor, text_size=size.small)
    
    // à¹à¸ªà¸”à¸‡ Wave Count à¹ƒà¸™ Dashboard - à¹à¸ªà¸”à¸‡à¸à¸²à¸£à¸™à¸±à¸šà¹€à¸§à¸Ÿà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸” (Major-Minor)
    // Wave Count à¸ˆà¸²à¸ TF 1H (à¸„à¸¥à¸·à¹ˆà¸™à¸«à¸¥à¸±à¸)
    string waveInfoText = showWaveInfo ? (wavePattern == "Impulse" ? str.tostring(impulseWaveCount) + "/5" : wavePattern == "Correction" ? (correctionWaveCount == 1 ? "A" : correctionWaveCount == 2 ? "B" : correctionWaveCount == 3 ? "C" : "?") + "/3" : "Waiting...") : ""
    color waveInfoColor = showWaveInfo ? (wavePattern == "Impulse" ? color.new(color.blue, 50) : wavePattern == "Correction" ? color.new(color.orange, 50) : color.new(color.gray, 60)) : color.new(color.gray, 60)
    string entryPriceText = not na(entryPrice) ? str.tostring(entryPrice, "#.##") : "N/A"
    
    if showWaveInfo
        table.cell(marketDashboard, 0, 13, "Wave (1H)", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        table.cell(marketDashboard, 1, 13, waveInfoText, bgcolor=waveInfoColor, text_color=color.white, text_size=size.small)
        table.cell(marketDashboard, 0, 14, "Entry Price", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        table.cell(marketDashboard, 1, 14, entryPriceText, bgcolor=color.new(color.white, 100), text_color=not na(entryPrice) ? color.new(color.blue, 20) : color.new(color.gray, 60), text_size=size.small)
    else
        table.cell(marketDashboard, 0, 13, "Entry Price", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        table.cell(marketDashboard, 1, 13, entryPriceText, bgcolor=color.new(color.white, 100), text_color=not na(entryPrice) ? color.new(color.blue, 20) : color.new(color.gray, 60), text_size=size.small)
    
    // à¹à¸ªà¸”à¸‡ Exit Info à¹ƒà¸™ Dashboard
    int exitRow = showWaveInfo ? 16 : 15  // à¹€à¸žà¸´à¹ˆà¸¡à¸ˆà¸²à¸ 15/14 à¹€à¸›à¹‡à¸™ 16/15 à¹€à¸žà¸£à¸²à¸°à¹€à¸žà¸´à¹ˆà¸¡ M1 à¹à¸¥à¹‰à¸§
    table.cell(marketDashboard, 0, exitRow, "Exit", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
    // à¸„à¸³à¸™à¸§à¸“ % profit/loss à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™ (à¸–à¹‰à¸²à¸¢à¸±à¸‡à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™ position)
    float currentPercent = 0.0
    string exitInfoText = "N/A"
    color exitInfoColor = color.new(color.gray, 60)
    
    if strategy.position_size > 0 and not na(entryPrice)
        currentPercent := ((close - entryPrice) / entryPrice) * 100
        exitInfoText := "Long " + (currentPercent > 0 ? "+" : "") + str.tostring(currentPercent, "#.##") + "%"
        exitInfoColor := currentPercent > 0 ? color.new(color.green, 50) : color.new(color.red, 50)
    else if strategy.position_size < 0 and not na(entryPrice)
        currentPercent := ((entryPrice - close) / entryPrice) * 100  // à¸ªà¸³à¸«à¸£à¸±à¸š Short
        exitInfoText := "Short " + (currentPercent > 0 ? "+" : "") + str.tostring(currentPercent, "#.##") + "%"
        exitInfoColor := currentPercent > 0 ? color.new(color.green, 50) : color.new(color.red, 50)
    else if exitReason != ""
        exitInfoText := exitReason + " " + (exitPercent > 0 ? "+" : "") + str.tostring(exitPercent, "#.##") + "%"
        exitInfoColor := exitPercent > 0 ? color.new(color.green, 50) : exitPercent < 0 ? color.new(color.red, 50) : color.new(color.gray, 60)
    
    table.cell(marketDashboard, 1, exitRow, exitInfoText, bgcolor=exitInfoColor, text_color=color.white, text_size=size.small)
    
    // MACD Status (simplified)
    if enableMACD and barstate.islast
        int macdRow = showWaveInfo ? 16 : 15  // à¹€à¸žà¸´à¹ˆà¸¡à¸ˆà¸²à¸ 15/14 à¹€à¸›à¹‡à¸™ 16/15 à¹€à¸žà¸£à¸²à¸°à¹€à¸žà¸´à¹ˆà¸¡ M1 à¹à¸¥à¹‰à¸§
        table.cell(marketDashboard, 0, macdRow, "MACD", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        string macdStatusText = not na(macdLine) and not na(signalLine) ? (macdBullishCondition ? "â†‘ Strong" : macdLine > signalLine ? "â†‘ Weak" : "â†“ Bear") : "N/A"
        color macdStatusColor = not na(macdLine) and not na(signalLine) ? (macdBullishCondition ? color.new(color.green, 50) : macdLine > signalLine ? color.new(color.orange, 50) : color.new(color.red, 50)) : color.new(color.gray, 60)
        table.cell(marketDashboard, 1, macdRow, macdStatusText, bgcolor=macdStatusColor, text_color=color.white, text_size=size.small)
    
    // à¹à¸ªà¸”à¸‡ Divergence Status à¹ƒà¸™ Dashboard
    if enableDivergence and barstate.islast
        int divRow = showWaveInfo ? 15 : 14
        table.cell(marketDashboard, 0, divRow, "Divergence", bgcolor=color.new(color.white, 100), text_color=color.new(color.gray, 10), text_size=size.small)
        string divStatusText = hasPositiveRegularDivergence ? "â†‘ Regular" : hasNegativeRegularDivergence ? "â†“ Regular" : hasPositiveHiddenDivergence ? "â†‘ Hidden" : hasNegativeHiddenDivergence ? "â†“ Hidden" : "N/A"
        color divStatusColor = hasPositiveRegularDivergence ? color.new(color.green, 50) : hasNegativeRegularDivergence ? color.new(color.red, 50) : (hasPositiveHiddenDivergence or hasNegativeHiddenDivergence) ? color.new(color.orange, 50) : color.new(color.gray, 60)
        table.cell(marketDashboard, 1, divRow, divStatusText, bgcolor=divStatusColor, text_color=color.white, text_size=size.small)

// ============================================================================
// FIBONACCI TRADING SYSTEM
// ============================================================================
// à¹€à¸à¹‡à¸š Swing Points à¸ªà¸³à¸«à¸£à¸±à¸š Fibonacci
var float fibLL = na  // Lower Low
var float fibHH = na  // Higher High
var int fibLLIndex = na
var int fibHHIndex = na
var int fibLLTime = na  // à¹€à¸à¹‡à¸š Time à¸‚à¸­à¸‡ LL à¸ªà¸³à¸«à¸£à¸±à¸šà¸§à¸²à¸” Fibonacci lines
var int fibHHTime = na  // à¹€à¸à¹‡à¸š Time à¸‚à¸­à¸‡ HH à¸ªà¸³à¸«à¸£à¸±à¸šà¸§à¸²à¸” Fibonacci lines
var float prevBtmY = na
var float prevTopY = na
var float fibHL = na  // Higher Low (HL) - à¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™ SL à¸ªà¸³à¸«à¸£à¸±à¸š Wave 2/Wave B (Long)
var int fibHLIndex = na
var float fibLH = na  // Lower High (LH) - à¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™ SL à¸ªà¸³à¸«à¸£à¸±à¸š Wave 2/Wave B (Short)
var int fibLHIndex = na
var bool chochDetected = false
var float chochPrice = na
var int chochIndex = na
var bool isFirstWave = true  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ Wave 1 (CHOCH à¹à¸£à¸) à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
// wave1Completed à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹„à¸§à¹‰à¸à¹ˆà¸­à¸™ Dashboard à¹à¸¥à¹‰à¸§ (à¸šà¸£à¸£à¸—à¸±à¸” 510) à¹€à¸žà¸·à¹ˆà¸­à¸›à¹‰à¸­à¸‡à¸à¸±à¸™ undeclared à¹ƒà¸™ Dashboard

// à¹€à¸à¹‡à¸š Wave 1 à¸ˆà¸²à¸à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡ trend (à¹„à¸¡à¹ˆ reset - à¹ƒà¸Šà¹‰à¸ªà¸³à¸«à¸£à¸±à¸š Extension TP calculation)
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: currentWaveTF à¹à¸¥à¸° currentSubWaveTF à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹„à¸§à¹‰à¸à¹ˆà¸­à¸™ Dashboard à¹à¸¥à¹‰à¸§ (à¸šà¸£à¸£à¸—à¸±à¸” 511-512)
var float firstWaveLL = na  // à¹€à¸à¹‡à¸š LL à¸‚à¸­à¸‡ Wave 1 à¸ˆà¸²à¸à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡ trend (à¹„à¸¡à¹ˆ reset)
var float firstWaveHH = na  // à¹€à¸à¹‡à¸š HH à¸‚à¸­à¸‡ Wave 1 à¸ˆà¸²à¸à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡ trend (à¹„à¸¡à¹ˆ reset)
var int firstWaveLLIndex = na  // à¹€à¸à¹‡à¸š Index à¸‚à¸­à¸‡ LL à¸‚à¸­à¸‡ Wave 1 à¸ªà¸³à¸«à¸£à¸±à¸šà¸§à¸²à¸” Extension
var int firstWaveHHIndex = na  // à¹€à¸à¹‡à¸š Index à¸‚à¸­à¸‡ HH à¸‚à¸­à¸‡ Wave 1 à¸ªà¸³à¸«à¸£à¸±à¸šà¸§à¸²à¸” Extension
var int firstWaveLLTime = na  // à¹€à¸à¹‡à¸š Time à¸‚à¸­à¸‡ LL à¸‚à¸­à¸‡ Wave 1 à¸ªà¸³à¸«à¸£à¸±à¸šà¸§à¸²à¸” Extension
var bool firstWaveStored = false  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹€à¸à¹‡à¸š Wave 1 à¸ˆà¸²à¸à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (à¹„à¸¡à¹ˆ reset)

// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: isWaveA à¹à¸¥à¸° isWaveB à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹„à¸§à¹‰à¹à¸¥à¹‰à¸§à¸à¹ˆà¸­à¸™ Dashboard (à¸šà¸£à¸£à¸—à¸±à¸” 507-508) - à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸›à¸£à¸°à¸à¸²à¸¨à¸‹à¹‰à¸³

// à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸š LL à¹à¸¥à¸° HH à¸ˆà¸²à¸ Swing Points (à¹ƒà¸Šà¹‰à¸ˆà¸²à¸ Structure detection)
// à¸ªà¹ˆà¸§à¸™à¸™à¸µà¹‰à¸ˆà¸°à¸–à¸¹à¸à¸¢à¹‰à¸²à¸¢à¹„à¸›à¹„à¸§à¹‰à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ btm à¹à¸¥à¸° top à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨
var label fibLLLabel = na
var label fibHHLabel = na

// à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸š CHOCH (Change of Character) - à¹ƒà¸Šà¹‰à¸ˆà¸²à¸ Structure detection
// à¸ªà¹ˆà¸§à¸™à¸™à¸µà¹‰à¸ˆà¸°à¸–à¸¹à¸à¸¢à¹‰à¸²à¸¢à¹„à¸›à¹„à¸§à¹‰à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ bull_choch_alert à¹à¸¥à¸° bear_choch_alert à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨
var label chochLabel = na

// à¸„à¸³à¸™à¸§à¸“ Fibonacci Levels
// à¸•à¸²à¸¡à¸—à¸¤à¸©à¸Žà¸µ Elliott Wave: à¸£à¸²à¸„à¸²à¸•à¹‰à¸­à¸‡à¸à¸¥à¸±à¸šà¸¡à¸²à¸—à¸µà¹ˆ 0.33-0.382 à¹€à¸žà¸·à¹ˆà¸­à¸ªà¸£à¹‰à¸²à¸‡à¸Šà¸¸à¸” Impulse (Wave A à¸ˆà¸šà¸Šà¸¸à¸”à¹ƒà¸«à¸à¹ˆ)
float fibRange = na
float fibRetracement618 = na
float fibRetracement382 = na
float fibRetracement50 = na
float fibRetracement786 = na  // Fibonacci 0.786 à¸ªà¸³à¸«à¸£à¸±à¸š Scale-in Entry
float fibRetracement33 = na  // Fibonacci 0.33 à¸ªà¸³à¸«à¸£à¸±à¸š Wave A à¸ˆà¸šà¸Šà¸¸à¸”à¹ƒà¸«à¸à¹ˆ (à¸•à¹‰à¸­à¸‡à¸à¸¥à¸±à¸šà¸¡à¸²à¸—à¸µà¹ˆ 0.33-0.382)
float fibRetracement382_FirstWave = na  // Fibonacci 38.2 à¸ˆà¸²à¸à¸Šà¸¸à¸”à¹à¸£à¸ (à¸ªà¸³à¸«à¸£à¸±à¸š Wave 1 à¸ˆà¸šà¹à¸¥à¹‰à¸§)
float firstWaveRange = na

// à¸„à¸³à¸™à¸§à¸“ Fibonacci Retracement Levels à¸ˆà¸²à¸ LL (fibLL) à¹„à¸› HH (fibHH)
// Retracement = HH - (Range * Retracement Level)
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: à¸•à¹‰à¸­à¸‡à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² fibHH > fibLL (à¸ªà¸³à¸«à¸£à¸±à¸š uptrend) à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¸à¸²à¸£à¸„à¸³à¸™à¸§à¸“à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡
// à¹ƒà¸Šà¹‰ fibLL à¹à¸¥à¸° fibHH à¸—à¸µà¹ˆà¹€à¸›à¹‡à¸™ LL/HH à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™ (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ firstWaveLL/HH à¸—à¸µà¹ˆà¸­à¸²à¸ˆà¹€à¸›à¹‡à¸™ swing à¹€à¸à¹ˆà¸²)
if not na(fibHH) and not na(fibLL) and fibHH > fibLL
    fibRange := fibHH - fibLL
    // Fibonacci Retracement: à¸§à¸±à¸”à¸ˆà¸²à¸ HH à¸¥à¸‡à¸¡à¸²à¸—à¸µà¹ˆ LL
    // 0.618 retracement = HH - (Range * 0.618) - à¸ªà¸³à¸«à¸£à¸±à¸š Entry (Wave A à¹à¸¥à¸° Wave B)
    fibRetracement618 := fibHH - (fibRange * fibEntryLevel)  // 0.618 retracement (default = 0.618)
    fibRetracement382 := fibHH - (fibRange * 0.382)  // 0.382 retracement - à¸ªà¸³à¸«à¸£à¸±à¸š Wave A à¸ˆà¸šà¸Šà¸¸à¸”à¹ƒà¸«à¸à¹ˆ (à¸•à¹‰à¸­à¸‡à¸à¸¥à¸±à¸šà¸¡à¸²à¸—à¸µà¹ˆ 0.33-0.382)
    fibRetracement33 := fibHH - (fibRange * 0.33)  // 0.33 retracement - à¸ªà¸³à¸«à¸£à¸±à¸š Wave A à¸ˆà¸šà¸Šà¸¸à¸”à¹ƒà¸«à¸à¹ˆ (à¸•à¹‰à¸­à¸‡à¸à¸¥à¸±à¸šà¸¡à¸²à¸—à¸µà¹ˆ 0.33-0.382)
    fibRetracement50 := fibHH - (fibRange * 0.5)  // 0.5 retracement - à¸ªà¸³à¸«à¸£à¸±à¸šà¸—à¸”à¸ªà¸­à¸šà¸•à¸­à¸™à¸¥à¸‡à¸¡à¸² (50 à¸«à¸£à¸·à¸­ 61.8)
    // Fib 0.786: à¸•à¹‰à¸­à¸‡à¸­à¸¢à¸¹à¹ˆà¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ fibLL à¹à¸¥à¸° fibHH (à¹„à¸¡à¹ˆà¸•à¹ˆà¸³à¸à¸§à¹ˆà¸² fibLL)
    float fib786Calc = fibHH - (fibRange * 0.786)
    fibRetracement786 := fib786Calc >= fibLL ? fib786Calc : na  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹„à¸¡à¹ˆà¸•à¹ˆà¸³à¸à¸§à¹ˆà¸² fibLL
else
    // à¸–à¹‰à¸² fibHH <= fibLL à¹à¸ªà¸”à¸‡à¸§à¹ˆà¸²à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ valid range
    fibRange := na
    fibRetracement618 := na
    fibRetracement382 := na
    fibRetracement33 := na
    fibRetracement50 := na
    fibRetracement786 := na

// à¸„à¸³à¸™à¸§à¸“ Fibonacci 38.2 à¸ˆà¸²à¸à¸Šà¸¸à¸”à¹à¸£à¸ (à¹€à¸¡à¸·à¹ˆà¸­ Wave 1 à¸ˆà¸šà¹à¸¥à¹‰à¸§)
if not na(firstWaveLL) and not na(firstWaveHH)
    firstWaveRange := firstWaveHH - firstWaveLL
    fibRetracement382_FirstWave := firstWaveHH - (firstWaveRange * 0.382)

// à¸„à¸³à¸™à¸§à¸“ TP1 à¹à¸¥à¸° TP2 à¸ˆà¸²à¸ Fibonacci Trend-Based Extension (à¸ˆà¸²à¸ Wave 1: firstWaveLL to firstWaveHH)
// Extension à¸ˆà¸°à¹€à¸›à¹‡à¸™à¸•à¸±à¸§à¸à¸³à¸«à¸™à¸” TP à¸•à¸²à¸¡à¸à¸Ž Elliott Wave (à¹„à¸¡à¹ˆà¸•à¸²à¸¢à¸•à¸±à¸§)
// à¸ªà¸³à¸«à¸£à¸±à¸š Wave 3 (Impulse) à¸—à¸µà¹ˆà¹€à¸›à¹‡à¸™à¸«à¸±à¸§à¹€à¸§à¸Ÿà¸—à¸³à¹€à¸‡à¸´à¸™: à¹ƒà¸Šà¹‰ Extension à¸•à¸²à¸¡à¸£à¸¹à¸›à¹à¸šà¸š 5/3/5
// Wave 3 = 1.618 à¸«à¸£à¸·à¸­ 2.618 à¸‚à¸­à¸‡ Wave 1 (à¸•à¸²à¸¡ Elliott Wave rules)
float fibTP1 = na
float fibTP2 = na
float fibTP3 = na  // TP3 à¸ªà¸³à¸«à¸£à¸±à¸š Wave 5
float extensionBase = na
float extensionRange = na

// Elliott Wave Entry, Stop Loss, à¹à¸¥à¸° Take Profit à¸•à¸²à¸¡à¸à¸Ž Elliott Wave
// à¹ƒà¸Šà¹‰ wave1High, wave1Low, wave2Low, wave3High, wave4Low, wave5High à¸—à¸µà¹ˆà¹€à¸à¹‡à¸šà¹„à¸§à¹‰
float ewEntryPrice = na  // Entry Price à¸•à¸²à¸¡à¸à¸Ž Elliott Wave
float ewStopLoss = na  // Stop Loss à¸•à¸²à¸¡à¸à¸Ž Elliott Wave
float ewTP1 = na  // Take Profit 1 à¸•à¸²à¸¡à¸à¸Ž Elliott Wave
float ewTP2 = na  // Take Profit 2 à¸•à¸²à¸¡à¸à¸Ž Elliott Wave
float ewTP3 = na  // Take Profit 3 à¸•à¸²à¸¡à¸à¸Ž Elliott Wave (à¸ªà¸³à¸«à¸£à¸±à¸š Wave 5)
int currentWaveForEntry = 0  // Wave à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰à¸ªà¸³à¸«à¸£à¸±à¸š Entry (2, 4)

// à¸„à¸³à¸™à¸§à¸“ Entry Price, Stop Loss, à¹à¸¥à¸° Take Profit à¸•à¸²à¸¡à¸à¸Ž Elliott Wave
bool isWave2 = not na(wave1High) and not na(wave1Low) and not na(wave2Low) and impulseWaveCount == 2
bool isWave4 = not na(wave3High) and not na(wave3Low) and not na(wave4Low) and impulseWaveCount == 4

if isWave2
    float wave1Range = wave1High - wave1Low
    float fib786 = wave1High - (wave1Range * 0.786)
    float fib236 = wave1High - (wave1Range * 0.236)
    if close >= fib786 and close <= fib236
        ewEntryPrice := close
        currentWaveForEntry := 2
        ewStopLoss := wave1Low
        ewTP1 := wave1High + (wave1Range * 1.618)
        ewTP2 := wave1High + (wave1Range * 2.618)

if isWave4 and not na(wave1High) and not na(wave1Low)
    float wave3Range = wave3High - wave3Low
    float fib618_w3 = wave3High - (wave3Range * 0.618)
    float fib236_w3 = wave3High - (wave3Range * 0.236)
    if close >= fib618_w3 and close <= fib236_w3
        ewEntryPrice := close
        currentWaveForEntry := 4
        ewStopLoss := wave1High
        float wave1Range = wave1High - wave1Low
        ewTP1 := wave1High + (wave1Range * 0.618)
        ewTP2 := wave1High + (wave1Range * 1.0)
        ewTP3 := wave1High + (wave1Range * 1.618)

// à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸š Wave 3 (Impulse) - à¸«à¸±à¸§à¹€à¸§à¸Ÿà¸—à¸³à¹€à¸‡à¸´à¸™
// Wave 3 = 3 swings ABC à¹à¸¥à¸°à¸£à¸¹à¸›à¹à¸šà¸šà¸„à¸¥à¸·à¹ˆà¸™ 5/3/5
// Wave 3 à¸ˆà¸°à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ Wave 1 à¹à¸¥à¸° Wave 2 à¸ˆà¸šà¹à¸¥à¹‰à¸§
bool isWave3 = false
if wave1Completed == true and impulseWaveCount >= 3
    // Wave 3 = Impulse wave à¸—à¸µà¹ˆ 3 (3 swings ABC pattern)
    isWave3 := impulseWaveCount == 3 or (impulseWaveCount > 3 and correctionWaveCount == 0)

// Extension à¹ƒà¸Šà¹‰ 3 à¸ˆà¸¸à¸”: LL (à¸ˆà¸¸à¸”1), HH (à¸ˆà¸¸à¸”2), Entry Price (à¸ˆà¸¸à¸”3 - à¸£à¸²à¸„à¸²à¸—à¸µà¹ˆà¸—à¸”à¸ªà¸­à¸š Fib 61.8% à¹à¸¥à¹‰à¸§à¸§à¸´à¹ˆà¸‡à¸ˆà¸£à¸´à¸‡)
// Extension = Entry Price + ((HH - LL) * Extension Level)
// TP à¸ˆà¸°à¸–à¸¹à¸à¸„à¸³à¸™à¸§à¸“à¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µà¸à¸²à¸£à¹€à¸›à¸´à¸”à¸‹à¸´à¸à¹à¸™à¸¥ Buy (entryPrice à¸–à¸¹à¸à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¹à¸¥à¹‰à¸§)
if not na(entryPrice) and not na(fibLL) and not na(fibHH) and fibHH > fibLL and strategy.position_size > 0
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ uptrend à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (fibHH > close à¸«à¸£à¸·à¸­ isUptrend_15M)
    // à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰ trend à¹€à¸žà¸£à¸²à¸° trend à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¸«à¸¥à¸±à¸‡à¸ªà¹ˆà¸§à¸™à¸™à¸µà¹‰
    bool isUptrend = fibHH > close or isUptrend_15M
    
    if isUptrend
        // à¹ƒà¸Šà¹‰ 3 à¸ˆà¸¸à¸”à¸ªà¸³à¸«à¸£à¸±à¸š Extension:
        // à¸ˆà¸¸à¸”à¸—à¸µà¹ˆ 1: LL (fibLL à¸«à¸£à¸·à¸­ firstWaveLL)
        // à¸ˆà¸¸à¸”à¸—à¸µà¹ˆ 2: HH (fibHH à¸«à¸£à¸·à¸­ firstWaveHH)
        // à¸ˆà¸¸à¸”à¸—à¸µà¹ˆ 3: Entry Price (entryPrice - à¸£à¸²à¸„à¸²à¸—à¸µà¹ˆà¸—à¸”à¸ªà¸­à¸š Fib 61.8% à¹à¸¥à¹‰à¸§à¸§à¸´à¹ˆà¸‡à¸ˆà¸£à¸´à¸‡)
        float extensionLL = fibLL  // LL à¸ªà¸³à¸«à¸£à¸±à¸š Extension (à¸ˆà¸¸à¸”à¸—à¸µà¹ˆ 1)
        float extensionHH = fibHH  // HH à¸ªà¸³à¸«à¸£à¸±à¸š Extension (à¸ˆà¸¸à¸”à¸—à¸µà¹ˆ 2)
        
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² firstWaveLL/HH à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
        if not na(firstWaveLL) and not na(firstWaveHH) and firstWaveHH > firstWaveLL
            if firstWaveHH >= fibHH and firstWaveLL <= fibLL and firstWaveHH >= close
                extensionLL := firstWaveLL
                extensionHH := firstWaveHH
        
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² extensionHH > extensionLL (à¸•à¹‰à¸­à¸‡à¸¡à¸µ range à¸—à¸µà¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡)
        if extensionHH > extensionLL and entryPrice > extensionLL
            extensionRange := extensionHH - extensionLL  // Range = HH - LL (à¸£à¸°à¸¢à¸°à¸‚à¸­à¸‡ Wave 1)
            extensionBase := entryPrice  // Base = Entry Price (à¸ˆà¸¸à¸”à¸—à¸µà¹ˆ 3 - à¸£à¸²à¸„à¸²à¸—à¸µà¹ˆà¸—à¸”à¸ªà¸­à¸š Fib 61.8% à¹à¸¥à¹‰à¸§à¸§à¸´à¹ˆà¸‡à¸ˆà¸£à¸´à¸‡)
            
            // Extension = Entry Price + ((HH - LL) * Extension Level)
            // TP1: 1.0 extension = Entry + (Range * 1.0) = Entry + (HH - LL)
            // TP2: 1.618 extension = Entry + (Range * 1.618)
            // à¸•à¸²à¸¡à¸—à¸¤à¸©à¸Žà¸µ Elliott Wave: à¸£à¸²à¸„à¸²à¸•à¹‰à¸­à¸‡à¹„à¸¡à¹ˆà¸¥à¸‡à¸–à¸¶à¸‡ 1.618 (à¸¥à¸‡à¹„à¸”à¹‰à¸–à¸¶à¸‡ 100% à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™)
            // Validation: à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² retracement à¹„à¸¡à¹ˆà¹€à¸à¸´à¸™ 100% (1.0 extension)
            float maxAllowedRetracement = extensionBase - (extensionRange * 1.0)  // 100% retracement (à¸¥à¹ˆà¸²à¸ªà¸¸à¸”à¹„à¸”à¹‰à¸–à¸¶à¸‡à¸•à¸£à¸‡à¸™à¸µà¹‰)
            bool isValidExtension = low >= maxAllowedRetracement  // à¸£à¸²à¸„à¸²à¸•à¹‰à¸­à¸‡à¹„à¸¡à¹ˆà¸¥à¸‡à¹€à¸à¸´à¸™ 100% (à¹„à¸¡à¹ˆà¸¥à¸‡à¸–à¸¶à¸‡ 1.618 extension)
            
            float tp1Mult = isWave3 ? 1.618 : 1.0
            float tp2Mult = isWave3 ? 2.618 : 1.618
            fibTP1 := isValidExtension ? extensionBase + (extensionRange * tp1Mult) : na
            fibTP2 := isValidExtension ? extensionBase + (extensionRange * tp2Mult) : na
    else
        // à¸ªà¸³à¸«à¸£à¸±à¸š downtrend: à¹ƒà¸Šà¹‰ 3 à¸ˆà¸¸à¸”à¹€à¸Šà¹ˆà¸™à¸à¸±à¸™ (LL, HH, Entry Price)
        float extensionLL = fibLL
        float extensionHH = fibHH
        
        if not na(firstWaveLL) and not na(firstWaveHH) and firstWaveHH > firstWaveLL and firstWaveHH <= fibHH and firstWaveLL >= fibLL
            extensionLL := firstWaveLL
            extensionHH := firstWaveHH
        
        if extensionHH > extensionLL and entryPrice < extensionHH
            extensionRange := extensionHH - extensionLL
            extensionBase := entryPrice  // Base = Entry Price (à¸ˆà¸¸à¸”à¸—à¸µà¹ˆ 3)
            
            float tp1Mult = isWave3 ? 1.618 : 1.0
            float tp2Mult = isWave3 ? 2.618 : 1.618
            fibTP1 := extensionBase - (extensionRange * tp1Mult)
            fibTP2 := extensionBase - (extensionRange * tp2Mult)
else if not na(entryPrice) and not na(firstWaveLL) and not na(firstWaveHH) and firstWaveHH > firstWaveLL and entryPrice > firstWaveLL and strategy.position_size > 0
    extensionRange := firstWaveHH - firstWaveLL
    extensionBase := entryPrice
    float tp1Mult = isWave3 ? 1.618 : 1.0
    float tp2Mult = isWave3 ? 2.618 : 1.618
    fibTP1 := extensionBase + (extensionRange * tp1Mult)
    fibTP2 := extensionBase + (extensionRange * tp2Mult)
else
    // à¹„à¸¡à¹ˆà¸„à¸³à¸™à¸§à¸“ Extension (fibTP1 à¹à¸¥à¸° fibTP2 à¸ˆà¸°à¹€à¸›à¹‡à¸™ na)
    extensionBase := na
    extensionRange := na

// à¸§à¸²à¸” Fibonacci Levels
var line fib618Line = na
var line fib382Line = na
var line fib50Line = na
var line fib786Line = na  // Fibonacci 0.786 à¸ªà¸³à¸«à¸£à¸±à¸š Scale-in Entry
var line fibTP1Line = na
var line fibTP2Line = na
var line fib382FirstWaveLine = na  // Fibonacci 38.2 à¸ˆà¸²à¸à¸Šà¸¸à¸”à¹à¸£à¸
var label fib618Label = na
var label fib382Label = na
var label fib50Label = na
var label fib786Label = na  // Label à¸ªà¸³à¸«à¸£à¸±à¸š Fibonacci 0.786
var label fibTP1Label = na
var label fibTP2Label = na
var label fib382FirstWaveLabel = na  // Label à¸ªà¸³à¸«à¸£à¸±à¸š Fibonacci 38.2 à¸ˆà¸²à¸à¸Šà¸¸à¸”à¹à¸£à¸

if showFibonacci and not na(fibLL) and not na(fibHH) and enableFibonacci
    // Fibonacci Retracement Lines - à¸ªà¸µà¸Šà¸±à¸”à¹€à¸ˆà¸™
    // à¹ƒà¸Šà¹‰ time à¹à¸—à¸™ bar_index à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¸•à¸³à¹à¸«à¸™à¹ˆà¸‡à¸£à¸²à¸„à¸²à¸–à¸¹à¸à¸•à¹‰à¸­à¸‡
    int fibLLTimeForLine = not na(fibLLTime) ? fibLLTime : (not na(fibLLIndex) and math.abs(bar_index - fibLLIndex) < 500) ? time[bar_index - fibLLIndex] : time
    
    if not na(fibLLTimeForLine)
        // Fibonacci 0.618 Line (Wave 1 entry level)
        if na(fib618Line)
            fib618Line := line.new(fibLLTimeForLine, fibRetracement618, time, fibRetracement618, color=fibLineColor, style=line.style_dashed, width=2, extend=extend.right, xloc=xloc.bar_time)
            fib618Label := label.new(bar_index + 50, fibRetracement618, "0.618\n" + str.tostring(fibRetracement618, "#.##"), color=color.new(fibLabelColor, 80), textcolor=fibLabelColor, size=size.small, style=label.style_label_left, xloc=xloc.bar_index)
        else
            // à¸­à¸±à¸›à¹€à¸”à¸• line à¹à¸¥à¸° label à¸—à¸¸à¸à¸„à¸£à¸±à¹‰à¸‡à¸—à¸µà¹ˆ fibRetracement618 à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™
            line.set_xy1(fib618Line, fibLLTimeForLine, fibRetracement618)
            line.set_xy2(fib618Line, time, fibRetracement618)
            line.set_color(fib618Line, fibLineColor)
            // à¸­à¸±à¸›à¹€à¸”à¸• label position à¹à¸¥à¸° text à¸—à¸¸à¸à¸„à¸£à¸±à¹‰à¸‡ (à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸£à¸­ barstate.islast)
            label.set_xy(fib618Label, bar_index + 50, fibRetracement618)
            label.set_text(fib618Label, "0.618\n" + str.tostring(fibRetracement618, "#.##"))  // à¸­à¸±à¸›à¹€à¸”à¸•à¸£à¸²à¸„à¸²à¹ƒà¸™ label
            label.set_textcolor(fib618Label, fibLabelColor)
        
        // à¹à¸ªà¸”à¸‡ 0.382 à¹à¸¥à¸° 0.5 à¹€à¸‰à¸žà¸²à¸°à¹€à¸¡à¸·à¹ˆà¸­ Wave 1 à¸ˆà¸šà¹à¸¥à¹‰à¸§ (à¹„à¸¡à¹ˆà¹à¸ªà¸”à¸‡à¹ƒà¸™ Wave 1)
        if isFirstWave == false
            if na(fib382Line)
                fib382Line := line.new(fibLLTimeForLine, fibRetracement382, time, fibRetracement382, color=fibLineColor, style=line.style_dashed, width=2, extend=extend.right, xloc=xloc.bar_time)
                fib382Label := label.new(bar_index + 50, fibRetracement382, "0.382\n" + str.tostring(fibRetracement382, "#.##"), color=color.new(fibLabelColor, 80), textcolor=fibLabelColor, size=size.small, style=label.style_label_left, xloc=xloc.bar_index)
            else
                line.set_xy1(fib382Line, fibLLTimeForLine, fibRetracement382)
                line.set_xy2(fib382Line, time, fibRetracement382)
                line.set_color(fib382Line, fibLineColor)
                label.set_xy(fib382Label, bar_index + 50, fibRetracement382)
                label.set_text(fib382Label, "0.382\n" + str.tostring(fibRetracement382, "#.##"))
                label.set_textcolor(fib382Label, fibLabelColor)
            if na(fib50Line)
                fib50Line := line.new(fibLLTimeForLine, fibRetracement50, time, fibRetracement50, color=fibLineColor, style=line.style_dashed, width=2, extend=extend.right, xloc=xloc.bar_time)
                fib50Label := label.new(bar_index + 50, fibRetracement50, "0.5\n" + str.tostring(fibRetracement50, "#.##"), color=color.new(fibLabelColor, 80), textcolor=fibLabelColor, size=size.small, style=label.style_label_left, xloc=xloc.bar_index)
            else
                line.set_xy1(fib50Line, fibLLTimeForLine, fibRetracement50)
                line.set_xy2(fib50Line, time, fibRetracement50)
                line.set_color(fib50Line, fibLineColor)
                label.set_xy(fib50Label, bar_index + 50, fibRetracement50)
                label.set_text(fib50Label, "0.5\n" + str.tostring(fibRetracement50, "#.##"))
                label.set_textcolor(fib50Label, fibLabelColor)
            // à¹à¸ªà¸”à¸‡ Fib 0.786 à¸ªà¸³à¸«à¸£à¸±à¸š Scale-in Entry (à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸›à¸´à¸”à¹ƒà¸Šà¹‰à¸‡à¸²à¸™ Scale-in à¹à¸¥à¸° Fib 0.786 à¸­à¸¢à¸¹à¹ˆà¹€à¸«à¸™à¸·à¸­ fibLL)
            if enableScaleInEntry and not na(fibRetracement786) and not na(fibLL) and fibRetracement786 > fibLL
                if na(fib786Line)
                    fib786Line := line.new(fibLLTimeForLine, fibRetracement786, time, fibRetracement786, color=color.new(color.orange, 0), style=line.style_dotted, width=2, extend=extend.right, xloc=xloc.bar_time)
                    fib786Label := label.new(bar_index + 50, fibRetracement786, "0.786\n" + str.tostring(fibRetracement786, "#.##"), color=color.new(color.orange, 80), textcolor=color.orange, size=size.small, style=label.style_label_left, xloc=xloc.bar_index)
                else
                    line.set_xy1(fib786Line, fibLLTimeForLine, fibRetracement786)
                    line.set_xy2(fib786Line, time, fibRetracement786)
                    label.set_xy(fib786Label, bar_index + 50, fibRetracement786)
                    label.set_text(fib786Label, "0.786\n" + str.tostring(fibRetracement786, "#.##"))
                    label.set_textcolor(fib786Label, color.orange)
    
    if wave1Completed == true and not na(fibRetracement382_FirstWave) and not na(firstWaveLLTime)
        if na(fib382FirstWaveLine)
            fib382FirstWaveLine := line.new(firstWaveLLTime, fibRetracement382_FirstWave, time, fibRetracement382_FirstWave, color=color.new(color.orange, 0), style=line.style_dashed, width=2, extend=extend.right, xloc=xloc.bar_time)
            fib382FirstWaveLabel := label.new(bar_index + 50, fibRetracement382_FirstWave, "38.2 (1st)\n" + str.tostring(fibRetracement382_FirstWave, "#.##"), color=color.new(color.orange, 80), textcolor=color.orange, size=size.small, style=label.style_label_left, xloc=xloc.bar_index)
        else
            line.set_xy1(fib382FirstWaveLine, firstWaveLLTime, fibRetracement382_FirstWave)
            line.set_xy2(fib382FirstWaveLine, time, fibRetracement382_FirstWave)
            label.set_xy(fib382FirstWaveLabel, bar_index + 50, fibRetracement382_FirstWave)
            label.set_text(fib382FirstWaveLabel, "38.2 (1st)\n" + str.tostring(fibRetracement382_FirstWave, "#.##"))
    
    // TP1 à¹à¸¥à¸° TP2 Lines à¸ˆà¸²à¸ Trend-Based Extension (Wave 1 Base) - à¸ªà¸µà¸Šà¸±à¸”à¹€à¸ˆà¸™
    // Extension à¸§à¸²à¸”à¸ˆà¸²à¸ extensionBase (Base) à¹„à¸›à¸¢à¸±à¸‡ TP1/TP2 (Extension Level)
    // à¹ƒà¸Šà¹‰ time à¹à¸—à¸™ bar_index à¹€à¸žà¸·à¹ˆà¸­à¸«à¸¥à¸µà¸à¹€à¸¥à¸µà¹ˆà¸¢à¸‡ error à¹€à¸¡à¸·à¹ˆà¸­ index à¸«à¹ˆà¸²à¸‡à¹€à¸à¸´à¸™à¹„à¸›
    // à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: extensionBase à¹à¸¥à¸° extensionRange à¸–à¸¹à¸à¸„à¸³à¸™à¸§à¸“à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Extension calculation à¸‚à¹‰à¸²à¸‡à¸šà¸™
    // à¸ªà¸³à¸«à¸£à¸±à¸š uptrend: extensionBase = fibHH, extensionRange = fibHH - fibLL
    if not na(extensionBase) and not na(extensionRange) and not na(fibTP1) and not na(fibTP2)
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² extensionBase à¸¡à¸²à¸ˆà¸²à¸ firstWaveLL à¸«à¸£à¸·à¸­ fibLL
        // à¸ªà¸³à¸«à¸£à¸±à¸š uptrend: extensionBase = LL (firstWaveLL à¸«à¸£à¸·à¸­ fibLL), à¹ƒà¸Šà¹‰ LLTime
        float extensionStartPrice = extensionBase
        int extensionStartTime = na
        
        bool useFirstWave = not na(firstWaveLL) and math.abs(extensionBase - firstWaveLL) < 0.01
        bool useFibLL = not na(fibLL) and math.abs(extensionBase - fibLL) < 0.01
        extensionStartTime := useFirstWave ? (not na(firstWaveLLTime) ? firstWaveLLTime : (not na(firstWaveLLIndex) and math.abs(bar_index - firstWaveLLIndex) < 500) ? time[bar_index - firstWaveLLIndex] : time - (timeframe.multiplier * 60000 * 100)) : useFibLL ? (not na(fibLLTime) ? fibLLTime : (not na(fibLLIndex) and math.abs(bar_index - fibLLIndex) < 500) ? time[bar_index - fibLLIndex] : time - (timeframe.multiplier * 60000 * 100)) : time - (timeframe.multiplier * 60000 * 100)
        
        // TP Lines à¸„à¸§à¸£à¹€à¸›à¹‡à¸™à¹€à¸ªà¹‰à¸™à¹à¸™à¸§à¸™à¸­à¸™ (horizontal line) à¸—à¸µà¹ˆà¹à¸ªà¸”à¸‡à¸£à¸°à¸”à¸±à¸šà¸£à¸²à¸„à¸² TP à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™ à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¹€à¸ªà¹‰à¸™à¸—à¹à¸¢à¸‡
        // à¹ƒà¸Šà¹‰ time à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™à¸«à¸£à¸·à¸­ time à¸—à¸µà¹ˆà¹ƒà¸à¸¥à¹‰à¹€à¸„à¸µà¸¢à¸‡à¹€à¸žà¸·à¹ˆà¸­à¸§à¸²à¸”à¹€à¸ªà¹‰à¸™à¹à¸™à¸§à¸™à¸­à¸™
        int tpStartTime = not na(extensionStartTime) ? extensionStartTime : (not na(fibLLTime) ? fibLLTime : time - (timeframe.multiplier * 60000 * 100))
        
        if not na(tpStartTime) and not na(fibTP1)
            if na(fibTP1Line)
                fibTP1Line := line.new(tpStartTime, fibTP1, time, fibTP1, color=color.new(color.green, 0), style=line.style_dashed, width=2, extend=extend.right, xloc=xloc.bar_time)
                fibTP1Label := label.new(bar_index + 50, fibTP1, "TP1 (Ext)\n" + str.tostring(fibTP1, "#.##"), color=color.new(color.green, 80), textcolor=color.green, size=size.small, style=label.style_label_left, xloc=xloc.bar_index)
            else
                line.set_xy1(fibTP1Line, tpStartTime, fibTP1)
                line.set_xy2(fibTP1Line, time, fibTP1)
                label.set_xy(fibTP1Label, bar_index + 50, fibTP1)
                label.set_text(fibTP1Label, "TP1 (Ext)\n" + str.tostring(fibTP1, "#.##"))
        
        if not na(tpStartTime) and not na(fibTP2)
            if na(fibTP2Line)
                fibTP2Line := line.new(tpStartTime, fibTP2, time, fibTP2, color=color.new(color.red, 0), style=line.style_dashed, width=2, extend=extend.right, xloc=xloc.bar_time)
                fibTP2Label := label.new(bar_index + 50, fibTP2, "TP2 (Ext)\n" + str.tostring(fibTP2, "#.##"), color=color.new(color.red, 80), textcolor=color.red, size=size.small, style=label.style_label_left, xloc=xloc.bar_index)
            else
                line.set_xy1(fibTP2Line, tpStartTime, fibTP2)
                line.set_xy2(fibTP2Line, time, fibTP2)
                label.set_xy(fibTP2Label, bar_index + 50, fibTP2)
                label.set_text(fibTP2Label, "TP2 (Ext)\n" + str.tostring(fibTP2, "#.##"))

// Fibonacci Time Zone - à¸§à¸²à¸”à¹€à¸ªà¹‰à¸™à¹à¸™à¸§à¸•à¸±à¹‰à¸‡à¸—à¸µà¹ˆà¸£à¸°à¸”à¸±à¸š 0.3 à¸ˆà¸²à¸à¸ªà¸§à¸´à¸‡à¹à¸£à¸ (LL à¹„à¸› HH)
// à¹ƒà¸Šà¹‰à¸„à¸²à¸”à¸à¸²à¸£à¸“à¹Œà¸§à¹ˆà¸²à¸ˆà¸°à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹€à¸§à¸Ÿà¹ƒà¸«à¸¡à¹ˆà¹€à¸¡à¸·à¹ˆà¸­à¹€à¸§à¸¥à¸²à¸–à¸¶à¸‡ 0.3 à¸‚à¸­à¸‡à¸ªà¸§à¸´à¸‡à¹à¸£à¸
var line fibTimeZone03Line = na
var label fibTimeZone03Label = na
var int lastFibLLTime = na
var int lastFibHHTime = na

if showFibonacciTimeZone and showFibonacci and not na(fibLLTime) and not na(fibHHTime) and enableFibonacci and fibHHTime > fibLLTime
    // à¸„à¸³à¸™à¸§à¸“à¹€à¸§à¸¥à¸²à¸—à¸µà¹ˆà¸£à¸°à¸”à¸±à¸š 0.3 à¸ˆà¸²à¸à¸ªà¸§à¸´à¸‡à¹à¸£à¸ (LL à¹„à¸› HH)
    // 0.3 = 30% à¸‚à¸­à¸‡à¸Šà¹ˆà¸§à¸‡à¹€à¸§à¸¥à¸² (fibLLTime à¹„à¸› fibHHTime)
    int timeRange = fibHHTime - fibLLTime
    int timeAt03 = fibLLTime + math.round(timeRange * 0.3)
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² fibLLTime à¸«à¸£à¸·à¸­ fibHHTime à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
    bool timeChanged = lastFibLLTime != fibLLTime or lastFibHHTime != fibHHTime
    
    // à¸¥à¸š line à¹€à¸à¹ˆà¸²à¸–à¹‰à¸²à¸¡à¸µà¹à¸¥à¸°à¹€à¸§à¸¥à¸²à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™
    if timeChanged and not na(fibTimeZone03Line)
        line.delete(fibTimeZone03Line)
        fibTimeZone03Line := na
    if timeChanged and not na(fibTimeZone03Label)
        label.delete(fibTimeZone03Label)
        fibTimeZone03Label := na
    
    // à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸ªà¹‰à¸™à¹à¸™à¸§à¸•à¸±à¹‰à¸‡à¹ƒà¸«à¸¡à¹ˆà¸—à¸µà¹ˆà¹€à¸§à¸¥à¸² 0.3 (à¸–à¹‰à¸²à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ)
    if na(fibTimeZone03Line) and not na(timeAt03)
        // à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸ªà¹‰à¸™à¹à¸™à¸§à¸•à¸±à¹‰à¸‡à¸—à¸µà¹ˆà¹€à¸§à¸¥à¸² 0.3 (à¹ƒà¸Šà¹‰ extend.both à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸ªà¹‰à¸™à¸—à¸­à¸”à¸¢à¸²à¸§à¸—à¸±à¹‰à¸‡à¸ªà¸­à¸‡à¸à¸±à¹ˆà¸‡)
        fibTimeZone03Line := line.new(timeAt03, low, timeAt03, high, color=fibTimeZoneColor, style=line.style_dashed, width=2, extend=extend.both, xloc=xloc.bar_time)
        fibTimeZone03Label := label.new(timeAt03, high, "0.3", color=color.new(fibTimeZoneColor, 80), textcolor=fibTimeZoneColor, size=size.small, style=label.style_label_down, xloc=xloc.bar_time)
    
    // à¹€à¸à¹‡à¸šà¸„à¹ˆà¸²à¹€à¸§à¸¥à¸²à¸¥à¹ˆà¸²à¸ªà¸¸à¸”
    lastFibLLTime := fibLLTime
    lastFibHHTime := fibHHTime
else
    // à¸¥à¸š line à¸–à¹‰à¸²à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¹„à¸¡à¹ˆà¹€à¸›à¹‡à¸™à¸ˆà¸£à¸´à¸‡
    if not na(fibTimeZone03Line)
        line.delete(fibTimeZone03Line)
        fibTimeZone03Line := na
    if not na(fibTimeZone03Label)
        label.delete(fibTimeZone03Label)
        fibTimeZone03Label := na
    lastFibLLTime := na
    lastFibHHTime := na

// Fibonacci Entry Condition - à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¸—à¸µà¹ˆ Fibonacci Retracement Level
bool fibEntryZone50 = false
bool fibEntryZone618 = false
bool fibEntryZone382_FirstWave = false  // Entry zone à¸ªà¸³à¸«à¸£à¸±à¸š 38.2 à¸ˆà¸²à¸à¸Šà¸¸à¸”à¹à¸£à¸ (à¹€à¸¡à¸·à¹ˆà¸­ Wave 1 à¸ˆà¸šà¹à¸¥à¹‰à¸§)
float fibEntryZoneTop50 = na
float fibEntryZoneBottom50 = na
float fibEntryZoneTop618 = na
float fibEntryZoneBottom618 = na
float fibEntryZoneTop382_FirstWave = na
float fibEntryZoneBottom382_FirstWave = na
float entryZoneSize = na

// Entry Zone à¸ªà¸³à¸«à¸£à¸±à¸š Wave 1 (CHOCH à¹à¸£à¸) à¹à¸¥à¸° Wave B - à¹ƒà¸Šà¹‰ 0.618 à¸ªà¸³à¸«à¸£à¸±à¸šà¸—à¸±à¹‰à¸‡à¸ªà¸­à¸‡à¸à¸£à¸“à¸µ
// Wave A (isFirstWave == true): à¹ƒà¸Šà¹‰ Fib 0.618 à¸ˆà¸²à¸ LL/HH à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™
// Wave B (wave1Completed == true): à¹ƒà¸Šà¹‰ Fib 0.618 à¸ˆà¸²à¸ firstWaveLL/firstWaveHH à¸«à¸£à¸·à¸­ fibLL/fibHH
// à¸‹à¸´à¸à¹à¸™à¸¥à¸•à¹‰à¸­à¸‡à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸•à¸£à¸‡à¸—à¸µà¹ˆà¸Ÿà¸´à¹‚à¸š 61.8 à¹‚à¸”à¸¢à¸•à¸£à¸‡ (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¸—à¸¸à¸à¸—à¸µà¹ˆà¹ƒà¸™ zone)
// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² low à¸«à¸£à¸·à¸­ close à¸­à¸¢à¸¹à¹ˆà¸•à¸£à¸‡à¸Ÿà¸´à¹‚à¸š 61.8 à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (à¸¢à¸­à¸¡à¸£à¸±à¸š error Â±0.5% à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¸¡à¸µ signal)
if not na(fibRetracement618)
    // à¹ƒà¸Šà¹‰ tolerance à¹€à¸žà¸µà¸¢à¸‡ 0.5% à¸‚à¸­à¸‡ fibRetracement618 à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹à¸™à¹ˆà¹ƒà¸ˆà¸§à¹ˆà¸²à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸•à¸£à¸‡à¸Ÿà¸´à¹‚à¸š 61.8
    float fib618Tolerance = fibRetracement618 * 0.005  // 0.5% tolerance
    fibEntryZoneTop618 := fibRetracement618 + fib618Tolerance
    fibEntryZoneBottom618 := fibRetracement618 - fib618Tolerance
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² low (à¸£à¸²à¸„à¸²à¸•à¹ˆà¸³à¸ªà¸¸à¸”à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡) à¸«à¸£à¸·à¸­ close à¸­à¸¢à¸¹à¹ˆà¸•à¸£à¸‡à¸Ÿà¸´à¹‚à¸š 61.8 à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
    // à¸‹à¸´à¸à¹à¸™à¸¥à¸•à¹‰à¸­à¸‡à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¸—à¸”à¸ªà¸­à¸šà¸Ÿà¸´à¹‚à¸š 61.8 à¹‚à¸”à¸¢à¸•à¸£à¸‡ (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¸—à¸¸à¸à¸—à¸µà¹ˆà¹ƒà¸™ zone)
    bool priceTestedFib618 = (low <= fibRetracement618 and low >= fibEntryZoneBottom618) or (close >= fibEntryZoneBottom618 and close <= fibEntryZoneTop618)
    fibEntryZone618 := priceTestedFib618
else
    fibEntryZone618 := false
    fibEntryZoneTop618 := na
    fibEntryZoneBottom618 := na

// Entry Zone à¸ªà¸³à¸«à¸£à¸±à¸š Wave 1 à¸ˆà¸šà¹à¸¥à¹‰à¸§ - à¹ƒà¸Šà¹‰ 38.2 à¸ˆà¸²à¸à¸Šà¸¸à¸”à¹à¸£à¸ (à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¸à¸¥à¸±à¸šà¸•à¸±à¸§à¸¥à¸‡à¸¡à¸²) - à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰à¹à¸¥à¹‰à¸§ (à¹ƒà¸Šà¹‰ 0.618 à¹à¸—à¸™)
if not na(fibRetracement382_FirstWave) and wave1Completed == true and false  // à¸›à¸´à¸”à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™ - à¹ƒà¸Šà¹‰ 0.618 à¹à¸—à¸™
    entryZoneSize := fibRetracement382_FirstWave * 0.01  // 1% à¸‚à¸­à¸‡ Fib level
    fibEntryZoneTop382_FirstWave := fibRetracement382_FirstWave + entryZoneSize
    fibEntryZoneBottom382_FirstWave := fibRetracement382_FirstWave - entryZoneSize
    fibEntryZone382_FirstWave := close >= fibEntryZoneBottom382_FirstWave and close <= fibEntryZoneTop382_FirstWave

// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š FVG à¹ƒà¸™à¸Šà¹ˆà¸§à¸‡ lookback
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: bullish_fvg_min à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¸—à¸µà¹ˆà¸šà¸£à¸£à¸—à¸±à¸” 1763 à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Imbalances
// à¹ƒà¸Šà¹‰ var à¹€à¸žà¸·à¹ˆà¸­à¹€à¸à¹‡à¸šà¸„à¹ˆà¸²à¹„à¸§à¹‰à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ bars
var bool hasFVG = false
// hasFVG à¸ˆà¸°à¸–à¸¹à¸à¸­à¸±à¸›à¹€à¸”à¸•à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Imbalances à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ bullish_fvg_min à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹à¸¥à¹‰à¸§

// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Order Block à¸—à¸µà¹ˆà¹€à¸›à¹‡à¸™ Engulfing pattern
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: bullishEngulfing à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¸—à¸µà¹ˆà¸šà¸£à¸£à¸—à¸±à¸” 619 à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ ENGULFING candles
// à¹ƒà¸Šà¹‰ var à¹€à¸žà¸·à¹ˆà¸­à¹€à¸à¹‡à¸šà¸„à¹ˆà¸²à¹„à¸§à¹‰à¸£à¸°à¸«à¸§à¹ˆà¸²à¸‡ bars
var bool hasEngulfingOB = false
// hasEngulfingOB à¸ˆà¸°à¸–à¸¹à¸à¸­à¸±à¸›à¹€à¸”à¸•à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ ENGULFING candles à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ bullishEngulfing à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹à¸¥à¹‰à¸§

// à¸•à¸±à¸§à¹à¸›à¸£à¸ªà¸³à¸«à¸£à¸±à¸š Dashboard Check: FVG + OB (à¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡ FVG) + Demand (à¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡ FVG)
var float fvgTop = na  // à¹€à¸à¹‡à¸šà¸£à¸²à¸„à¸²à¸šà¸™à¸ªà¸¸à¸”à¸‚à¸­à¸‡ FVG
var float fvgBottom = na  // à¹€à¸à¹‡à¸šà¸£à¸²à¸„à¸²à¸¥à¹ˆà¸²à¸‡à¸ªà¸¸à¸”à¸‚à¸­à¸‡ FVG
var bool hasOBBelowFVG = false  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸¡à¸µ OB à¸­à¸¢à¸¹à¹ˆà¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡ FVG à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
var bool hasDemandBelowFVG = false  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸¡à¸µ Demand à¸­à¸¢à¸¹à¹ˆà¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡ FVG à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ

// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¹ƒà¸«à¸¡à¹ˆà¸•à¸²à¸¡ Elliott Wave Theory
// Wave A (à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™): à¹ƒà¸Šà¹‰à¹€à¸‰à¸žà¸²à¸° Fib 0.618 à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™ à¹à¸¥à¸°à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸«à¸¥à¸¸à¸” LL à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (à¸–à¹‰à¸²à¸«à¸¥à¸¸à¸” = à¹„à¸¡à¹ˆà¹€à¸‚à¹‰à¸²)
// Wave B (Sub-wave): à¹ƒà¸Šà¹‰ Fib 0.382, à¸•à¹‰à¸­à¸‡à¸¡à¸µ rejection candle, à¹à¸¥à¸° FVG à¸à¸±à¹ˆà¸‡à¸‹à¹‰à¸²à¸¢
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: isWaveA à¹à¸¥à¸° isWaveB à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹„à¸§à¹‰à¹à¸¥à¹‰à¸§à¸à¹ˆà¸­à¸™ Dashboard (à¸šà¸£à¸£à¸—à¸±à¸” 507-508) - à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸›à¸£à¸°à¸à¸²à¸¨à¸‹à¹‰à¸³
bool fibBuyCondition = false
bool hasLL = false
bool hasHH = false
bool hasCHOCH = false
// isWaveA à¹à¸¥à¸° isWaveB à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹„à¸§à¹‰à¹à¸¥à¹‰à¸§à¸à¹ˆà¸­à¸™ Dashboard (à¸šà¸£à¸£à¸—à¸±à¸” 507-508) - à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸›à¸£à¸°à¸à¸²à¸¨à¸‹à¹‰à¸³
bool inFibZone = false
bool rsiCondition = false
bool macdCondition = false
bool divergenceCondition = false
bool fvgCondition = false
bool obCondition = false
bool hasRejectionAtFib = false  // Rejection candle à¸—à¸µà¹ˆ Fibonacci level
bool notBrokeLL = true  // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸«à¸¥à¸¸à¸” LL à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (à¸–à¹‰à¸²à¸«à¸¥à¸¸à¸” = à¹„à¸¡à¹ˆà¹€à¸‚à¹‰à¸²)
bool priceAtFib618 = false  // à¸£à¸²à¸„à¸²à¸­à¸¢à¸¹à¹ˆà¸•à¸£à¸‡à¸Ÿà¸´à¹‚à¸š 61.8 à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (à¸›à¸£à¸°à¸à¸²à¸¨à¸à¹ˆà¸­à¸™à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸Šà¹‰à¹ƒà¸™à¸«à¸¥à¸²à¸¢à¸—à¸µà¹ˆ)
bool waveACompleted = false  // Wave A à¸ˆà¸šà¸Šà¸¸à¸”à¹ƒà¸«à¸à¹ˆà¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (Wave A à¸ˆà¸šà¸Šà¸¸à¸”à¹ƒà¸«à¸à¹ˆ = CHOCH à¹ƒà¸™ TF 15M)
bool priceAtRetracementZone = false  // à¸£à¸²à¸„à¸²à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™ retracement zone (0.33-0.382) à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ

if enableFibonacci
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸¡à¸µ LL à¹à¸¥à¸° HH
    hasLL := not na(fibLL) and not na(fibLLIndex)
    hasHH := not na(fibHH) and not na(fibHHIndex)
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š CHOCH
    hasCHOCH := not useCHOCH or chochDetected
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ Wave A (à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™) à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
    // à¸à¸Ž Market Structure: à¸•à¹‰à¸­à¸‡à¸¡à¸µ Break of Structure (BOS) à¸«à¸£à¸·à¸­ CHOCH à¸à¹ˆà¸­à¸™à¹€à¸ªà¸¡à¸­
    // Wave A = à¹€à¸à¸´à¸”à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸à¸¡à¸µ structure break + à¸£à¸²à¸„à¸²à¸ªà¸£à¹‰à¸²à¸‡ HL (Higher Low) à¹à¸¥à¹‰à¸§ pullback à¸¡à¸² Fib 61.8
    // à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: CHOCH/BOS + LL/HH + à¸£à¸²à¸„à¸²à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™ Demand Zone
    isWaveA := chochDetected == true and hasLL and hasHH and not wave1Completed
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ Wave B (Sub-wave) à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
    // à¸à¸Ž Market Structure: Wave A à¸•à¹‰à¸­à¸‡à¸ˆà¸š (à¸§à¸´à¹ˆà¸‡à¸–à¸¶à¸‡ 100%+) + à¹€à¸à¸´à¸” CHOCH M5 à¹ƒà¸«à¸¡à¹ˆ + à¸£à¸²à¸„à¸² pullback à¸¡à¸² Fib 61.8
    // Wave B = Wave A à¸ˆà¸š (wave1Completed) + CHOCH M5 + à¸£à¸²à¸„à¸²à¸ªà¸£à¹‰à¸²à¸‡ Higher Low à¹ƒà¸«à¸¡à¹ˆ
    // Entry: à¸£à¸²à¸„à¸²à¸Šà¸™ Fib 61.8 + FVG/OB + RSI confirm
    // à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: wave1Completed + CHOCH M5 + waveAReached100Percent (à¸¢à¸·à¸™à¸¢à¸±à¸™à¸§à¹ˆà¸² Wave A à¸§à¸´à¹ˆà¸‡à¸ˆà¸šà¸ˆà¸£à¸´à¸‡)
    isWaveB := wave1Completed == true and waveAReached100Percent == true and chochDetected_5M == true and not na(firstWaveLL) and not na(firstWaveHH)
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Wave A à¸ˆà¸šà¸Šà¸¸à¸”à¹ƒà¸«à¸à¹ˆ: à¸£à¸²à¸„à¸²à¸ˆà¸°à¹€à¸à¸´à¸” CHOCH à¹ƒà¸™ TF 15M à¹à¸¥à¸°à¸£à¸²à¸„à¸²à¸•à¹‰à¸­à¸‡à¸à¸¥à¸±à¸šà¸¡à¸²à¸—à¸µà¹ˆ 0.33-0.382 à¹€à¸žà¸·à¹ˆà¸­à¸ªà¸£à¹‰à¸²à¸‡à¸Šà¸¸à¸” Impulse
    // à¸•à¸²à¸¡à¸—à¸¤à¸©à¸Žà¸µ: à¸Šà¸¸à¸”à¹à¸£à¸à¸•à¹‰à¸­à¸‡à¹€à¸›à¹‡à¸™ 5 à¹à¸¥à¸°à¸›à¸£à¸±à¸š 3 à¹€à¸à¸´à¸”à¹€à¸›à¹‡à¸™à¸£à¸¹à¸›à¹à¸šà¸š à¸—à¸”à¸ªà¸­à¸šà¸•à¸­à¸™à¸¥à¸‡à¸¡à¸²à¹€à¸›à¹‡à¸™ 50 à¸«à¸£à¸·à¸­ 61.8
    waveACompleted := wave1Completed == true and chochDetected_15M == true  // Wave A à¸ˆà¸šà¸Šà¸¸à¸”à¹ƒà¸«à¸à¹ˆ = CHOCH à¹ƒà¸™ TF 15M
    priceAtRetracementZone := false
    if waveACompleted and not na(fibRetracement33) and not na(fibRetracement382)
        // à¸£à¸²à¸„à¸²à¸•à¹‰à¸­à¸‡à¸à¸¥à¸±à¸šà¸¡à¸²à¸—à¸µà¹ˆ 0.33-0.382 à¹€à¸žà¸·à¹ˆà¸­à¸ªà¸£à¹‰à¸²à¸‡à¸Šà¸¸à¸” Impulse (à¸—à¸”à¸ªà¸­à¸šà¸•à¸­à¸™à¸¥à¸‡à¸¡à¸²à¹€à¸›à¹‡à¸™ 50 à¸«à¸£à¸·à¸­ 61.8)
        priceAtRetracementZone := (close >= fibRetracement382 and close <= fibRetracement33) or (close >= fibRetracement50 and close <= fibRetracement382) or (close >= fibRetracement618 and close <= fibRetracement50)
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸«à¸¥à¸¸à¸” LL à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (à¸ªà¸³à¸«à¸£à¸±à¸š Wave A)
    // à¸–à¹‰à¸²à¸«à¸¥à¸¸à¸” LL à¹„à¸›à¹à¸¥à¹‰à¸§ = à¸£à¸²à¸„à¸²à¸ˆà¸°à¸¥à¸‡à¹„à¸›à¸ˆà¸£à¸´à¸‡à¹† (à¹„à¸¡à¹ˆà¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”)
    if isWaveA == true and not na(fibLL)
        notBrokeLL := low > fibLL  // à¸£à¸²à¸„à¸²à¸•à¹‰à¸­à¸‡à¹„à¸¡à¹ˆà¸•à¹ˆà¸³à¸à¸§à¹ˆà¸² LL
    else
        notBrokeLL := true  // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ Wave A = à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Fibonacci Entry Zone
    // Wave A (à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™): à¹ƒà¸Šà¹‰à¹€à¸‰à¸žà¸²à¸° 0.618 à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™ à¹à¸¥à¸°à¸•à¹‰à¸­à¸‡à¹„à¸¡à¹ˆà¸«à¸¥à¸¸à¸” LL
    // Wave B (Sub-wave à¹„à¸› C): à¹ƒà¸Šà¹‰ 0.618 (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ 0.382), à¸•à¹‰à¸­à¸‡à¸¡à¸µ rejection candle à¸—à¸µà¹ˆà¸Ÿà¸´à¹‚à¸š 61.8
    // à¸‹à¸´à¸à¹à¸™à¸¥à¸•à¹‰à¸­à¸‡à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸•à¸£à¸‡à¸—à¸µà¹ˆà¸Ÿà¸´à¹‚à¸š 61.8 à¹‚à¸”à¸¢à¸•à¸£à¸‡ (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¸—à¸¸à¸à¸—à¸µà¹ˆà¹ƒà¸™ zone)
    inFibZone := false
    hasRejectionAtFib := false  // Reset à¸à¹ˆà¸­à¸™à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹ƒà¸«à¸¡à¹ˆ
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² low à¸«à¸£à¸·à¸­ close à¸­à¸¢à¸¹à¹ˆà¸•à¸£à¸‡à¸Ÿà¸´à¹‚à¸š 61.8 à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
    // à¸•à¹‰à¸­à¸‡à¸¡à¸µà¸à¸²à¸£ "à¸—à¸”à¸ªà¸­à¸š" Fib 0.618 à¸ˆà¸£à¸´à¸‡à¹† (low à¸•à¹‰à¸­à¸‡à¸–à¸¶à¸‡ Fib 0.618)
    priceAtFib618 := false
    if not na(fibRetracement618)
        // à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: low à¸•à¹‰à¸­à¸‡à¸—à¸”à¸ªà¸­à¸š (touch) Fib 0.618 à¹à¸¥à¸° close à¸•à¹‰à¸­à¸‡à¸­à¸¢à¸¹à¹ˆà¹€à¸«à¸™à¸·à¸­ Fib 0.618
        // à¸™à¸µà¹ˆà¸„à¸·à¸­ rejection candle (à¸£à¸²à¸„à¸²à¸¥à¸‡à¹„à¸›à¸—à¸”à¸ªà¸­à¸šà¹à¸¥à¹‰à¸§à¸›à¸´à¸”à¹€à¸«à¸™à¸·à¸­)
        float fib618 = fibRetracement618
        bool lowTouchedFib = low <= fib618 * 1.005 and low >= fib618 * 0.995  // low à¸—à¸”à¸ªà¸­à¸š Fib Â±0.5%
        bool closedAboveFib = close > fib618  // close à¹€à¸«à¸™à¸·à¸­ Fib (rejection)
        priceAtFib618 := lowTouchedFib and closedAboveFib
    
    // Wave A: à¹ƒà¸Šà¹‰ Fib 0.618 à¹‚à¸”à¸¢à¸•à¸£à¸‡ - à¸£à¸²à¸„à¸²à¸•à¹‰à¸­à¸‡à¸—à¸”à¸ªà¸­à¸šà¸Ÿà¸´à¹‚à¸š 61.8 à¹à¸¥à¸°à¹„à¸¡à¹ˆà¸«à¸¥à¸¸à¸” LL (à¸–à¹‰à¸²à¸¡à¸µ LL)
    // à¸•à¸²à¸¡à¸—à¸¤à¸©à¸Žà¸µ Elliott Wave: RSI à¸¥à¸‡à¸¡à¸²à¸ˆà¸¸à¹ˆà¸¡ 30% à¸­à¸µà¸à¸„à¸£à¸±à¹‰à¸‡ à¹à¸¥à¸°à¸à¸£à¸²à¸Ÿà¸ªà¸£à¹‰à¸²à¸‡ LL = à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡à¹€à¸§à¸Ÿà¹ƒà¸«à¸¡à¹ˆ
    // à¸›à¸£à¸±à¸šà¹ƒà¸«à¹‰à¸‡à¹ˆà¸²à¸¢à¸‚à¸¶à¹‰à¸™: à¸–à¹‰à¸²à¸¡à¸µ priceAtFib618 à¹à¸¥à¹‰à¸§ à¹ƒà¸«à¹‰ inFibZone à¹€à¸›à¹‡à¸™ true (à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸£à¸­à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸­à¸·à¹ˆà¸™)
    if isWaveA == true and priceAtFib618
        // à¹„à¸¡à¹ˆà¸«à¸¥à¸¸à¸” LL à¸–à¹‰à¸²à¸¡à¸µ LL (à¸–à¹‰à¸²à¸«à¸¥à¸¸à¸” LL à¹„à¸›à¹à¸¥à¹‰à¸§ = à¸£à¸²à¸„à¸²à¸ˆà¸°à¸¥à¸‡à¹„à¸›à¸ˆà¸£à¸´à¸‡à¹† - à¹„à¸¡à¹ˆà¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”)
        if not na(fibLL)
            inFibZone := notBrokeLL == true
        else
            inFibZone := true  // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸¡à¸µ LL = à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š notBrokeLL
    // Wave B: à¹ƒà¸Šà¹‰ Fib 0.618 à¹‚à¸”à¸¢à¸•à¸£à¸‡ - à¸•à¸²à¸¡à¸—à¸¤à¸©à¸Žà¸µ Elliott Wave: à¸£à¸²à¸„à¸²à¸ˆà¸²à¸ Wave B à¸‚à¸¶à¹‰à¸™à¹„à¸›à¸ˆà¸šà¸—à¸µà¹ˆ 1.618 à¹à¸¥à¹‰à¸§à¸—à¸¸à¸šà¸¥à¸‡ = Fib 61.8%
    // Entry Point: à¸£à¸²à¸„à¸²à¸ˆà¸²à¸ Wave B à¸‚à¸¶à¹‰à¸™à¹„à¸›à¸ˆà¸šà¸—à¸µà¹ˆ 1.618 à¹à¸¥à¹‰à¸§à¸—à¸¸à¸šà¸¥à¸‡à¸¡à¸²à¸—à¸”à¸ªà¸­à¸š Fib 61.8% + Divergence M5 à¸¢à¸·à¸™à¸¢à¸±à¸™ + Rejection Candle
    // à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: fibTP2 à¸•à¹‰à¸­à¸‡à¸„à¸³à¸™à¸§à¸“à¸ˆà¸²à¸ Wave 1 (firstWaveLL/HH) à¹€à¸žà¸·à¹ˆà¸­à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸£à¸²à¸„à¸²à¹€à¸„à¸¢à¸–à¸¶à¸‡ 1.618 à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
    else if isWaveB == true and fibEntryZone618 == true and priceAtFib618 and not na(firstWaveLL) and not na(firstWaveHH) and firstWaveHH > firstWaveLL
        // à¸„à¸³à¸™à¸§à¸“ fibTP2 à¸ˆà¸²à¸ Wave 1 (firstWaveLL/HH) à¸ªà¸³à¸«à¸£à¸±à¸šà¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸£à¸²à¸„à¸²à¹€à¸„à¸¢à¸–à¸¶à¸‡ 1.618 à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
        // à¸•à¸²à¸¡à¸—à¸¤à¸©à¸Žà¸µ: à¸£à¸²à¸„à¸²à¸ˆà¸²à¸ Wave B à¹„à¸”à¹‰à¸‚à¸¶à¹‰à¸™à¹„à¸›à¸ˆà¸šà¸—à¸µà¹ˆ 1.618 (à¸ˆà¸²à¸ Wave 1 extension) à¹à¸¥à¸°à¸—à¸¸à¸šà¸¥à¸‡ à¸•à¸£à¸‡à¸™à¸µà¹‰à¸„à¸·à¸­à¸Ÿà¸´à¹‚à¸š 61.8
        float wave1RangeForTP = firstWaveHH - firstWaveLL  // Range à¸‚à¸­à¸‡ Wave 1
        float waveBTarget1618 = firstWaveHH + (wave1RangeForTP * 1.618)  // TP2 = 1.618 extension à¸ˆà¸²à¸ Wave 1
        
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸£à¸²à¸„à¸²à¹€à¸„à¸¢à¸‚à¸¶à¹‰à¸™à¹„à¸›à¸–à¸¶à¸‡ 1.618 extension (waveBTarget1618) à¹à¸¥à¹‰à¸§à¸—à¸¸à¸šà¸¥à¸‡à¸¡à¸²à¸—à¸”à¸ªà¸­à¸š Fib 61.8%
        bool priceReached1618 = ta.highest(high, 50) >= waveBTarget1618 * 0.995  // à¸£à¸²à¸„à¸²à¹€à¸„à¸¢à¸–à¸¶à¸‡ 1.618 à¹ƒà¸™ 50 bars à¸¥à¹ˆà¸²à¸ªà¸¸à¸” (à¸¢à¸­à¸¡à¸£à¸±à¸š error Â±0.5%)
        
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š rejection candle à¸—à¸µà¹ˆ Fib 0.618 à¹‚à¸”à¸¢à¸•à¸£à¸‡ (à¸¢à¸­à¸¡à¸£à¸±à¸š error Â±0.5%)
        // Rejection candle = bullish rejection (hammer, pin bar, doji) à¸—à¸µà¹ˆà¸Ÿà¸´à¹‚à¸š 61.8
        hasRejectionAtFib := bullishRejection and priceAtFib618  // à¸•à¹‰à¸­à¸‡à¸¡à¸µ rejection candle à¹à¸¥à¸°à¸£à¸²à¸„à¸²à¸­à¸¢à¸¹à¹ˆà¸•à¸£à¸‡à¸Ÿà¸´à¹‚à¸š 61.8
        
        // Wave B Entry: à¸£à¸²à¸„à¸²à¹€à¸„à¸¢à¸‚à¸¶à¹‰à¸™à¹„à¸›à¸–à¸¶à¸‡ 1.618 à¹à¸¥à¹‰à¸§à¸—à¸¸à¸šà¸¥à¸‡à¸¡à¸²à¸—à¸”à¸ªà¸­à¸š Fib 61.8% + à¸¡à¸µ rejection candle + Divergence M5 à¸¢à¸·à¸™à¸¢à¸±à¸™
        // Divergence M5 = à¹à¸£à¸‡ divergence à¹€à¸‚à¹‰à¸² â†’ à¸—à¸³à¹ƒà¸«à¹‰à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¹„à¸”à¹‰
        inFibZone := priceReached1618 and priceAtFib618 and hasRejectionAtFib  // à¸£à¸²à¸„à¸²à¹€à¸„à¸¢à¸–à¸¶à¸‡ 1.618 à¹à¸¥à¹‰à¸§à¸—à¸¸à¸šà¸¥à¸‡à¸¡à¸²à¸—à¸µà¹ˆ Fib 61.8% + rejection
    // Fallback: à¸–à¹‰à¸²à¸¡à¸µ LL/HH à¹à¸¥à¸°à¸£à¸²à¸„à¸²à¸—à¸”à¸ªà¸­à¸šà¸Ÿà¸´à¹‚à¸š 61.8 à¹‚à¸”à¸¢à¸•à¸£à¸‡ à¹à¸•à¹ˆà¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ Wave A/B
    else if hasLL and hasHH and fibEntryZone618 == true and priceAtFib618
        inFibZone := true  // Fallback entry condition: à¸£à¸²à¸„à¸²à¸•à¹‰à¸­à¸‡à¸­à¸¢à¸¹à¹ˆà¸•à¸£à¸‡à¸Ÿà¸´à¹‚à¸š 61.8
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š RSI (oversold à¸ªà¸³à¸«à¸£à¸±à¸š buy) - à¹ƒà¸Šà¹‰à¸ˆà¸²à¸ TF 15M à¹à¸¥à¸° 30M à¸ªà¸³à¸«à¸£à¸±à¸š entry timing
    // à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: RSI <= 35 (oversold zone) - à¸¢à¸·à¸”à¸«à¸¢à¸¸à¹ˆà¸™à¸‚à¸¶à¹‰à¸™à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¸¡à¸µ signal à¸šà¹‰à¸²à¸‡
    // à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: prevRSI à¹à¸¥à¸° rsiTested30 à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹„à¸§à¹‰à¹à¸¥à¹‰à¸§à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Strategy Variables (à¸šà¸£à¸£à¸—à¸±à¸” 484-485)
    rsiCondition := false
    
    // à¹ƒà¸Šà¹‰ RSI à¸ˆà¸²à¸ TF 15M à¹à¸¥à¸° 30M (à¹ƒà¸Šà¹‰à¸„à¹ˆà¸²à¸—à¸µà¹ˆà¸”à¸µà¸à¸§à¹ˆà¸²à¸«à¸£à¸·à¸­à¸—à¸±à¹‰à¸‡à¸ªà¸­à¸‡à¸•à¹‰à¸­à¸‡à¸œà¹ˆà¸²à¸™)
    float rsiForEntry = na
    if not na(rsiValue_15M) and not na(rsiValue_30M)
        // à¹ƒà¸Šà¹‰à¸„à¹ˆà¸² RSI à¸—à¸µà¹ˆà¸•à¹ˆà¸³à¸à¸§à¹ˆà¸² (oversold à¸¡à¸²à¸à¸à¸§à¹ˆà¸²) à¸ˆà¸²à¸ TF 15M à¸«à¸£à¸·à¸­ 30M
        rsiForEntry := math.min(rsiValue_15M, rsiValue_30M)
    else if not na(rsiValue_15M)
        rsiForEntry := rsiValue_15M
    else if not na(rsiValue_30M)
        rsiForEntry := rsiValue_30M
    else
        rsiForEntry := rsiValue  // Fallback: à¹ƒà¸Šà¹‰ RSI à¸ˆà¸²à¸ TF à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™
    
    if not na(rsiForEntry)
        bool rsiOversoldCheck = rsiForEntry <= rsiOversold
        bool rsiOversoldZone = rsiForEntry <= rsiOversold + 5
        bool rsiRetest = not na(prevRSI) and prevRSI <= rsiOversold and rsiForEntry > rsiOversold and rsiForEntry <= (rsiOversold + 10)
        bool rsiRetestAfterTest = rsiTested30 and rsiForEntry > rsiOversold and rsiForEntry <= (rsiOversold + 10)
        if rsiOversoldCheck or rsiOversoldZone or rsiRetest or rsiRetestAfterTest
            rsiTested30 := rsiOversoldCheck or rsiOversoldZone or rsiRetest or rsiTested30
            rsiCondition := true
        prevRSI := rsiForEntry
    
    // MACD and Divergence conditions (simplified)
    macdCondition := enableMACD ? (not na(macdLine) and not na(signalLine) and macdBullishCondition) : true
    divergenceCondition := (enableDivergence and requireDivergence) ? hasPositiveRegularDivergence : true
    
    // FVG/OB conditions (simplified)
    fvgCondition := isWaveB ? (hasFVG and hasOBBelowFVG and hasDemandBelowFVG) : (not requireFVG or hasFVG)
    obCondition := isWaveB ? (hasOBBelowFVG or not requireEngulfingOB) : (not requireEngulfingOB or hasEngulfingOB)
    
    // Buy condition (simplified)
    fibBuyCondition := hasLL and hasHH and hasCHOCH and inFibZone and rsiCondition and macdCondition and divergenceCondition and fvgCondition and obCondition and (not isWaveA or notBrokeLL) and (not isWaveB or hasRejectionAtFib)

// à¸­à¸±à¸›à¹€à¸”à¸• Dashboard Signal (à¸¢à¹‰à¸²à¸¢à¹„à¸›à¹„à¸§à¹‰à¸«à¸¥à¸±à¸‡à¸à¸²à¸£à¸›à¸£à¸°à¸à¸²à¸¨ wave entry conditions)
// à¸ˆà¸°à¸–à¸¹à¸à¸­à¸±à¸›à¹€à¸”à¸•à¸—à¸µà¹ˆà¸šà¸£à¸£à¸—à¸±à¸”à¸«à¸¥à¸±à¸‡ wave entry conditions à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹à¸¥à¹‰à¸§ (à¸”à¸¹à¸—à¸µà¹ˆà¸šà¸£à¸£à¸—à¸±à¸”à¸«à¸¥à¸±à¸‡ updateDashboardEntrySignal)

// Highlight Entry Zone
var box fibEntryBox50 = na
var box fibEntryBox618 = na
var box fibEntryBox382_FirstWave = na  // Entry box à¸ªà¸³à¸«à¸£à¸±à¸š 38.2 à¸ˆà¸²à¸à¸Šà¸¸à¸”à¹à¸£à¸

if showFibonacci and enableFibonacci
    if not na(fibEntryZoneTop618) and not na(fibEntryZoneBottom618) and not na(fibLLIndex) and isFirstWave == true
        if na(fibEntryBox618)
            fibEntryBox618 := box.new(fibLLIndex, fibEntryZoneTop618, bar_index + 100, fibEntryZoneBottom618, border_color=color.new(color.blue, 70), bgcolor=color.new(color.blue, 90), extend=extend.right, xloc=xloc.bar_index)
        else
            box.set_lefttop(fibEntryBox618, fibLLIndex, fibEntryZoneTop618)
            box.set_rightbottom(fibEntryBox618, bar_index + 100, fibEntryZoneBottom618)
    if not na(fibEntryZoneTop382_FirstWave) and not na(fibEntryZoneBottom382_FirstWave) and wave1Completed == true
        if na(fibEntryBox382_FirstWave)
            fibEntryBox382_FirstWave := box.new(bar_index - 50, fibEntryZoneTop382_FirstWave, bar_index + 100, fibEntryZoneBottom382_FirstWave, border_color=color.new(color.orange, 70), bgcolor=color.new(color.orange, 90), extend=extend.right, xloc=xloc.bar_index)
        else
            box.set_lefttop(fibEntryBox382_FirstWave, bar_index - 50, fibEntryZoneTop382_FirstWave)
            box.set_rightbottom(fibEntryBox382_FirstWave, bar_index + 100, fibEntryZoneBottom382_FirstWave)

// ============================================================================
// WAVE STRUCTURE DETECTION (Smart Logic)
// ============================================================================
// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡ Wave à¸•à¸²à¸¡à¸—à¸µà¹ˆà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸­à¸˜à¸´à¸šà¸²à¸¢:
// 1. Major Wave A: CHOCH M5 â†’ à¸‚à¸¶à¹‰à¸™ >= 100% â†’ à¸¥à¸‡
// 2. Sub-Wave Bâ†’C: Pullback Fib 0.618 â†’ à¸‚à¸¶à¹‰à¸™ 1.618
// 3. Major Wave B: Correction à¸¥à¸‡ Fib 0.382 â†’ à¹€à¸‚à¹‰à¸² Buy â†’ à¹„à¸› 1.618

// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² Wave A (Major) à¸§à¸´à¹ˆà¸‡à¹„à¸› >= 100% à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡
if not waveAReached100Percent and not na(firstWaveLL) and not na(waveAHighestPrice) and ((waveAHighestPrice - firstWaveLL) / firstWaveLL) * 100 >= 100.0
    waveAReached100Percent := true

// à¸­à¸±à¸žà¹€à¸”à¸— waveAHighestPrice à¹à¸¥à¸° Wave C completion
if strategy.position_size > 0 and justEnteredLong
    waveAHighestPrice := na(waveAHighestPrice) ? high : math.max(waveAHighestPrice, high)
if not waveCCompleted and not na(fibTP2) and high >= fibTP2
    waveCCompleted := true

// à¸•à¸´à¸”à¸•à¸²à¸¡ Major Wave structure à¹à¸¥à¸°à¸­à¸±à¸žà¹€à¸”à¸— Wave count
if not na(firstWaveLL) and not na(firstWaveHH)
    if na(wave1High) or na(wave1Low)
        wave1Low := firstWaveLL
        wave1High := firstWaveHH
        currentMajorWave := 1
    if not wave3Extended and not na(wave1High) and not na(wave1Low) and high >= (wave1Low + ((wave1High - wave1Low) * 2.618))
        wave3Extended := true
        wave3High := high
        currentMajorWave := 3

// ============================================================================
// STRATEGY EXECUTION
// ============================================================================
// à¸•à¸±à¸§à¹à¸›à¸£à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹„à¸§à¹‰à¹à¸¥à¹‰à¸§à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Strategy Variables (à¸à¹ˆà¸­à¸™ Dashboard)

// Entry conditions - à¹ƒà¸Šà¹‰à¹€à¸‰à¸žà¸²à¸° Fibonacci Entry (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰à¸à¸²à¸£à¸•à¸±à¸”à¸à¸±à¸™à¸‚à¸­à¸‡à¹€à¸ªà¹‰à¸™ SMA)
// à¹€à¸‚à¹‰à¸²à¸”à¹‰à¸§à¸¢à¸£à¸²à¸„à¸² Fibonacci à¸•à¸²à¸¡à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸‚à¸­à¸‡ Elliott Wave
// Reset exit conditions
exitLong := false
exitShort := false

// ========================================================================
// SIDEWAYS DETECTION à¹à¸¥à¸° BREAKOUT/RETEST/BOS
// ========================================================================
// à¸Šà¹ˆà¸§à¸‡ sideways = à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µà¹€à¸—à¸£à¸™à¸”à¹Œ (isSidewaysMarket = true)
// à¸–à¹‰à¸²à¸«à¸¥à¸¸à¸” sideways à¸—à¸²à¸‡à¹ƒà¸”à¸—à¸²à¸‡à¸«à¸™à¸¶à¹ˆà¸‡ â†’ à¸£à¸²à¸„à¸²à¸•à¹‰à¸­à¸‡à¸à¸¥à¸±à¸šà¸¡à¸²à¹€à¸žà¸·à¹ˆà¸­à¸—à¸”à¸ªà¸­à¸šà¹à¸™à¸§à¸£à¸±à¸š/à¹à¸™à¸§à¸•à¹‰à¸²à¸™à¸—à¸µà¹ˆà¸—à¸°à¸¥à¸¸à¹„à¸›
// à¸–à¹‰à¸²à¸¡à¸µà¸à¸²à¸£à¸¢à¸·à¸™à¸¢à¸±à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¸«à¸£à¸·à¸­à¸‚à¸²à¸¥à¸‡ â†’ à¸ˆà¸°à¸¡à¸²à¸—à¸”à¸ªà¸­à¸š BOS à¸—à¸µà¹ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ

// à¸­à¸±à¸›à¹€à¸”à¸• sideways range (high/low)
if isSidewaysMarket
    // à¸à¸³à¸¥à¸±à¸‡à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™à¸Šà¹ˆà¸§à¸‡ sideways - à¸­à¸±à¸›à¹€à¸”à¸• high/low
    if na(sidewaysHigh) or high > sidewaysHigh
        sidewaysHigh := high
    if na(sidewaysLow) or low < sidewaysLow
        sidewaysLow := low
    sidewaysBreakoutUp := false
    sidewaysBreakoutDown := false
    isRetestingBreakout := false
    bosComplete := false
else
    // à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ sideways à¹à¸¥à¹‰à¸§ - à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š breakout
    if not na(sidewaysHigh) and not na(sidewaysLow)
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š breakout à¸‚à¸¶à¹‰à¸™ (à¸«à¸¥à¸¸à¸”à¸”à¹‰à¸²à¸™à¸šà¸™)
        if not sidewaysBreakoutUp and high > sidewaysHigh
            sidewaysBreakoutUp := true
            breakoutLevel := sidewaysHigh  // à¸£à¸°à¸”à¸±à¸šà¹à¸™à¸§à¸•à¹‰à¸²à¸™à¸—à¸µà¹ˆà¸«à¸¥à¸¸à¸”
            isRetestingBreakout := false
            bosComplete := false
        
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š breakout à¸¥à¸‡ (à¸«à¸¥à¸¸à¸”à¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡)
        if not sidewaysBreakoutDown and low < sidewaysLow
            sidewaysBreakoutDown := true
            breakoutLevel := sidewaysLow  // à¸£à¸°à¸”à¸±à¸šà¹à¸™à¸§à¸£à¸±à¸šà¸—à¸µà¹ˆà¸«à¸¥à¸¸à¸”
            isRetestingBreakout := false
            bosComplete := false
        
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š retest (à¸£à¸²à¸„à¸²à¸à¸¥à¸±à¸šà¸¡à¸²à¸—à¸”à¸ªà¸­à¸šà¸£à¸°à¸”à¸±à¸šà¸—à¸µà¹ˆà¸«à¸¥à¸¸à¸”)
        if sidewaysBreakoutUp and not na(breakoutLevel)
            // à¸£à¸²à¸„à¸²à¸à¸¥à¸±à¸šà¸¡à¸²à¸—à¸”à¸ªà¸­à¸šà¹à¸™à¸§à¸•à¹‰à¸²à¸™à¸—à¸µà¹ˆà¸«à¸¥à¸¸à¸” (retest resistance)
            if not isRetestingBreakout and close <= breakoutLevel * 1.02 and close >= breakoutLevel * 0.98
                isRetestingBreakout := true
            // à¸–à¹‰à¸²à¸¡à¸µà¸à¸²à¸£à¸¢à¸·à¸™à¸¢à¸±à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™ (isStrongUptrend) à¹à¸¥à¸° retest à¹à¸¥à¹‰à¸§ = BOS à¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ
            if isRetestingBreakout and isStrongUptrend
                bosComplete := true
        
        if sidewaysBreakoutDown and not na(breakoutLevel)
            // à¸£à¸²à¸„à¸²à¸à¸¥à¸±à¸šà¸¡à¸²à¸—à¸”à¸ªà¸­à¸šà¹à¸™à¸§à¸£à¸±à¸šà¸—à¸µà¹ˆà¸«à¸¥à¸¸à¸” (retest support)
            if not isRetestingBreakout and close >= breakoutLevel * 0.98 and close <= breakoutLevel * 1.02
                isRetestingBreakout := true
            // à¸–à¹‰à¸²à¸¡à¸µà¸à¸²à¸£à¸¢à¸·à¸™à¸¢à¸±à¸™à¸‚à¸²à¸¥à¸‡ (isStrongDowntrend) à¹à¸¥à¸° retest à¹à¸¥à¹‰à¸§ = BOS à¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ
            if isRetestingBreakout and isStrongDowntrend
                bosComplete := true

// Multiple Entry Strategy - à¹à¸¢à¸à¸à¸¥à¸¢à¸¸à¸—à¸˜à¹Œà¸­à¸­à¸à¹€à¸›à¹‡à¸™à¸«à¸¥à¸²à¸¢à¸ˆà¸±à¸‡à¸«à¸§à¸°à¹ƒà¸™à¸à¸²à¸£à¹€à¸‚à¹‰à¸²
// à¸‹à¸´à¸à¹à¸™à¸¥à¸•à¹‰à¸­à¸‡à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸•à¸£à¸‡à¸—à¸µà¹ˆà¸Ÿà¸´à¹‚à¸š 61.8 à¹‚à¸”à¸¢à¸•à¸£à¸‡ (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¸—à¸¸à¸à¸—à¸µà¹ˆà¹ƒà¸™ zone)
// priceAtFib618 à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹„à¸§à¹‰à¹à¸¥à¹‰à¸§à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Fibonacci Entry Zone (à¸šà¸£à¸£à¸—à¸±à¸” 1111)
// Wave A Entry (Wave 1 - CHOCH à¹à¸£à¸): à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸žà¸·à¹‰à¸™à¸à¸²à¸™ - LL, HH, Fib 61.8, RSI, MACD
// Core conditions (à¸šà¸±à¸‡à¸„à¸±à¸š): hasLL, hasHH, à¸£à¸²à¸„à¸²à¸­à¸¢à¸¹à¹ˆà¸•à¸£à¸‡à¸Ÿà¸´à¹‚à¸š 61.8, rsiCondition, macdCondition
// Optional conditions (à¹„à¸¡à¹ˆà¸šà¸±à¸‡à¸„à¸±à¸šà¸–à¹‰à¸²à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¹€à¸›à¸´à¸”à¹ƒà¸Šà¹‰): CHOCH, Divergence, FVG, OB
// à¸•à¸²à¸¡à¸—à¸¤à¸©à¸Žà¸µ: RSI à¸¥à¸‡à¸¡à¸²à¸ˆà¸¸à¹ˆà¸¡ 30% à¸­à¸µà¸à¸„à¸£à¸±à¹‰à¸‡ à¹à¸¥à¸°à¸à¸£à¸²à¸Ÿà¸ªà¸£à¹‰à¸²à¸‡ LL = à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡à¹€à¸§à¸Ÿà¹ƒà¸«à¸¡à¹ˆ
// Wave A Entry: à¸•à¸²à¸¡à¸à¸¥à¸¢à¸¸à¸—à¸˜à¹Œ Swing Trading Elliott Wave
// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: 
// 1. CHOCH à¸—à¸µà¹ˆà¹€à¸›à¹‡à¸™ solid line shock (top_y) - à¹€à¸›à¸´à¸”à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¸¡à¸µ CHOCH à¸—à¸µà¹ˆà¹€à¸›à¹‡à¸™à¸Šà¹‡à¸­à¸à¸ˆà¸£à¸´à¸‡à¹†
// 2. à¸£à¸²à¸„à¸²à¸•à¹‰à¸­à¸‡ rejection à¸—à¸µà¹ˆ 61.8 à¹à¸¥à¸°à¸•à¸£à¸‡à¸™à¸±à¹‰à¸™à¸•à¹‰à¸­à¸‡à¸¡à¸µà¹à¸™à¸§à¸£à¸±à¸š (FVG, OB, à¸«à¸£à¸·à¸­à¹à¸™à¸§à¸£à¸±à¸šà¸­à¸·à¹ˆà¸™à¹†)
// 3. SMA7/21 à¸•à¹‰à¸­à¸‡à¸­à¸¢à¸¹à¹ˆà¸”à¹‰à¸²à¸™à¸šà¸™à¸‚à¸­à¸‡à¸à¸£à¸²à¸Ÿ (à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¸¥à¸‡à¸¡à¸²à¸£à¸µà¹€à¸—à¸ªà¹€à¸¡à¸™à¸•à¹Œà¸—à¸µà¹ˆ 61.8)
// 4. SL à¸•à¹‰à¸­à¸‡à¹„à¸¡à¹ˆà¸«à¸¥à¸¸à¸” LL
bool smaAbovePrice = close < fastSMA and close < slowSMA  // SMA7/21 à¸­à¸¢à¸¹à¹ˆà¸”à¹‰à¸²à¸™à¸šà¸™à¸‚à¸­à¸‡à¸à¸£à¸²à¸Ÿ (à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¸¥à¸‡à¸¡à¸²à¸£à¸µà¹€à¸—à¸ªà¹€à¸¡à¸™à¸•à¹Œ)
bool hasSupportAtFib618 = fvgCondition or obCondition  // à¸¡à¸µà¹à¸™à¸§à¸£à¸±à¸š (FVG à¸«à¸£à¸·à¸­ OB) à¸—à¸µà¹ˆ Fibonacci 61.8

// ========================================================================
// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚ CONFIRMATION à¸•à¸²à¸¡ Market Structure
// ========================================================================
// 1. CHOCH 5M (Market Structure Break)
bool hasConfirmedTrend_5M = chochDetected_5M

// 2. à¸¡à¸µ Support (FVG à¸«à¸£à¸·à¸­ OB) à¸—à¸µà¹ˆ Fib 61.8 - à¸•à¹‰à¸­à¸‡à¸¡à¸µà¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 1 à¸­à¸¢à¹ˆà¸²à¸‡
bool mustHaveSupport = fvgCondition or obCondition

// 3. RSI confirmation
bool rsiConfirmLong = rsiValue < 50

// 4. à¸£à¸²à¸„à¸²à¸•à¹‰à¸­à¸‡à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™ Demand Zone à¸ˆà¸£à¸´à¸‡à¹† (FVG + OB + à¸­à¸¢à¸¹à¹ˆà¹ƒà¸à¸¥à¹‰ Fib 61.8)
// à¸•à¹‰à¸­à¸‡à¸¡à¸µ FVG à¹à¸¥à¸° OB à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆà¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡ FVG à¸žà¸£à¹‰à¸­à¸¡à¸à¸±à¸™
// à¸—à¸³à¹ƒà¸«à¹‰à¸‡à¹ˆà¸²à¸¢à¸‚à¸¶à¹‰à¸™: à¸–à¹‰à¸²à¸¡à¸µ FVG à¸«à¸£à¸·à¸­ OB à¸­à¸¢à¹ˆà¸²à¸‡à¹ƒà¸”à¸­à¸¢à¹ˆà¸²à¸‡à¸«à¸™à¸¶à¹ˆà¸‡à¸à¹‡à¸žà¸­
bool inDemandZone = (hasFVG or hasEngulfingOB or hasOBBelowFVG or hasDemandBelowFVG) and priceAtFib618

// à¸£à¸§à¸¡à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚ Confirmation à¸ªà¸³à¸«à¸£à¸±à¸š LONG (Market Structure)
// à¸—à¸³à¹ƒà¸«à¹‰à¸‡à¹ˆà¸²à¸¢à¸‚à¸¶à¹‰à¸™: à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸¡à¸µ inDemandZone (à¹€à¸žà¸£à¸²à¸°à¸¡à¸±à¸™à¸‹à¸±à¸šà¸‹à¹‰à¸­à¸™à¹€à¸à¸´à¸™à¹„à¸›)
bool hasStrongConfirmation = hasConfirmedTrend_5M and mustHaveSupport and rsiConfirmLong

// Wave A Entry Condition - à¸•à¹‰à¸­à¸‡à¸¡à¸µ Market Structure Break + à¸£à¸²à¸„à¸²à¸—à¸”à¸ªà¸­à¸š Fib 0.618
// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: CHOCH + à¸£à¸²à¸„à¸² LOW à¸—à¸”à¸ªà¸­à¸š Fib 61.8 + close à¹€à¸«à¸™à¸·à¸­ Fib (rejection) + LL/HH + Demand Zone + RSI + à¹„à¸¡à¹ˆà¸«à¸¥à¸¸à¸” LL
// à¸ªà¸±à¸à¸à¸²à¸“à¸•à¹‰à¸­à¸‡à¹€à¸à¸´à¸”à¸•à¸£à¸‡à¸ˆà¸¸à¸”à¸—à¸µà¹ˆà¸£à¸²à¸„à¸²à¸—à¸”à¸ªà¸­à¸š 0.618 à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™ (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¹€à¸›à¸´à¸”à¸¡à¸²à¸—à¸±à¹‰à¸‡à¸—à¸²à¸‡)
// à¸—à¸³à¹ƒà¸«à¹‰à¸‡à¹ˆà¸²à¸¢à¸‚à¸¶à¹‰à¸™: à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¸¡à¸µ hasFVG (à¹€à¸žà¸£à¸²à¸°à¸¡à¸±à¸™à¸‹à¸±à¸šà¸‹à¹‰à¸­à¸™à¹€à¸à¸´à¸™à¹„à¸›)
bool waveAEntryCondition = isWaveA and priceAtFib618 and inFibZone and not na(fibRetracement618) and hasLL and hasHH and notBrokeLL and hasStrongConfirmation and low <= fibRetracement618

// Wave B Entry Condition - à¸•à¹‰à¸­à¸‡à¹„à¸¡à¹ˆà¸‹à¹‰à¸­à¸™à¸à¸±à¸š Wave A à¹à¸¥à¸° Wave A à¸•à¹‰à¸­à¸‡à¸ˆà¸šà¸ˆà¸£à¸´à¸‡ (100%+)
// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: Wave A à¸ˆà¸š (100%) + CHOCH M5 à¹ƒà¸«à¸¡à¹ˆ + à¸£à¸²à¸„à¸² LOW à¸—à¸”à¸ªà¸­à¸š Fib 61.8 + close à¹€à¸«à¸™à¸·à¸­ Fib + Demand Zone
// à¸ªà¸±à¸à¸à¸²à¸“à¸•à¹‰à¸­à¸‡à¹€à¸à¸´à¸”à¸•à¸£à¸‡à¸ˆà¸¸à¸”à¸—à¸µà¹ˆà¸£à¸²à¸„à¸²à¸—à¸”à¸ªà¸­à¸š 0.618 à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™
bool waveBEntryCondition = isWaveB and not isWaveA and priceAtFib618 and inFibZone and not na(fibRetracement618) and hasLL and hasHH and hasStrongConfirmation and waveAReached100Percent and low <= fibRetracement618

// Major Wave B Entry (0.382) - à¸à¸Ž: Wave A à¹ƒà¸«à¸à¹ˆà¸ˆà¸š â†’ à¸›à¸£à¸±à¸šà¸•à¸·à¹‰à¸™ 0.33-0.382
// à¸•à¹‰à¸­à¸‡à¸ªà¸£à¹‰à¸²à¸‡ HL/LL + RSI à¹à¸£à¸‡ + à¹„à¸¡à¹ˆà¸¥à¸‡à¹€à¸à¸´à¸™ HH à¸‚à¸­à¸‡ sub-wave A
// à¸à¸Ž: à¸ˆà¸šà¹€à¸§à¸Ÿ A à¸¢à¹ˆà¸­à¸›à¸£à¸±à¸šà¸•à¸·à¹‰à¸™ 0.33 à¸–à¸¶à¸‡ 0.382 à¹„à¸¡à¹ˆà¸„à¸§à¸£à¸¥à¸‡à¹€à¸à¸´à¸™à¸‚à¸­à¸‡ HH à¸‚à¸­à¸‡ sub à¹€à¸§à¸Ÿà¸‚à¸­à¸‡ A
// à¸à¸²à¸£à¸¢à¸·à¸™à¸¢à¸±à¸™: à¸–à¹‰à¸²à¸à¸¥à¸±à¸šà¸•à¸±à¸§à¸—à¸µà¹ˆ 0.382 à¸«à¸£à¸·à¸­ 0.33 à¸£à¸²à¸„à¸²à¸ˆà¸°à¸ªà¸£à¹‰à¸²à¸‡ HL/LL à¹à¸¥à¸°à¸¡à¸µà¹à¸£à¸‡à¸ªà¹ˆà¸‡à¸‚à¸­à¸‡ RSI
bool priceAtFib382 = not na(fibRetracement382) and math.abs(close - fibRetracement382) < (fibRetracement382 * 0.015)  // Â±1.5%
bool priceAtFib33 = not na(fibRetracement33) and math.abs(close - fibRetracement33) < (fibRetracement33 * 0.015)
bool inFibZone382 = not na(fibRetracement382) and not na(fibRetracement33) and close >= fibRetracement382 * 0.99 and close <= fibRetracement33 * 1.01
// Confirmation: Wave A à¹ƒà¸«à¸à¹ˆà¸ˆà¸š (100%+) + à¸›à¸£à¸±à¸šà¸•à¸·à¹‰à¸™ + RSI + HL/LL + CHOCH M5
bool majorWaveBConfirmation = waveAReached100Percent and hasStrongConfirmation and hasLL and hasHH and chochDetected_5M
bool majorWaveBEntryCondition = (priceAtFib382 or priceAtFib33 or inFibZone382) and majorWaveBConfirmation

// Fallback Entry - à¸•à¹‰à¸­à¸‡à¸¡à¸µ Strong Confirmation à¹€à¸«à¸¡à¸·à¸­à¸™à¸à¸±à¸™
bool fallbackEntryCondition = hasLL and hasHH and priceAtFib618 and inFibZone and not na(fibRetracement618) and hasStrongConfirmation

// ========================================================================
// à¸£à¸°à¸šà¸šà¸‹à¸´à¸à¹à¸™à¸¥à¹ƒà¸«à¸¡à¹ˆ: SMA Crossover + 3 à¸ªà¸§à¸´à¸‡ ABC + Fibo 61.8
// ========================================================================
// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚:
// 1. SMA 7 à¸•à¸±à¸”à¸‚à¸¶à¹‰à¸™ SMA 21 à¸—à¸µà¹ˆ TF 15M
// 2. à¸•à¹‰à¸­à¸‡à¸—à¸³ 3 à¸ªà¸§à¸´à¸‡ ABC à¸ˆà¸šà¸Šà¸¸à¸” A (correctionWaveCount == 1 = Wave A à¸ˆà¸š)
// 3. à¸£à¸²à¸„à¸²à¸¥à¸‡à¸¡à¸²à¸—à¸µà¹ˆ Fibo 61.8 â†’ à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¸—à¸±à¸™à¸—à¸µ
// 4. SL à¸­à¸¢à¸¹à¹ˆà¸—à¸µà¹ˆ LL à¸‚à¸­à¸‡à¸ªà¸§à¸´à¸‡
// 5. à¹ƒà¸Šà¹‰ Fibo Extension à¸«à¸² POI à¸•à¸²à¸¡à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚ Elliott Wave

// à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸š SMA Crossover à¸—à¸µà¹ˆ 15M
float sma7_15M = request.security(syminfo.tickerid, "15", ta.sma(close, fastLength), lookahead=barmerge.lookahead_off)
float sma21_15M = request.security(syminfo.tickerid, "15", ta.sma(close, slowLength), lookahead=barmerge.lookahead_off)
float sma7_15M_prev = request.security(syminfo.tickerid, "15", ta.sma(close, fastLength)[1], lookahead=barmerge.lookahead_off)
float sma21_15M_prev = request.security(syminfo.tickerid, "15", ta.sma(close, slowLength)[1], lookahead=barmerge.lookahead_off)
bool smaCrossover_15M = not na(sma7_15M) and not na(sma21_15M) and not na(sma7_15M_prev) and not na(sma21_15M_prev) and sma7_15M > sma21_15M and sma7_15M_prev <= sma21_15M_prev

// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š 3 à¸ªà¸§à¸´à¸‡ ABC à¸ˆà¸šà¸Šà¸¸à¸” A
// Wave A à¸ˆà¸š = correctionWaveCount == 1 (Wave A à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¹à¸¥à¹‰à¸§) à¹à¸¥à¸°à¸¡à¸µ pivot points à¸—à¸µà¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡
// à¸•à¹‰à¸­à¸‡à¸¡à¸µ: Wave A (pivot low = wave1Low) à¹à¸¥à¸°à¸¡à¸µ pivot high à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸à¸™à¸±à¹‰à¸™ (Wave B)
// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸ˆà¸²à¸ pivot points: à¸•à¹‰à¸­à¸‡à¸¡à¸µà¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 2 pivots (Low à¹à¸¥à¹‰à¸§ High) = Wave A à¹à¸¥à¸° Wave B à¹€à¸£à¸´à¹ˆà¸¡à¹à¸¥à¹‰à¸§
bool waveACompleted_ABC = correctionWaveCount == 1 and not na(wave1Low) and array.size(pivotHighs) > 0 and array.size(pivotLows) > 0

// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸£à¸²à¸„à¸²à¸¥à¸‡à¸¡à¸²à¸—à¸µà¹ˆ Fibo 61.8
bool priceAtFib618_NewSignal = not na(fibRetracement618) and low <= fibRetracement618 * 1.01 and low >= fibRetracement618 * 0.99

// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸‹à¸´à¸à¹à¸™à¸¥à¹ƒà¸«à¸¡à¹ˆ: SMA Crossover + Wave A à¸ˆà¸š + à¸£à¸²à¸„à¸²à¸—à¸µà¹ˆ Fibo 61.8
// à¹€à¸žà¸´à¹ˆà¸¡à¸à¸²à¸£à¸¢à¸·à¸™à¸¢à¸±à¸™à¸ˆà¸²à¸ M1 à¹à¸¥à¸° M5: à¸•à¹‰à¸­à¸‡à¸¡à¸µ trend à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¸—à¸µà¹ˆ M1 à¹à¸¥à¸° M5 à¹€à¸žà¸·à¹ˆà¸­à¸¢à¸·à¸™à¸¢à¸±à¸™
float close_1M_NewSignal = request.security(syminfo.tickerid, "1", close, lookahead=barmerge.lookahead_off)
float close_5M_NewSignal = request.security(syminfo.tickerid, "5", close, lookahead=barmerge.lookahead_off)
bool trend_1M_NewSignal = not na(fastSMA_1M) and not na(slowSMA_1M) and not na(close_1M_NewSignal) and close_1M_NewSignal > fastSMA_1M and fastSMA_1M > slowSMA_1M
bool trend_5M_NewSignal = not na(fastSMA_5M) and not na(slowSMA_5M) and not na(close_5M_NewSignal) and close_5M_NewSignal > fastSMA_5M and fastSMA_5M > slowSMA_5M
bool m1M5Confirmation = trend_1M_NewSignal and trend_5M_NewSignal  // à¸¢à¸·à¸™à¸¢à¸±à¸™à¸ˆà¸²à¸ M1 à¹à¸¥à¸° M5

// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸‹à¸´à¸à¹à¸™à¸¥à¹ƒà¸«à¸¡à¹ˆ: SMA Crossover (15M) + Wave A à¸ˆà¸š + à¸£à¸²à¸„à¸²à¸—à¸µà¹ˆ Fibo 61.8 + à¸¢à¸·à¸™à¸¢à¸±à¸™à¸ˆà¸²à¸ M1/M5
bool newSignalCondition = smaCrossover_15M and waveACompleted_ABC and priceAtFib618_NewSignal and m1M5Confirmation and hasLL and hasHH and not na(fibRetracement618) and strategy.position_size == 0

// ========================================================================
// à¹à¸ªà¸”à¸‡ Limit Entry Point à¸—à¸µà¹ˆ Fib 61.8 (à¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µ HH/LL à¹à¸¥à¸° CHOCH à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡)
// ========================================================================
// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: à¸¡à¸µ HH/LL + CHOCH à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡ (5M à¸«à¸£à¸·à¸­ 15M à¸«à¸£à¸·à¸­ 1H) + à¸£à¸²à¸„à¸²à¸­à¸¢à¸¹à¹ˆà¹ƒà¸à¸¥à¹‰ Fib 61.8
bool hasStrongCHOCH = chochDetected_5M or chochDetected_15M or chochDetected_1H
bool showLimitEntry = showLimitEntryPoint and hasLL and hasHH and hasStrongCHOCH and not na(fibRetracement618) and strategy.position_size == 0
bool priceNearFib618 = not na(fibRetracement618) and (low <= fibRetracement618 * 1.02 and low >= fibRetracement618 * 0.98) or (close >= fibRetracement618 * 0.98 and close <= fibRetracement618 * 1.02)

// à¸•à¸±à¸§à¹à¸›à¸£à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸à¹‡à¸š label à¹à¸¥à¸° line limit entry
var label limitEntryLabel = na
var line limitEntryLine = na

// à¹à¸ªà¸”à¸‡ Limit Entry Point
if showLimitEntry and priceNearFib618
    // à¸„à¸³à¸™à¸§à¸“ entry price (à¹ƒà¸Šà¹‰ low à¸ªà¸³à¸«à¸£à¸±à¸š Long - à¸›à¸¥à¸²à¸¢ wick)
    float limitEntryPrice = math.min(low, fibRetracement618)
    
    // à¸¥à¸š label à¹à¸¥à¸° line à¹€à¸à¹ˆà¸² (à¸–à¹‰à¸²à¸¡à¸µ)
    if not na(limitEntryLabel)
        label.delete(limitEntryLabel)
    if not na(limitEntryLine)
        line.delete(limitEntryLine)
    
    // à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸ªà¹‰à¸™à¹à¸™à¸§à¸™à¸­à¸™à¸—à¸µà¹ˆà¸£à¸²à¸„à¸² Fib 61.8 (à¹à¸ªà¸”à¸‡ limit entry level)
    limitEntryLine := line.new(bar_index - 20, fibRetracement618, bar_index + 50, fibRetracement618, color=color.new(color.green, 30), width=2, style=line.style_dashed, extend=extend.right)
    
    // à¸ªà¸£à¹‰à¸²à¸‡ label à¸—à¸µà¹ˆà¸£à¸²à¸„à¸² Fib 61.8
    string chochText = chochDetected_5M ? "CHOCH 5M" : (chochDetected_15M ? "CHOCH 15M" : "CHOCH 1H")
    string entryText = "ðŸ”µ LIMIT BUY\n@" + str.tostring(limitEntryPrice, "#.##") + "\nFib 61.8%\n" + chochText
    string tooltipText = "Limit Entry Point at Fib 61.8%\nâœ“ HH/LL: Ready\nâœ“ CHOCH: " + chochText + "\nâœ“ Entry: " + str.tostring(limitEntryPrice, "#.##") + "\nâœ“ SL: " + str.tostring(not na(fibLL) ? fibLL : na, "#.##")
    limitEntryLabel := label.new(bar_index, fibRetracement618, text=entryText, color=color.new(color.blue, 0), textcolor=color.white, style=label.style_label_up, size=size.normal, tooltip=tooltipText)
else if showLimitEntry and not priceNearFib618
    // à¹à¸ªà¸”à¸‡ label à¹à¸šà¸šà¸–à¸²à¸§à¸£à¸—à¸µà¹ˆ Fib 61.8 (à¹à¸¡à¹‰à¸£à¸²à¸„à¸²à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸–à¸¶à¸‡) à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸žà¸£à¹‰à¸­à¸¡
    if not na(limitEntryLabel)
        label.delete(limitEntryLabel)
    if not na(limitEntryLine)
        line.delete(limitEntryLine)
    
    // à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸ªà¹‰à¸™à¹à¸™à¸§à¸™à¸­à¸™à¸—à¸µà¹ˆà¸£à¸²à¸„à¸² Fib 61.8 (à¹à¸ªà¸”à¸‡ limit entry level)
    limitEntryLine := line.new(bar_index - 20, fibRetracement618, bar_index + 50, fibRetracement618, color=color.new(color.yellow, 50), width=1, style=line.style_dotted, extend=extend.right)
    
    // à¸ªà¸£à¹‰à¸²à¸‡ label à¹à¸šà¸šà¸–à¸²à¸§à¸£
    string chochText = chochDetected_5M ? "CHOCH 5M" : (chochDetected_15M ? "CHOCH 15M" : "CHOCH 1H")
    string entryText = "â³ LIMIT BUY\n@" + str.tostring(fibRetracement618, "#.##") + "\nFib 61.8%\n" + chochText + "\nWaiting..."
    string tooltipText2 = "Limit Entry Point at Fib 61.8%\nâœ“ HH/LL: Ready\nâœ“ CHOCH: " + chochText + "\nâ³ Waiting for price to reach Fib 61.8"
    limitEntryLabel := label.new(bar_index, fibRetracement618, text=entryText, color=color.new(color.yellow, 0), textcolor=color.white, style=label.style_label_left, size=size.small, tooltip=tooltipText2)
else
    // à¸¥à¸š label à¹à¸¥à¸° line à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¹„à¸¡à¹ˆà¸žà¸£à¹‰à¸­à¸¡
    if not na(limitEntryLabel)
        label.delete(limitEntryLabel)
        limitEntryLabel := na
    if not na(limitEntryLine)
        line.delete(limitEntryLine)
        limitEntryLine := na

// ========================================================================
// à¹à¸ªà¸”à¸‡ Stop Loss (SL) à¸—à¸µà¹ˆ LL à¸‚à¸­à¸‡à¸ªà¸§à¸´à¸‡
// ========================================================================
// à¹à¸ªà¸”à¸‡ SL line à¹à¸¥à¸° label à¸—à¸µà¹ˆ fibLL à¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µ position à¸«à¸£à¸·à¸­à¸žà¸£à¹‰à¸­à¸¡à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”
var line stopLossLine = na
var label stopLossLabel = na

// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¹à¸ªà¸”à¸‡ SL: à¸¡à¸µ fibLL à¹à¸¥à¸° (à¸¡à¸µ position à¸«à¸£à¸·à¸­à¸žà¸£à¹‰à¸­à¸¡à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”)
bool showStopLoss = showLimitEntryPoint and not na(fibLL) and (strategy.position_size > 0 or (hasLL and hasHH and hasStrongCHOCH and not na(fibRetracement618)))

if showStopLoss
    // à¸¥à¸š line à¹à¸¥à¸° label à¹€à¸à¹ˆà¸² (à¸–à¹‰à¸²à¸¡à¸µ)
    if not na(stopLossLine)
        line.delete(stopLossLine)
    if not na(stopLossLabel)
        label.delete(stopLossLabel)
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸£à¸²à¸„à¸²à¸«à¸¥à¸¸à¸” LL à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡
    bool priceBrokeLL = low < fibLL
    color slLineColor = priceBrokeLL ? color.new(color.red, 0) : color.new(color.orange, 0)
    string slText = priceBrokeLL ? "ðŸ›‘ STOP LOSS âš ï¸\n@" + str.tostring(fibLL, "#.##") + "\nSwing LL\nâš ï¸ BROKEN!" : "ðŸ›‘ STOP LOSS\n@" + str.tostring(fibLL, "#.##") + "\nSwing LL"
    string slTooltip = "Stop Loss at Swing LL\nPrice: " + str.tostring(fibLL, "#.##") + (priceBrokeLL ? "\nâš ï¸ PRICE BROKE BELOW LL!\nExit immediately!" : "\nâš ï¸ Exit if price breaks below this level")
    
    // à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸ªà¹‰à¸™à¹à¸™à¸§à¸™à¸­à¸™à¸—à¸µà¹ˆà¸£à¸²à¸„à¸² SL (fibLL)
    stopLossLine := line.new(bar_index - 20, fibLL, bar_index + 50, fibLL, color=slLineColor, width=2, style=line.style_solid, extend=extend.right)
    
    // à¸ªà¸£à¹‰à¸²à¸‡ label à¸—à¸µà¹ˆà¸£à¸²à¸„à¸² SL
    stopLossLabel := label.new(bar_index, fibLL, text=slText, color=color.new(color.red, 0), textcolor=color.white, style=label.style_label_down, size=size.normal, tooltip=slTooltip)
else
    // à¸¥à¸š line à¹à¸¥à¸° label à¹€à¸¡à¸·à¹ˆà¸­à¹„à¸¡à¹ˆà¹à¸ªà¸”à¸‡
    if not na(stopLossLine)
        line.delete(stopLossLine)
        stopLossLine := na
    if not na(stopLossLabel)
        label.delete(stopLossLabel)
        stopLossLabel := na

// à¹à¸ªà¸”à¸‡ Entry Signals à¸šà¸™à¸à¸£à¸²à¸Ÿ - à¸§à¸‡à¸à¸¥à¸¡à¸ªà¸µà¸Ÿà¹‰à¸² (A) à¹à¸¥à¸°à¸ªà¸µà¸ªà¹‰à¸¡ (B)
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: plotshape à¸–à¸¹à¸à¸¢à¹‰à¸²à¸¢à¹„à¸›à¹„à¸§à¹‰à¸—à¸µà¹ˆà¸šà¸£à¸£à¸—à¸±à¸” 1442-1445 à¹à¸¥à¹‰à¸§

// ========================================================================
// à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸à¸²à¸£à¹€à¸‚à¹‰à¸²à¸‹à¹‰à¸³à¹ƒà¸™ Major Wave à¹€à¸”à¸µà¸¢à¸§à¸à¸±à¸™ (Anti-Re-entry - à¹€à¸‚à¹‰à¸¡à¸‡à¸§à¸”à¸¡à¸²à¸à¸‚à¸¶à¹‰à¸™)
// ========================================================================
// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸² Major Wave à¸ˆà¸šà¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡ (à¹‚à¸”à¸¢à¸”à¸¹à¸ˆà¸²à¸à¸à¸²à¸£à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™ structure à¸—à¸µà¹ˆà¸Šà¸±à¸”à¹€à¸ˆà¸™)
bool newMajorWaveDetected = false
if not na(firstWaveLL) and not na(firstWaveHH)
    // à¸•à¹‰à¸­à¸‡à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹à¸›à¸¥à¸‡à¸­à¸¢à¹ˆà¸²à¸‡à¸Šà¸±à¸”à¹€à¸ˆà¸™ (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹‰ ATR à¹à¸¥à¹‰à¸§ - à¹ƒà¸Šà¹‰ percentage à¹à¸—à¸™)
    float structureChangePercent = 0.05  // 5% change = new structure
    bool structureChanged = (not na(lastMajorWaveHL) and math.abs(firstWaveLL - lastMajorWaveHL) > lastMajorWaveHL * structureChangePercent) or (not na(lastMajorWaveHH) and math.abs(firstWaveHH - lastMajorWaveHH) > lastMajorWaveHH * structureChangePercent)
    newMajorWaveDetected := structureChanged or na(lastMajorWaveHL)

// Reset cooldown à¸–à¹‰à¸²à¹€à¸à¸´à¸” Major Wave à¹ƒà¸«à¸¡à¹ˆ
if newMajorWaveDetected
    lastEntryWaveType := ""
    majorWaveCompleted := false

// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™ cooldown period à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (à¹€à¸‚à¹‰à¸¡à¸‡à¸§à¸”à¸¡à¸²à¸à¸‚à¸¶à¹‰à¸™)
// à¸«à¹‰à¸²à¸¡à¹€à¸‚à¹‰à¸²à¸‹à¹‰à¸³à¸ˆà¸™à¸à¸§à¹ˆà¸²à¸ˆà¸°:
// 1. à¸›à¸´à¸” position à¹à¸¥à¹‰à¸§ (majorWaveCompleted = true)
// 2. à¸žà¸š Major Wave à¹ƒà¸«à¸¡à¹ˆ (newMajorWaveDetected = true)
// 3. à¸œà¹ˆà¸²à¸™à¹„à¸›à¸­à¸¢à¹ˆà¸²à¸‡à¸™à¹‰à¸­à¸¢ 100 bars (à¹à¸—à¸™ 50)
bool inCooldownPeriod = not na(lastMajorWaveEntryBar) and not majorWaveCompleted and not newMajorWaveDetected

// à¹€à¸žà¸´à¹ˆà¸¡à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: à¸«à¹‰à¸²à¸¡ entry à¸–à¹‰à¸²à¸¡à¸µ position à¸­à¸¢à¸¹à¹ˆà¹à¸¥à¹‰à¸§
bool hasOpenPosition = strategy.position_size != 0

// ========================================================================
// ENTRY LOGIC (à¸¡à¸µ Priority: Wave A > Wave B > Fallback)
// ========================================================================
// à¸à¸Ž: Wave A à¹€à¸à¸´à¸”à¸à¹ˆà¸­à¸™ â†’ à¸ˆà¸š + CHOCH M5 â†’ à¸–à¸¶à¸‡à¸ˆà¸°à¹€à¸›à¹‡à¸™ Wave B
// à¸«à¹‰à¸²à¸¡ Wave A à¹à¸¥à¸° Wave B à¹€à¸à¸´à¸”à¸žà¸£à¹‰à¸­à¸¡à¸à¸±à¸™ (à¸‹à¹‰à¸­à¸™à¸à¸±à¸™)

// ========================================================================
// à¸£à¸°à¸šà¸šà¸‹à¸´à¸à¹à¸™à¸¥à¹ƒà¸«à¸¡à¹ˆ: SMA Crossover + 3 à¸ªà¸§à¸´à¸‡ ABC + Fibo 61.8 (Priority 0 - à¸ªà¸¹à¸‡à¸ªà¸¸à¸”)
// ========================================================================
if newSignalCondition and strategy.position_size == 0 and not inCooldownPeriod and not hasOpenPosition
    // à¸„à¸³à¸™à¸§à¸“ Entry, SL, TP à¸•à¸²à¸¡à¸£à¸°à¸šà¸šà¹ƒà¸«à¸¡à¹ˆ
    float newEntryPrice = math.min(low, fibRetracement618)  // Entry à¸—à¸µà¹ˆ Fibo 61.8 (à¹ƒà¸Šà¹‰ low)
    float newStopLoss = not na(fibLL) ? fibLL : newEntryPrice * 0.99  // SL à¸—à¸µà¹ˆ LL à¸‚à¸­à¸‡à¸ªà¸§à¸´à¸‡
    
    // à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œ Elliott Wave Pattern
    // à¹ƒà¸Šà¹‰ pivot points à¸ˆà¸²à¸ array à¹€à¸žà¸·à¹ˆà¸­à¸§à¸´à¹€à¸„à¸£à¸²à¸°à¸«à¹Œ Wave A, B, C
    float waveALow = not na(wave1Low) ? wave1Low : (array.size(pivotLows) > 0 ? array.get(pivotLows, 0) : na)
    float waveAHigh = not na(wave1High) ? wave1High : (array.size(pivotHighs) > 0 ? array.get(pivotHighs, 0) : na)
    float waveBLow = array.size(pivotLows) > 1 ? array.get(pivotLows, 1) : na
    float waveBHigh = array.size(pivotHighs) > 1 ? array.get(pivotHighs, 1) : na
    float waveCLow = array.size(pivotLows) > 2 ? array.get(pivotLows, 2) : na
    float waveCHigh = array.size(pivotHighs) > 2 ? array.get(pivotHighs, 2) : na
    
    [isFlatPattern, isExtendedWave, isZigzagPattern] = analyzeElliottWavePattern(waveALow, waveAHigh, waveBLow, waveBHigh, waveCLow, waveCHigh)
    
    // à¸„à¸³à¸™à¸§à¸“ TP à¸ˆà¸²à¸ Fibo Extension à¸•à¸²à¸¡ Elliott Wave
    // à¹ƒà¸Šà¹‰ Wave A (waveALow to waveAHigh) à¹€à¸›à¹‡à¸™à¸à¸²à¸™
    float waveARange = not na(waveAHigh) and not na(waveALow) ? waveAHigh - waveALow : na
    float newTP1 = na, float newTP2 = na, float newTP3 = na
    
    if not na(waveARange) and waveARange > 0
        // Correction Wave (ABC): Wave C à¸¡à¸±à¸à¸ˆà¸° 1.0 à¸«à¸£à¸·à¸­ 1.618 à¸‚à¸­à¸‡ Wave A
        // à¹ƒà¸Šà¹‰ Fibo Extension à¸ˆà¸²à¸ Entry Price (Fibo 61.8) à¹„à¸›à¸«à¸² POI
        if isFlatPattern
            // Flat Pattern: Wave C à¸¡à¸±à¸à¸ˆà¸° 1.0 à¸«à¸£à¸·à¸­ 1.236 à¸‚à¸­à¸‡ Wave A
            // POI = Entry + (Wave A Range Ã— Extension Level)
            newTP1 := newEntryPrice + (waveARange * 1.0)  // POI1 = 100% extension
            newTP2 := newEntryPrice + (waveARange * 1.236)  // POI2 = 123.6% extension
            newTP3 := newEntryPrice + (waveARange * 1.618)  // POI3 = 161.8% extension
        else if isZigzagPattern
            // Zigzag Pattern: Wave C à¸¡à¸±à¸à¸ˆà¸° 1.0 à¸«à¸£à¸·à¸­ 1.618 à¸‚à¸­à¸‡ Wave A
            newTP1 := newEntryPrice + (waveARange * 1.0)  // POI1 = 100% extension
            newTP2 := newEntryPrice + (waveARange * 1.618)  // POI2 = 161.8% extension
            newTP3 := newEntryPrice + (waveARange * 2.618)  // POI3 = 261.8% extension
        else if isExtendedWave
            // Extended Wave: Wave C à¸¢à¸²à¸§à¸¡à¸²à¸ â†’ TP à¹ƒà¸Šà¹‰ 2.618 à¹à¸¥à¸° 4.236
            newTP1 := newEntryPrice + (waveARange * 1.618)  // POI1 = 161.8% extension
            newTP2 := newEntryPrice + (waveARange * 2.618)  // POI2 = 261.8% extension
            newTP3 := newEntryPrice + (waveARange * 4.236)  // POI3 = 423.6% extension
        else
            // Normal Correction: Wave C à¸¡à¸±à¸à¸ˆà¸° 1.0 à¸«à¸£à¸·à¸­ 1.618 à¸‚à¸­à¸‡ Wave A
            newTP1 := newEntryPrice + (waveARange * 1.0)  // POI1 = 100% extension
            newTP2 := newEntryPrice + (waveARange * 1.618)  // POI2 = 161.8% extension
            newTP3 := newEntryPrice + (waveARange * 2.618)  // POI3 = 261.8% extension
    
    // à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”
    if not na(newEntryPrice) and not na(newStopLoss)
        strategy.entry("NewSignal_SMA_ABC", strategy.long, limit=newEntryPrice, comment="SMA+ABC Entry")
        setExitOrders("NewSignal_SMA_ABC_Exit", "NewSignal_SMA_ABC", newStopLoss, newTP1, newTP2, newTP3)
        
        // à¹€à¸à¹‡à¸šà¸„à¹ˆà¸² entry
        entryPrice := newEntryPrice
        stopLossPrice := newStopLoss
        fibTP1 := newTP1
        fibTP2 := newTP2
        fibTP3 := newTP3
        entryTime := time
        entryIndex := bar_index
        exitReason := ""
        exitPercent := 0.0
        justEnteredLong := true
        lastEntryWaveType := "NewSignal_SMA_ABC"
        
        // Alert
        if enableAlerts
            string tpInfo = (not na(newTP1) ? " TP1: " + str.tostring(newTP1) : "") + (not na(newTP2) ? " TP2: " + str.tostring(newTP2) : "") + (not na(newTP3) ? " TP3: " + str.tostring(newTP3) : "")
            alert("ðŸŸ¢ New Signal: SMA Crossover + ABC + Fibo 61.8 - " + syminfo.ticker + " Entry: " + str.tostring(newEntryPrice) + " SL: " + str.tostring(newStopLoss) + tpInfo, alert.freq_once_per_bar)
        
        if sendEntrySignals
            string macdTrend = macdLine > signalLine ? "Bullish" : "Bearish"
            string patternType = isFlatPattern ? "Flat" : (isZigzagPattern ? "Zigzag" : (isExtendedWave ? "Extended" : "Normal"))
            string aiData = createAIData("BUY", "SMA_ABC", newEntryPrice, newStopLoss, newTP1, newTP2, newTP3, correctionWaveCount, false, macdTrend, rsiValue, atrValue)
            string desc = "**New Signal System (SMA + ABC)**\n**Entry:** " + str.tostring(newEntryPrice, "#.##") + "\n**SL:** " + str.tostring(newStopLoss, "#.##") + "\n**TP1 (POI1):** " + str.tostring(newTP1, "#.##") + "\n**TP2 (POI2):** " + str.tostring(newTP2, "#.##") + (not na(newTP3) ? "\n**TP3 (POI3):** " + str.tostring(newTP3, "#.##") : "") + "\n**Pattern:** " + patternType + "\n**Wave A Range:** " + str.tostring(waveARange, "#.##")
            sendDiscordAlert("ðŸŸ¢ New Signal: SMA+ABC - " + syminfo.ticker, desc, "3066993", aiData)

// ========================================================================
// Scale-in Entry System: à¹à¸šà¹ˆà¸‡ Position à¹€à¸‚à¹‰à¸²à¸—à¸µà¹ˆ Fib levels à¸•à¹ˆà¸²à¸‡à¹†
// ========================================================================
// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸£à¸²à¸„à¸²à¹à¸•à¸° Fib levels à¸•à¹ˆà¸²à¸‡à¹† à¸ªà¸³à¸«à¸£à¸±à¸š Scale-in Entry
bool priceAtFib382_ScaleIn = not na(fibRetracement382) and low <= fibRetracement382 * 1.01 and low >= fibRetracement382 * 0.99
bool priceAtFib50_ScaleIn = not na(fibRetracement50) and low <= fibRetracement50 * 1.01 and low >= fibRetracement50 * 0.99
bool priceAtFib618_ScaleIn = not na(fibRetracement618) and low <= fibRetracement618 * 1.01 and low >= fibRetracement618 * 0.99
bool priceAtFib786_ScaleIn = not na(fibRetracement786) and low <= fibRetracement786 * 1.01 and low >= fibRetracement786 * 0.99

// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸ªà¸³à¸«à¸£à¸±à¸š Scale-in Entry
bool canUseScaleIn = enableScaleInEntry and (waveAEntryCondition or waveBEntryCondition or fallbackEntryCondition) and hasLL and hasHH and hasStrongConfirmation and not na(fibRetracement382) and not na(fibRetracement50) and not na(fibRetracement618) and not na(fibLL)

// Scale-in Entry à¸—à¸µà¹ˆ Fib 0.382
if canUseScaleIn and priceAtFib382_ScaleIn and not entry382Filled
    executeScaleInEntry("0.382", fibRetracement382, fibLL, fibHH, firstWaveLL, firstWaveHH, fib382PositionPercent, waveAEntryCondition, waveBEntryCondition, fallbackEntryCondition, enableAlerts, "382")
    entry382Filled := true

// Scale-in Entry à¸—à¸µà¹ˆ Fib 0.50
if canUseScaleIn and priceAtFib50_ScaleIn and not entry50Filled and (entry382Filled or (not priceAtFib382_ScaleIn and low < fibRetracement382 * 1.01))
    executeScaleInEntry("0.50", fibRetracement50, fibLL, fibHH, firstWaveLL, firstWaveHH, fib50PositionPercent, waveAEntryCondition, waveBEntryCondition, fallbackEntryCondition, enableAlerts, "50")
    entry50Filled := true

// Scale-in Entry à¸—à¸µà¹ˆ Fib 0.618
if canUseScaleIn and priceAtFib618_ScaleIn and not entry618Filled and (entry50Filled or entry382Filled or (not priceAtFib50_ScaleIn and low < fibRetracement50 * 1.01))
    executeScaleInEntry("0.618", fibRetracement618, fibLL, fibHH, firstWaveLL, firstWaveHH, fib618PositionPercent, waveAEntryCondition, waveBEntryCondition, fallbackEntryCondition, enableAlerts, "618")
    entry618Filled := true

// Scale-in Entry à¸—à¸µà¹ˆ Fib 0.786
if canUseScaleIn and priceAtFib786_ScaleIn and not entry786Filled and fib786PositionPercent > 0 and not na(fibRetracement786)
    bool notBrokeLL786 = not na(fibLL) and not na(fibRetracement786) and fibRetracement786 > fibLL and low > fibLL
    bool canEnter786 = entry618Filled or entry50Filled or entry382Filled or (not priceAtFib618_ScaleIn and not na(fibRetracement618) and low < fibRetracement618)
    if notBrokeLL786 and canEnter786
        executeScaleInEntry("0.786", fibRetracement786, fibLL, fibHH, firstWaveLL, firstWaveHH, fib786PositionPercent, waveAEntryCondition, waveBEntryCondition, fallbackEntryCondition, enableAlerts, "786")
        entry786Filled := true

// Reset Scale-in Entry Tracking à¹€à¸¡à¸·à¹ˆà¸­à¸›à¸´à¸” position à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”
if strategy.position_size == 0
    entry382Filled := false
    entry50Filled := false
    entry618Filled := false
    entry786Filled := false

// Entry à¸ªà¸³à¸«à¸£à¸±à¸š Wave A (Priority 1) - à¹ƒà¸Šà¹‰ Scale-in Entry à¸–à¹‰à¸²à¹€à¸›à¸´à¸”à¹ƒà¸Šà¹‰à¸‡à¸²à¸™
// à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¹ƒà¸Šà¹‰ Scale-in = à¹ƒà¸Šà¹‰ entry à¹à¸šà¸šà¹€à¸”à¸´à¸¡ (100% à¸—à¸µà¹ˆ Fib 61.8)
if waveAEntryCondition and strategy.position_size == 0 and not inCooldownPeriod and not hasOpenPosition and lastEntryWaveType != "WaveA_Long" and not enableScaleInEntry
    [entryPrice, stopLossPrice, fibTP1, fibTP2, fibTP3] = executeLongEntry("Long_WaveA", "WaveA", "ðŸŸ¢ xon Wave A Entry", "ðŸŸ¢ xon Wave A Entry", ewEntryPrice, currentWaveForEntry, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibRetracement382, fibLL, fibHH, fibHL, firstWaveLL, firstWaveHH, wave1Low, wave1High, currentMajorWave, isImpulseWave, wave3Extended, trendFromCHOCH_1H, false, enableAlerts, sendEntrySignals, macdLine, signalLine, rsiValue, atrValue)
    entryTime := time
    entryIndex := bar_index
    exitReason := ""
    exitPercent := 0.0
    hlPrice := na
    hlIndex := na
    hlFirstCandleIndex := na
    hlFirstCandleOpen := na
    isSubWave := false
    rsiTested30 := false
    prevRSI := na
    tp1Exited := false
    m5BearishLow := na
    m15OBHigh := na
    m15OBBarIndex := na
    rejectionPartialExited := false
    justEnteredLong := true
    lastMajorWaveEntryBar := bar_index
    lastMajorWaveHL := firstWaveLL
    lastMajorWaveHH := firstWaveHH
    lastEntryWaveType := "WaveA_Long"
    majorWaveCompleted := false

// Entry à¸ªà¸³à¸«à¸£à¸±à¸š Wave B à¹„à¸› C (Priority 2)
// à¸•à¹‰à¸­à¸‡à¹à¸¢à¸à¸ˆà¸²à¸ Wave A: à¸«à¹‰à¸²à¸¡à¹€à¸‚à¹‰à¸² Wave B à¸–à¹‰à¸² Wave A à¸¢à¸±à¸‡à¹€à¸à¸´à¸”à¸­à¸¢à¸¹à¹ˆ
// Wave B à¹€à¸à¸´à¸”à¹„à¸”à¹‰à¸•à¹ˆà¸­à¹€à¸¡à¸·à¹ˆà¸­: Wave A à¸ˆà¸š + CHOCH M5 + à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ Wave A à¸­à¸µà¸à¸•à¹ˆà¸­à¹„à¸›
if waveBEntryCondition and not waveAEntryCondition and strategy.position_size == 0 and not inCooldownPeriod and not hasOpenPosition and lastEntryWaveType != "WaveB_Long"
    [entryPrice, stopLossPrice, fibTP1, fibTP2, fibTP3] = executeLongEntry("Long_WaveB", "WaveB", "ðŸŸ¢ xon Wave Bâ†’C Entry", "ðŸŸ¢ xon Wave Bâ†’C Entry", ewEntryPrice, currentWaveForEntry, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibRetracement382, fibLL, fibHH, fibHL, firstWaveLL, firstWaveHH, wave1Low, wave1High, currentMajorWave, isImpulseWave, wave3Extended, trendFromCHOCH_1H, false, enableAlerts, sendEntrySignals, macdLine, signalLine, rsiValue, atrValue)
    entryTime := time
    entryIndex := bar_index
    exitReason := ""
    exitPercent := 0.0
    hlPrice := na
    hlIndex := na
    hlFirstCandleIndex := na
    hlFirstCandleOpen := na
    isSubWave := false
    rsiTested30 := false
    prevRSI := na
    tp1Exited := false
    m5BearishLow := na
    m15OBHigh := na
    m15OBBarIndex := na
    rejectionPartialExited := false
    justEnteredLong := true
    lastMajorWaveEntryBar := bar_index
    lastMajorWaveHL := firstWaveLL
    lastMajorWaveHH := firstWaveHH
    lastEntryWaveType := "WaveB_Long"
    majorWaveCompleted := false

// Fallback Entry (Priority 3)
if fallbackEntryCondition and not waveAEntryCondition and not waveBEntryCondition and strategy.position_size == 0 and not inCooldownPeriod and not hasOpenPosition and lastEntryWaveType != "Fallback_Long"
    [entryPrice, stopLossPrice, fibTP1, fibTP2, fibTP3] = executeLongEntry("Long_Fallback", "Fallback", "ðŸŸ¢ xon Fallback Entry", "ðŸŸ¢ xon Fallback Entry", ewEntryPrice, currentWaveForEntry, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibRetracement382, fibLL, fibHH, fibHL, firstWaveLL, firstWaveHH, wave1Low, wave1High, currentMajorWave, isImpulseWave, wave3Extended, trendFromCHOCH_1H, false, enableAlerts, sendEntrySignals, macdLine, signalLine, rsiValue, atrValue)
    fibTP3 := na
    entryTime := time
    entryIndex := bar_index
    exitReason := ""
    exitPercent := 0.0
    hlPrice := na
    hlIndex := na
    hlFirstCandleIndex := na
    hlFirstCandleOpen := na
    isSubWave := false
    rsiTested30 := false
    prevRSI := na
    tp1Exited := false
    m5BearishLow := na
    m15OBHigh := na
    m15OBBarIndex := na
    rejectionPartialExited := false
    justEnteredLong := true
    lastMajorWaveEntryBar := bar_index
    lastMajorWaveHL := firstWaveLL
    lastMajorWaveHH := firstWaveHH
    lastEntryWaveType := "Fallback_Long"
    majorWaveCompleted := false

// ========================================================================
// MAJOR WAVE B ENTRY (Fib 0.382) - Priority 4
// ========================================================================
// à¹€à¸‚à¹‰à¸²à¹€à¸¡à¸·à¹ˆà¸­: Wave A >= 100% â†’ à¸›à¸£à¸±à¸šà¸•à¸·à¹‰à¸™ 0.33-0.382 â†’ à¸ªà¸£à¹‰à¸²à¸‡ HL/LL + RSI à¹à¸£à¸‡
// à¸«à¹‰à¸²à¸¡à¸‹à¹‰à¸­à¸™à¸à¸±à¸š Wave A à¸«à¸£à¸·à¸­ Wave B
if majorWaveBEntryCondition and not waveAEntryCondition and not waveBEntryCondition and strategy.position_size == 0 and not inCooldownPeriod and not hasOpenPosition and lastEntryWaveType != "MajorWaveB_Long"
    [entryPrice, stopLossPrice, fibTP1, fibTP2, fibTP3] = executeLongEntry("Long_MajorWaveB", "MajorWaveB", "ðŸŸ¢ðŸŸ¢ xon Major Wave B Entry (0.382)", "ðŸŸ¢ðŸŸ¢ xon Major Wave B Entry (0.382)", ewEntryPrice, currentWaveForEntry, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibRetracement382, fibLL, fibHH, fibHL, firstWaveLL, firstWaveHH, wave1Low, wave1High, currentMajorWave, isImpulseWave, wave3Extended, trendFromCHOCH_1H, true, enableAlerts, sendEntrySignals, macdLine, signalLine, rsiValue, atrValue)
    entryTime := time
    entryIndex := bar_index
    exitReason := ""
    exitPercent := 0.0
    hlPrice := na
    hlIndex := na
    hlFirstCandleIndex := na
    hlFirstCandleOpen := na
    isSubWave := false
    rsiTested30 := false
    prevRSI := na
    tp1Exited := false
    m5BearishLow := na
    m15OBHigh := na
    m15OBBarIndex := na
    rejectionPartialExited := false
    justEnteredLong := true
    lastMajorWaveEntryBar := bar_index
    lastMajorWaveHL := firstWaveLL
    lastMajorWaveHH := firstWaveHH
    lastEntryWaveType := "MajorWaveB_Long"
    majorWaveCompleted := false

//=============================================================================
// SHORT (SELL) ENTRY CONDITIONS - à¸ªà¸¡à¸¡à¸²à¸•à¸£à¸à¸±à¸š LONG
//=============================================================================
// à¸ªà¸£à¹‰à¸²à¸‡à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸ªà¸³à¸«à¸£à¸±à¸š Short (bearish trend) à¹‚à¸”à¸¢à¹ƒà¸Šà¹‰à¸«à¸¥à¸±à¸à¸à¸²à¸£à¹€à¸”à¸µà¸¢à¸§à¸à¸±à¸š Long à¹à¸•à¹ˆà¸à¸¥à¸±à¸šà¸”à¹‰à¸²à¸™
// à¹ƒà¸Šà¹‰ fibHH à¹à¸—à¸™ fibLL, à¹ƒà¸Šà¹‰ bear_choch_alert à¹à¸—à¸™ bull_choch_alert

// à¸•à¸±à¸§à¹à¸›à¸£à¸ªà¸³à¸«à¸£à¸±à¸š Short conditions (à¸à¸¥à¸±à¸šà¸”à¹‰à¸²à¸™à¸ˆà¸²à¸ Long)
bool isWaveA_Short = not na(fibHH) and not na(fibLL) and not chochDetected and trendFromCHOCH_1H < 0
// Wave B Short: Wave A à¸ˆà¸š + CHOCH M5 + à¸£à¸²à¸„à¸²à¸Šà¸™ Fib 61.8
bool isWaveB_Short = wave1Completed == true and not na(firstWaveHH) and not na(firstWaveLL) and chochDetected_5M == true
bool priceAtFib618_Short = false
if not na(fibRetracement618)
    // Short: high à¸•à¹‰à¸­à¸‡à¸—à¸”à¸ªà¸­à¸š Fib 0.618 à¹à¸¥à¸° close à¸•à¹‰à¸­à¸‡à¸­à¸¢à¸¹à¹ˆà¹ƒà¸•à¹‰ Fib 0.618 (rejection)
    float fib618 = fibRetracement618
    bool highTouchedFib = high >= fib618 * 0.995 and high <= fib618 * 1.005  // high à¸—à¸”à¸ªà¸­à¸š Fib Â±0.5%
    bool closedBelowFib = close < fib618  // close à¹ƒà¸•à¹‰ Fib (rejection)
    priceAtFib618_Short := highTouchedFib and closedBelowFib
bool inFibZone_Short = not na(fibRetracement618) and close <= fibRetracement618 * 1.02 and close >= fibRetracement618 * 0.95  // à¸£à¸²à¸„à¸²à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™à¹‚à¸‹à¸™ Fib
bool hasHH_Short = not na(fibHH)  // à¸¡à¸µ Higher High (à¸ªà¸³à¸«à¸£à¸±à¸š downtrend retracement)
bool hasLL_Short = not na(fibLL)  // à¸¡à¸µ Lower Low (à¸ªà¸³à¸«à¸£à¸±à¸š downtrend)
bool notBrokeHH_Short = not na(fibHH) ? close < fibHH : true  // à¸£à¸²à¸„à¸²à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸«à¸¥à¸¸à¸” HH (à¸ªà¸³à¸«à¸£à¸±à¸š Short)

// Bearish Rejection - à¸à¸¥à¸±à¸šà¸”à¹‰à¸²à¸™à¸ˆà¸²à¸ Bullish Rejection
bool hasBearishRejection = bearishRejection and atResistance

// ========================================================================
// CONFIRMATION à¸ªà¸³à¸«à¸£à¸±à¸š SHORT (Market Structure)
// ========================================================================
bool hasConfirmedTrend_5M_Short = chochDetected_5M
bool mustHaveResistance = atResistance or (not na(fibHH) and close >= fibHH * 0.98)
bool rsiConfirmShort = rsiValue > 50
bool inSupplyZone = atResistance
bool hasStrongConfirmation_Short = hasConfirmedTrend_5M_Short and mustHaveResistance and rsiConfirmShort and inSupplyZone

// Wave A Short Entry: à¸•à¹‰à¸­à¸‡à¸¡à¸µ Market Structure Break (CHOCH) + à¸£à¸²à¸„à¸²à¸—à¸”à¸ªà¸­à¸š Fib 0.618
// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: CHOCH + high à¸—à¸”à¸ªà¸­à¸š Fib 61.8 + close à¹ƒà¸•à¹‰ Fib (rejection) + HH/LL + Resistance + RSI
bool waveAShortEntryCondition = isWaveA_Short and priceAtFib618_Short and inFibZone_Short and hasHH_Short and hasLL_Short and notBrokeHH_Short and hasStrongConfirmation_Short and atResistance and high >= fibRetracement618

// Wave B Short Entry: Wave A à¸•à¹‰à¸­à¸‡à¸ˆà¸š (100%+) + CHOCH M5 à¹ƒà¸«à¸¡à¹ˆ + à¸£à¸²à¸„à¸²à¸—à¸”à¸ªà¸­à¸š Fib 0.618
bool waveBShortEntryCondition = isWaveB_Short and not isWaveA_Short and priceAtFib618_Short and inFibZone_Short and hasHH_Short and hasLL_Short and hasStrongConfirmation_Short and wave1Completed and high >= fibRetracement618

// Fallback Short Entry - à¸•à¹‰à¸­à¸‡à¸¡à¸µ Strong Confirmation à¹€à¸«à¸¡à¸·à¸­à¸™à¸à¸±à¸™
bool fallbackShortEntryCondition = hasHH_Short and hasLL_Short and priceAtFib618_Short and inFibZone_Short and hasStrongConfirmation_Short

// Entry à¸ªà¸³à¸«à¸£à¸±à¸š Wave A Short (Priority 1)
if waveAShortEntryCondition and strategy.position_size == 0 and not inCooldownPeriod and not hasOpenPosition and lastEntryWaveType != "WaveA_Short"
    [entryPrice, stopLossPrice, fibTP1, fibTP2, fibTP3] = executeShortEntry("Short_WaveA", "WaveA", "ðŸ”´ xon Wave A Short Entry", "ðŸ”´ xon Wave A Short Entry", ewEntryPrice, currentWaveForEntry, trendFromCHOCH_1H, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibHH, fibLL, firstWaveHH, firstWaveLL, enableAlerts, sendEntrySignals, macdLine, signalLine, rsiValue, atrValue)
    entryTime := time
    entryIndex := bar_index
    exitReason := ""
    exitPercent := 0.0
    hlPrice := na
    hlIndex := na
    hlFirstCandleIndex := na
    hlFirstCandleOpen := na
    isSubWave := false
    rsiTested30 := false
    prevRSI := na
    tp1Exited := false
    m5BearishLow := na
    m15OBHigh := na
    m15OBBarIndex := na
    rejectionPartialExited := false
    justEnteredShort := true
    lastMajorWaveEntryBar := bar_index
    lastMajorWaveHL := firstWaveLL
    lastMajorWaveHH := firstWaveHH
    lastEntryWaveType := "WaveA_Short"
    majorWaveCompleted := false

// Entry à¸ªà¸³à¸«à¸£à¸±à¸š Wave B Short (Priority 2)
// à¸•à¹‰à¸­à¸‡à¹à¸¢à¸à¸ˆà¸²à¸ Wave A Short: à¸«à¹‰à¸²à¸¡à¹€à¸‚à¹‰à¸² Wave B à¸–à¹‰à¸² Wave A à¸¢à¸±à¸‡à¹€à¸à¸´à¸”à¸­à¸¢à¸¹à¹ˆ
// Wave B à¹€à¸à¸´à¸”à¹„à¸”à¹‰à¸•à¹ˆà¸­à¹€à¸¡à¸·à¹ˆà¸­: Wave A à¸ˆà¸š + CHOCH M5 + à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ Wave A à¸­à¸µà¸à¸•à¹ˆà¸­à¹„à¸›
if waveBShortEntryCondition and not waveAShortEntryCondition and strategy.position_size == 0 and not inCooldownPeriod and not hasOpenPosition and lastEntryWaveType != "WaveB_Short"
    [entryPrice, stopLossPrice, fibTP1, fibTP2, fibTP3] = executeShortEntry("Short_WaveB", "WaveB", "ðŸ”´ xon Wave B Short Entry", "ðŸ”´ xon Wave B Short Entry", ewEntryPrice, currentWaveForEntry, trendFromCHOCH_1H, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibHH, fibLL, firstWaveHH, firstWaveLL, enableAlerts, sendEntrySignals, macdLine, signalLine, rsiValue, atrValue)
    entryTime := time
    entryIndex := bar_index
    exitReason := ""
    exitPercent := 0.0
    hlPrice := na
    hlIndex := na
    hlFirstCandleIndex := na
    hlFirstCandleOpen := na
    isSubWave := false
    rsiTested30 := false
    prevRSI := na
    tp1Exited := false
    m5BearishLow := na
    m15OBHigh := na
    m15OBBarIndex := na
    rejectionPartialExited := false
    justEnteredShort := true
    lastMajorWaveEntryBar := bar_index
    lastMajorWaveHL := firstWaveLL
    lastMajorWaveHH := firstWaveHH
    lastEntryWaveType := "WaveB_Short"
    majorWaveCompleted := false

// Fallback Short Entry (Priority 3)
// à¹€à¸‚à¹‰à¸²à¹„à¸”à¹‰à¸•à¹ˆà¸­à¹€à¸¡à¸·à¹ˆà¸­: à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ Wave A à¹à¸¥à¸°à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ Wave B
if fallbackShortEntryCondition and not waveAShortEntryCondition and not waveBShortEntryCondition and strategy.position_size == 0 and not inCooldownPeriod and not hasOpenPosition and lastEntryWaveType != "Fallback_Short"
    [entryPrice, stopLossPrice, fibTP1, fibTP2, fibTP3] = executeShortEntry("Short_Fallback", "Fallback", "ðŸ”´ xon Fallback Short Entry", "ðŸ”´ xon Fallback Short Entry", ewEntryPrice, currentWaveForEntry, trendFromCHOCH_1H, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibHH, fibLL, firstWaveHH, firstWaveLL, enableAlerts, sendEntrySignals, macdLine, signalLine, rsiValue, atrValue)
    fibTP3 := na
    entryTime := time
    entryIndex := bar_index
    exitReason := ""
    exitPercent := 0.0
    hlPrice := na
    hlIndex := na
    hlFirstCandleIndex := na
    hlFirstCandleOpen := na
    isSubWave := false
    rsiTested30 := false
    prevRSI := na
    tp1Exited := false
    m5BearishLow := na
    m15OBHigh := na
    m15OBBarIndex := na
    rejectionPartialExited := false
    justEnteredShort := true
    lastMajorWaveEntryBar := bar_index
    lastMajorWaveHL := firstWaveLL
    lastMajorWaveHH := firstWaveHH
    lastEntryWaveType := "Fallback_Short"
    majorWaveCompleted := false

//=============================================================================
// UPDATE DASHBOARD ENTRY SIGNAL INFO (à¸­à¸±à¸›à¹€à¸”à¸•à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ entry conditions à¸–à¸¹à¸à¸„à¸³à¸™à¸§à¸“à¹à¸¥à¹‰à¸§)
//=============================================================================
if showDashboard and not na(marketDashboard)
    updateDashboardEntrySignal(marketDashboard, waveAEntryCondition, waveBEntryCondition, majorWaveBEntryCondition, fallbackEntryCondition, waveAShortEntryCondition, waveBShortEntryCondition, fallbackShortEntryCondition, ewEntryPrice, currentWaveForEntry, ewStopLoss, ewTP1, ewTP2, ewTP3, fibRetracement618, fibRetracement382, fibLL, fibHH, fibHL, firstWaveLL, firstWaveHH, wave1Low, wave1High, currentMajorWave, isImpulseWave, wave3Extended, trendFromCHOCH_1H)

// à¸­à¸±à¸›à¹€à¸”à¸• Dashboard Signal - à¹ƒà¸Šà¹‰à¸‹à¸´à¸à¹à¸™à¸¥à¸—à¸µà¹ˆà¹€à¸›à¸´à¸”à¸­à¸¢à¸¹à¹ˆ (entry conditions à¸—à¸µà¹ˆà¹à¸—à¹‰à¸ˆà¸£à¸´à¸‡)
// à¹€à¸žà¸´à¹ˆà¸¡à¸à¸²à¸£à¹à¸ªà¸”à¸‡ % à¸—à¸µà¹ˆà¸§à¸´à¹ˆà¸‡à¸¡à¸²à¹à¸¥à¹‰à¸§ à¹à¸¥à¸° % à¸à¸³à¹„à¸£/à¸‚à¸²à¸”à¸—à¸¸à¸™ à¸žà¸£à¹‰à¸­à¸¡à¸ªà¸µà¸à¸£à¸°à¸žà¸£à¸´à¸š
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: à¸•à¹‰à¸­à¸‡à¸­à¸¢à¸¹à¹ˆà¸«à¸¥à¸±à¸‡à¸à¸²à¸£à¸›à¸£à¸°à¸à¸²à¸¨ wave entry conditions (waveAEntryCondition, waveBEntryCondition, etc.)
if showDashboard and not na(marketDashboard) and barstate.islast
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸‹à¸´à¸à¹à¸™à¸¥à¸—à¸µà¹ˆà¹€à¸›à¸´à¸”à¸­à¸¢à¸¹à¹ˆ (entry conditions à¸—à¸µà¹ˆà¹à¸—à¹‰à¸ˆà¸£à¸´à¸‡)
    // Priority: Wave A > Wave B > Major Wave B > Fallback (Long) > Short signals
    bool hasActiveSignal = waveAEntryCondition or waveBEntryCondition or majorWaveBEntryCondition or fallbackEntryCondition or waveAShortEntryCondition or waveBShortEntryCondition or fallbackShortEntryCondition or strategy.position_size != 0
    
    // à¸£à¸°à¸šà¸¸à¸›à¸£à¸°à¹€à¸ à¸—à¸‹à¸´à¸à¹à¸™à¸¥à¸—à¸µà¹ˆà¹€à¸›à¸´à¸”à¸­à¸¢à¸¹à¹ˆ
    string signalType = ""
    if strategy.position_size > 0
        signalType := "LONG"
    else if strategy.position_size < 0
        signalType := "SHORT"
    else if waveAEntryCondition
        signalType := "Wave A"
    else if waveBEntryCondition
        signalType := "Wave B"
    else if majorWaveBEntryCondition
        signalType := "Major B"
    else if fallbackEntryCondition
        signalType := "Fallback"
    else if waveAShortEntryCondition
        signalType := "Wave A Short"
    else if waveBShortEntryCondition
        signalType := "Wave B Short"
    else if fallbackShortEntryCondition
        signalType := "Fallback Short"
    
    // à¸„à¸³à¸™à¸§à¸“ % à¸—à¸µà¹ˆà¸§à¸´à¹ˆà¸‡à¸¡à¸²à¹à¸¥à¹‰à¸§ (à¸ˆà¸²à¸ entry price à¸–à¸¶à¸‡ current price)
    float priceMovePercent = na
    float profitLossPercent = na
    
    // à¸„à¸³à¸™à¸§à¸“ % à¸ˆà¸²à¸ entry price (à¸–à¹‰à¸²à¸¡à¸µ)
    if not na(entryPrice) and not na(close) and entryPrice > 0
        // % à¸—à¸µà¹ˆà¸§à¸´à¹ˆà¸‡à¸¡à¸²à¹à¸¥à¹‰à¸§ (à¸ˆà¸²à¸ entry price)
        priceMovePercent := ((close - entryPrice) / entryPrice) * 100
        
        // % à¸à¸³à¹„à¸£/à¸‚à¸²à¸”à¸—à¸¸à¸™ (à¸–à¹‰à¸²à¸¡à¸µ position)
        if strategy.position_size > 0
            // Long position: à¸à¸³à¹„à¸£à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¸‚à¸¶à¹‰à¸™
            profitLossPercent := priceMovePercent
        else if strategy.position_size < 0
            // Short position: à¸à¸³à¹„à¸£à¹€à¸¡à¸·à¹ˆà¸­à¸£à¸²à¸„à¸²à¸¥à¸‡
            profitLossPercent := -priceMovePercent
        else if hasActiveSignal
            // à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ position à¹à¸•à¹ˆà¸¡à¸µ signal = à¹à¸ªà¸”à¸‡ % à¸—à¸µà¹ˆà¸§à¸´à¹ˆà¸‡à¸¡à¸²à¹à¸¥à¹‰à¸§à¸ˆà¸²à¸ entry price
            profitLossPercent := priceMovePercent
    
    // à¸ªà¸£à¹‰à¸²à¸‡à¸ªà¸µà¸à¸£à¸°à¸žà¸£à¸´à¸š (à¹€à¸‚à¸µà¸¢à¸§-à¹à¸”à¸‡) à¹à¸šà¸šà¹€à¸£à¸µà¸¢à¸§à¸—à¸²à¸£à¹Œà¸¡ (à¸ªà¸¥à¸±à¸šà¸—à¸¸à¸ bar)
    bool isBlinkGreen = bar_index % 2 == 0  // à¸ªà¸¥à¸±à¸šà¸ªà¸µà¸—à¸¸à¸ bar (0 = à¹€à¸‚à¸µà¸¢à¸§, 1 = à¹€à¸‚à¹‰à¸¡à¸‚à¸¶à¹‰à¸™)
    color blinkColor = na
    color textColor = color.white
    
    if hasActiveSignal and not na(profitLossPercent)
        if profitLossPercent > 0
            // à¸à¸³à¹„à¸£ = à¸ªà¸µà¹€à¸‚à¸µà¸¢à¸§à¸à¸£à¸°à¸žà¸£à¸´à¸š (à¹€à¸‚à¸µà¸¢à¸§à¸ªà¸¥à¸±à¸šà¹€à¸‚à¸µà¸¢à¸§à¹€à¸‚à¹‰à¸¡)
            blinkColor := isBlinkGreen ? color.new(color.green, 0) : color.new(color.green, 20)
        else if profitLossPercent < 0
            // à¸‚à¸²à¸”à¸—à¸¸à¸™ = à¸ªà¸µà¹à¸”à¸‡à¸à¸£à¸°à¸žà¸£à¸´à¸š (à¹à¸”à¸‡à¸ªà¸¥à¸±à¸šà¹à¸”à¸‡à¹€à¸‚à¹‰à¸¡)
            blinkColor := isBlinkGreen ? color.new(color.red, 0) : color.new(color.red, 20)
        else
            // 0% = à¸ªà¸µà¹€à¸«à¸¥à¸·à¸­à¸‡
            blinkColor := isBlinkGreen ? color.new(color.yellow, 0) : color.new(color.yellow, 20)
    else if hasActiveSignal
        // à¸¡à¸µ signal à¹à¸•à¹ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ % = à¸ªà¸µà¹€à¸‚à¸µà¸¢à¸§à¸à¸£à¸°à¸žà¸£à¸´à¸š (Long) à¸«à¸£à¸·à¸­à¸ªà¸µà¹à¸”à¸‡à¸à¸£à¸°à¸žà¸£à¸´à¸š (Short)
        if strategy.position_size < 0 or waveAShortEntryCondition or waveBShortEntryCondition or fallbackShortEntryCondition
            // Short signal = à¸ªà¸µà¹à¸”à¸‡à¸à¸£à¸°à¸žà¸£à¸´à¸š
            blinkColor := isBlinkGreen ? color.new(color.red, 0) : color.new(color.red, 30)
        else
            // Long signal = à¸ªà¸µà¹€à¸‚à¸µà¸¢à¸§à¸à¸£à¸°à¸žà¸£à¸´à¸š
            blinkColor := isBlinkGreen ? color.new(color.green, 0) : color.new(color.green, 30)
    else
        // à¹„à¸¡à¹ˆà¸¡à¸µ signal = à¸ªà¸µà¹€à¸—à¸²
        blinkColor := color.new(color.gray, 60)
    
    // à¸ªà¸£à¹‰à¸²à¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹à¸ªà¸”à¸‡ signal
    string signalDisplayText = ""
    if hasActiveSignal
        // à¸£à¸°à¸šà¸¸à¸›à¸£à¸°à¹€à¸ à¸—à¸‹à¸´à¸à¹à¸™à¸¥
        string signalPrefix = ""
        if strategy.position_size > 0
            signalPrefix := signalType != "" ? signalType + " " : "LONG "
        else if strategy.position_size < 0
            signalPrefix := signalType != "" ? signalType + " " : "SHORT "
        else
            // à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ position à¹à¸•à¹ˆà¸¡à¸µ signal = à¸£à¸­à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”
            signalPrefix := signalType != "" ? signalType + " " : ""
        
        if strategy.position_size != 0
            // à¸¡à¸µ position à¹à¸¥à¹‰à¸§ = à¹à¸ªà¸”à¸‡ % P/L
            if not na(profitLossPercent)
                // à¹à¸ªà¸”à¸‡ % à¸à¸³à¹„à¸£/à¸‚à¸²à¸”à¸—à¸¸à¸™
                string profitLossText = profitLossPercent > 0 ? "+" + str.tostring(profitLossPercent, "#.##") + "%" : str.tostring(profitLossPercent, "#.##") + "%"
                signalDisplayText := signalPrefix + profitLossText
            else if not na(priceMovePercent)
                // à¹à¸ªà¸”à¸‡ % à¸—à¸µà¹ˆà¸§à¸´à¹ˆà¸‡à¸¡à¸²à¹à¸¥à¹‰à¸§
                string moveText = priceMovePercent > 0 ? "+" + str.tostring(priceMovePercent, "#.##") + "%" : str.tostring(priceMovePercent, "#.##") + "%"
                signalDisplayText := signalPrefix + moveText
            else
                signalDisplayText := signalPrefix != "" ? signalPrefix : "SIGNAL"
        else
            // à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ position à¹à¸•à¹ˆà¸¡à¸µ signal = à¹à¸ªà¸”à¸‡ "à¸£à¸­à¹€à¸‚à¹‰à¸² BUY" à¸«à¸£à¸·à¸­ "à¸£à¸­à¹€à¸‚à¹‰à¸² SELL"
            if waveAShortEntryCondition or waveBShortEntryCondition or fallbackShortEntryCondition
                signalDisplayText := "â³ à¸£à¸­à¹€à¸‚à¹‰à¸² SELL"
            else
                signalDisplayText := "â³ à¸£à¸­à¹€à¸‚à¹‰à¸² BUY"
    else
        signalDisplayText := "WAIT"
    
    // à¸­à¸±à¸›à¹€à¸”à¸• Dashboard (row 11 = Signal)
    table.cell(marketDashboard, 1, 11, signalDisplayText, bgcolor=blinkColor, text_color=textColor, text_size=size.small)

//=============================================================================
// EXIT CONDITIONS FOR SHORT
//=============================================================================
// Track lowest price for Short positions (à¸à¸¥à¸±à¸šà¸”à¹‰à¸²à¸™à¸ˆà¸²à¸ Long)
// Calculate exit conditions using function (à¹€à¸£à¸µà¸¢à¸à¸—à¸¸à¸à¸„à¸£à¸±à¹‰à¸‡à¹€à¸žà¸·à¹ˆà¸­à¸„à¸§à¸²à¸¡à¸ªà¸­à¸”à¸„à¸¥à¹‰à¸­à¸‡)
float calcShortStopLoss = na
if strategy.position_size < 0
    if justEnteredShort
        lowestPrice := close
        justEnteredShort := false
    else
        lowestPrice := math.min(lowestPrice, low)
    
    // Exit short if trend changes or TP reached
    calcShortStopLoss := na(stopLossPrice) ? lowestPrice * 1.01 : math.min(stopLossPrice, lowestPrice * 1.01)  // 1% above lowest
else
    calcShortStopLoss := na

// Calculate exit conditions using function (à¹€à¸£à¸µà¸¢à¸à¸—à¸¸à¸à¸„à¸£à¸±à¹‰à¸‡)
[exitShortCalc, tp1ReachedShortCalc, tp2ReachedShortCalc, tp3ReachedShortCalc, rejectionAtSupportCalc] = calculateShortExitConditions(calcShortStopLoss, fibTP1, fibTP2, fibTP3, isUptrend, slowSMA_30minutes, detectRejection, atSupport, bullishRejection, checkSupportResistance)

if strategy.position_size < 0
    stopLoss := calcShortStopLoss
    tp1Reached := tp1ReachedShortCalc
    tp2Reached := tp2ReachedShortCalc
    bool tp3Reached_Short = tp3ReachedShortCalc
    bool rejectionAtSupport_Short = rejectionAtSupportCalc
    exitShort := exitShortCalc
    
    if exitShort
        strategy.close("Short_WaveA", comment="Exit Short")
        strategy.close("Short_WaveB", comment="Exit Short")
        strategy.close("Short_Fallback", comment="Exit Short")
        
        if not na(entryPrice)
            exitPercent := ((entryPrice - close) / entryPrice) * 100
            exitReason := "Exit Short"
        
        entryPrice := na
        stopLossPrice := na
        fibTP1 := na
        fibTP2 := na
        fibTP3 := na

// Track highest/lowest prices for trailing stop and Fibonacci TP
// Calculate exit conditions using function (à¹€à¸£à¸µà¸¢à¸à¸—à¸¸à¸à¸„à¸£à¸±à¹‰à¸‡à¹€à¸žà¸·à¹ˆà¸­à¸„à¸§à¸²à¸¡à¸ªà¸­à¸”à¸„à¸¥à¹‰à¸­à¸‡)
float calcStopLoss = na
if strategy.position_size > 0
    if justEnteredLong
        highestPrice := close
        justEnteredLong := false
        // entryPrice à¸–à¸¹à¸à¹€à¸à¹‡à¸šà¹„à¸§à¹‰à¹à¸¥à¹‰à¸§à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Entry conditions (à¸£à¸²à¸„à¸² Fibonacci)
    else
        highestPrice := math.max(highestPrice, high)
    
    // Exit long if trend changes, trailing stop hit, or TP reached
    // à¹ƒà¸Šà¹‰ Stop Loss à¸—à¸µà¹ˆà¸•à¸±à¹‰à¸‡à¹„à¸§à¹‰à¸•à¸­à¸™à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸” à¸«à¸£à¸·à¸­ trailing stop
    calcStopLoss := na(stopLossPrice) ? highestPrice * 0.99 : math.max(stopLossPrice, highestPrice * 0.99)  // 1% below highest
else
    calcStopLoss := na

// Calculate exit conditions using function (à¹€à¸£à¸µà¸¢à¸à¸—à¸¸à¸à¸„à¸£à¸±à¹‰à¸‡)
[exitLongCalc, tp1ReachedLongCalc, tp2ReachedLongCalc, tp3ReachedLongCalc, rejectionAtResistanceCalc, priceActionExitCalc, smartExitSignalCalc, hasRejectionAtResistanceCalc, nearTargetCalc] = calculateLongExitConditions(calcStopLoss, fibTP1, fibTP2, fibTP3, entryPrice, wave1High, wave1Low, fibHH, trendFromCHOCH_5M, trendFromCHOCH_15M, detectRejection, atResistance, bearishRejection, rejectionWickRatio, isDowntrend, slowSMA_30minutes, enableMACD, macdTrendHold_1H, macdTrendHold_4H, isStrongUptrend, checkSupportResistance, hlFirstCandleOpen)

if strategy.position_size > 0
    // ========================================================================
    // à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¸¢à¸«à¸²à¸¢: à¸–à¹‰à¸²à¸«à¸¥à¸¸à¸” LL à¸‚à¸­à¸‡à¸ªà¸§à¸´à¸‡ (fibLL) à¹ƒà¸«à¹‰ exit à¸—à¸±à¸™à¸—à¸µ
    // ========================================================================
    bool brokeSwingLL = not na(fibLL) and low < fibLL
    if brokeSwingLL
        // à¸£à¸²à¸„à¸²à¸«à¸¥à¸¸à¸” LL à¸‚à¸­à¸‡à¸ªà¸§à¸´à¸‡ = à¸ªà¸±à¸à¸à¸²à¸“à¸§à¹ˆà¸²à¹€à¸—à¸£à¸™à¸”à¹Œà¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™ â†’ exit à¸—à¸±à¸™à¸—à¸µà¹€à¸žà¸·à¹ˆà¸­à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¸¢à¸«à¸²à¸¢
        exitLongCalc := true
        exitReason := "Broke Swing LL (Protection)"
        // Exit à¸—à¸±à¸™à¸—à¸µà¹€à¸¡à¸·à¹ˆà¸­à¸«à¸¥à¸¸à¸” LL
        strategy.close_all(comment="Broke Swing LL")
    
    // à¹ƒà¸Šà¹‰ Stop Loss à¸—à¸µà¹ˆà¸•à¸±à¹‰à¸‡à¹„à¸§à¹‰à¸•à¸­à¸™à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸” (fibLL) à¸«à¸£à¸·à¸­ trailing stop
    // Priority: à¹ƒà¸Šà¹‰ fibLL à¹€à¸›à¹‡à¸™ SL à¸à¹ˆà¸­à¸™ (à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¸„à¸§à¸²à¸¡à¹€à¸ªà¸µà¸¢à¸«à¸²à¸¢) à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸¡à¸µà¸„à¹ˆà¸­à¸¢à¹ƒà¸Šà¹‰ trailing stop
    stopLoss := not na(fibLL) ? math.max(fibLL, calcStopLoss) : calcStopLoss
    
    // Check TP1, TP2, à¹à¸¥à¸° TP3 (à¸•à¸²à¸¡à¸à¸Ž Elliott Wave)
    tp1Reached := tp1ReachedLongCalc
    tp2Reached := tp2ReachedLongCalc
    bool tp3Reached = tp3ReachedLongCalc
    rejectionAtResistance := rejectionAtResistanceCalc
    priceActionExit := priceActionExitCalc
    bool smartExitSignal = smartExitSignalCalc
    bool hasRejectionAtResistance = hasRejectionAtResistanceCalc
    bool nearTarget = nearTargetCalc
    
    // à¹€à¸¡à¸·à¹ˆà¸­à¸–à¸¶à¸‡ TP1, TP2, à¸«à¸£à¸·à¸­ TP3 (Wave 1 à¸ˆà¸š) à¹ƒà¸«à¹‰à¸šà¸±à¸™à¸—à¸¶à¸à¹à¸¥à¸°à¹€à¸•à¸£à¸µà¸¢à¸¡à¸ªà¸³à¸«à¸£à¸±à¸š entry à¸„à¸£à¸±à¹‰à¸‡à¸•à¹ˆà¸­à¹„à¸›
    if (tp1Reached or tp2Reached or tp3Reached) and isFirstWave == true and wave1Completed == false
        wave1Completed := true
        isFirstWave := false
        if firstWaveStored == false
            if na(firstWaveLL) and not na(fibLL) and not na(fibLLIndex)
                firstWaveLL := fibLL
                firstWaveLLIndex := fibLLIndex
                firstWaveLLTime := math.abs(bar_index - fibLLIndex) < 500 ? time[bar_index - fibLLIndex] : time
            if na(firstWaveHH) and not na(fibHH) and not na(fibHHIndex)
                firstWaveHH := fibHH
                firstWaveHHIndex := fibHHIndex
            firstWaveStored := true
    
    // ========================================================================
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹à¸™à¸§à¸•à¹‰à¸²à¸™ (Resistance) - à¹ƒà¸Šà¹‰à¸•à¸±à¸§à¹à¸›à¸£ atResistance à¸—à¸µà¹ˆà¸–à¸¹à¸à¸­à¸±à¸›à¹€à¸”à¸•à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Order Blocks
    // atResistance à¸ˆà¸°à¸–à¸¹à¸à¸­à¸±à¸›à¹€à¸”à¸•à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Order Blocks à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ ob_top, ob_btm, ob_type à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹à¸¥à¹‰à¸§
    
    // Trailing Stop - à¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µ Long position à¹à¸¥à¸°à¸¡à¸µà¸à¸³à¹„à¸£ â†’ à¹ƒà¸Šà¹‰ M15 timeframe
    // à¸à¸Ž: 
    // 1. Trailing Stop à¸ˆà¸°à¹€à¸¥à¸·à¹ˆà¸­à¸™à¸‚à¸¶à¹‰à¸™à¹„à¸›à¸—à¸¸à¸à¹à¸—à¹ˆà¸‡ M15 à¸—à¸µà¹ˆ body (à¹ƒà¸ªà¹‰à¹€à¸—à¸µà¸¢à¸™)
    // 2. à¸–à¹‰à¸²à¹€à¸ˆà¸­: à¹à¸—à¹ˆà¸‡à¹€à¸‚à¸µà¸¢à¸§à¸›à¸´à¸”à¹€à¸•à¹‡à¸¡ â†’ à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡à¸¢à¹ˆà¸­à¸•à¸±à¸§ â†’ à¹à¸—à¹ˆà¸‡à¹€à¸‚à¸µà¸¢à¸§à¸Šà¸™à¸°à¸‚à¸¶à¹‰à¸™à¹„à¸›
    //    â†’ Trailing Stop à¸¡à¸²à¸—à¸µà¹ˆ OB zone (high à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡)
    if strategy.position_size > 0 and not na(entryPrice)
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸¡à¸µà¸à¸³à¹„à¸£à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
        bool hasProfit = close > entryPrice
        
        if hasProfit
            // à¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µà¸à¸³à¹„à¸£ â†’ à¹ƒà¸Šà¹‰ M15 timeframe
            float m15Close = request.security(syminfo.tickerid, "15", close)
            float m15Open = request.security(syminfo.tickerid, "15", open)
            float m15High = request.security(syminfo.tickerid, "15", high)
            float m15Low = request.security(syminfo.tickerid, "15", low)
            float m15ClosePrev = request.security(syminfo.tickerid, "15", close[1])
            float m15OpenPrev = request.security(syminfo.tickerid, "15", open[1])
            float m15HighPrev = request.security(syminfo.tickerid, "15", high[1])
            float m15LowPrev = request.security(syminfo.tickerid, "15", low[1])
            float m15ClosePrev2 = request.security(syminfo.tickerid, "15", close[2])
            float m15OpenPrev2 = request.security(syminfo.tickerid, "15", open[2])
            float m15HighPrev2 = request.security(syminfo.tickerid, "15", high[2])
            float m15LowPrev2 = request.security(syminfo.tickerid, "15", low[2])
            
            // à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸š pattern: à¹€à¸‚à¸µà¸¢à¸§à¹€à¸•à¹‡à¸¡ â†’ à¹à¸”à¸‡à¸¢à¹ˆà¸­à¸•à¸±à¸§ â†’ à¹€à¸‚à¸µà¸¢à¸§à¸Šà¸™à¸°
            // à¹€à¸‚à¸µà¸¢à¸§à¹€à¸•à¹‡à¸¡à¹à¸—à¹ˆà¸‡: à¹à¸—à¹ˆà¸‡à¹€à¸‚à¸µà¸¢à¸§à¸—à¸µà¹ˆà¸¡à¸µ body à¹€à¸•à¹‡à¸¡ (close à¹ƒà¸à¸¥à¹‰ high, body > 70% à¸‚à¸­à¸‡ range)
            float m15BodyPrev2 = m15ClosePrev2 - m15OpenPrev2  // body à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡à¹€à¸‚à¸µà¸¢à¸§ (2 bars à¸à¹ˆà¸­à¸™)
            float m15RangePrev2 = m15HighPrev2 - m15LowPrev2  // range à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡à¹€à¸‚à¸µà¸¢à¸§ (2 bars à¸à¹ˆà¸­à¸™)
            bool m15GreenFullPrev2 = m15ClosePrev2 > m15OpenPrev2 and math.abs(m15BodyPrev2) > (m15RangePrev2 * 0.7)  // à¹€à¸‚à¸µà¸¢à¸§à¹€à¸•à¹‡à¸¡à¹à¸—à¹ˆà¸‡
            
            // à¹à¸”à¸‡à¸¢à¹ˆà¸­à¸•à¸±à¸§: à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡à¸—à¸µà¹ˆà¸¡à¸µ body à¹€à¸¥à¹‡à¸ (body < 50% à¸‚à¸­à¸‡ range)
            float m15BodyPrev = m15ClosePrev - m15OpenPrev  // body à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡ (1 bar à¸à¹ˆà¸­à¸™)
            float m15RangePrev = m15HighPrev - m15LowPrev
            bool m15RedSmallPrev = m15ClosePrev < m15OpenPrev and math.abs(m15BodyPrev) < (m15RangePrev * 0.5)  // à¹à¸”à¸‡à¸¢à¹ˆà¸­à¸•à¸±à¸§
            
            // à¹€à¸‚à¸µà¸¢à¸§à¸Šà¸™à¸°à¸‚à¸¶à¹‰à¸™à¹„à¸›: à¹à¸—à¹ˆà¸‡à¹€à¸‚à¸µà¸¢à¸§à¸—à¸µà¹ˆà¸Šà¸™à¸°à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡ (close > open à¹à¸¥à¸° close > high à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡)
            bool m15GreenWin = m15Close > m15Open and m15Close > m15HighPrev  // à¹€à¸‚à¸µà¸¢à¸§à¸Šà¸™à¸°à¸‚à¸¶à¹‰à¸™à¹„à¸›
            
            // Pattern: à¹€à¸‚à¸µà¸¢à¸§à¹€à¸•à¹‡à¸¡ â†’ à¹à¸”à¸‡à¸¢à¹ˆà¸­à¸•à¸±à¸§ â†’ à¹€à¸‚à¸µà¸¢à¸§à¸Šà¸™à¸°
            if m15GreenFullPrev2 and m15RedSmallPrev and m15GreenWin and not na(m15HighPrev) and (na(m15OBHigh) or m15HighPrev > m15OBHigh)
                m15OBHigh := m15HighPrev
                m15OBBarIndex := bar_index
            
            // Trailing Stop: à¹€à¸¥à¸·à¹ˆà¸­à¸™à¸‚à¸¶à¹‰à¸™à¹„à¸›à¸—à¸¸à¸à¹à¸—à¹ˆà¸‡ M15 à¸—à¸µà¹ˆ body (à¹ƒà¸ªà¹‰à¹€à¸—à¸µà¸¢à¸™)
            float m15BodyLow = math.min(m15Open, m15Close)
            float m15TrailingStop = (not na(m15OBHigh) and m15OBHigh > entryPrice) ? m15OBHigh : (m15BodyLow > entryPrice ? m15BodyLow : na)
            if not na(m15TrailingStop)
                stopLoss := math.max(stopLoss, m15TrailingStop)
                exitReason := (not na(m15OBHigh) and m15OBHigh > entryPrice) ? "Trailing Stop (M15 OB Zone)" : "Trailing Stop (M15 Body)"
        else
            // à¹„à¸¡à¹ˆà¸¡à¸µà¸à¸³à¹„à¸£ â†’ à¹ƒà¸Šà¹‰ M5 timeframe (à¹€à¸”à¸´à¸¡)
            float m5Close = request.security(syminfo.tickerid, "5", close)
            float m5Open = request.security(syminfo.tickerid, "5", open)
            float m5High = request.security(syminfo.tickerid, "5", high)
            float m5Low = request.security(syminfo.tickerid, "5", low)
            float m5ClosePrev = request.security(syminfo.tickerid, "5", close[1])
            float m5OpenPrev = request.security(syminfo.tickerid, "5", open[1])
            float m5LowPrev = request.security(syminfo.tickerid, "5", low[1])
            
            // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹à¸—à¹ˆà¸‡à¹à¸”à¸‡ (bearish) à¸—à¸µà¹ˆà¸ªà¸¹à¸‡à¸à¸§à¹ˆà¸²à¸£à¸²à¸„à¸²à¹€à¸‚à¹‰à¸²
            bool m5BearishPrev = m5ClosePrev < m5OpenPrev  // à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡à¸à¹ˆà¸­à¸™à¸«à¸™à¹‰à¸²
            bool m5BearishAboveEntry = m5BearishPrev and m5LowPrev > entryPrice  // à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡à¸—à¸µà¹ˆà¸ªà¸¹à¸‡à¸à¸§à¹ˆà¸²à¸£à¸²à¸„à¸²à¹€à¸‚à¹‰à¸²
            
            // à¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µà¹à¸£à¸‡à¸‹à¸·à¹‰à¸­à¸‚à¸¶à¹‰à¸™à¸•à¹ˆà¸­ (bullish) à¹ƒà¸«à¹‰à¸­à¸±à¸›à¹€à¸”à¸• low à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡à¹€à¸›à¹‡à¸™ trailing stop
            bool m5Bullish = m5Close > m5Open  // à¹à¸—à¹ˆà¸‡à¹€à¸‚à¸µà¸¢à¸§ (bullish) - à¹à¸£à¸‡à¸‹à¸·à¹‰à¸­à¸‚à¸¶à¹‰à¸™à¸•à¹ˆà¸­
            
            if m5BearishAboveEntry and m5Bullish and not na(m5LowPrev) and (na(m5BearishLow) or m5LowPrev > m5BearishLow)
                m5BearishLow := m5LowPrev
            
            // à¹ƒà¸Šà¹‰ trailing stop à¸ˆà¸²à¸ low à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡à¹à¸”à¸‡ M5
            float m5TrailingStop = not na(m5BearishLow) and m5BearishLow > entryPrice ? m5BearishLow : (nearTarget ? (not na(fibHL) ? fibHL : entryPrice) : na)
            if not na(m5TrailingStop)
                stopLoss := math.max(stopLoss, m5TrailingStop)
                exitReason := not na(m5BearishLow) and m5BearishLow > entryPrice ? "Trailing Stop (M5 Bearish Low)" : (stopLoss > entryPrice ? "Trailing Stop (Breakeven+)" : "Trailing Stop")
    
    if smartExitSignal
        exitReason := "Wave C/5 Complete + CHOCH + Inverted Hammer"
    
    // Sub-wave detection and trailing stop (simplified)
    if not na(fibHH) and high > fibHH
        subWaveDetected := true
        isSubWave := true
        if not na(hlFirstCandleOpen)
            stopLoss := math.max(stopLoss, hlFirstCandleOpen)
            exitLongCalc := exitLongCalc or (close < hlFirstCandleOpen)
            exitReason := "HL Broken"
    if close < stopLoss
        exitLongCalc := true
        exitReason := "Trailing Stop (Wave C/5 Near)"
    
    // à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¸­à¸­à¸: TP, Stop Loss, Rejection à¸—à¸µà¹ˆà¹à¸™à¸§à¸•à¹‰à¸²à¸™, à¸«à¸£à¸·à¸­à¹à¸™à¸§à¸•à¹‰à¸²à¸™, à¸«à¸£à¸·à¸­ HL Broken
    // à¹à¸•à¹ˆà¹„à¸¡à¹ˆ exit à¸–à¹‰à¸² MACD à¸ˆà¸²à¸ TF 1H à¹à¸¥à¸° 4H à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸•à¸±à¸”à¸à¸¥à¸±à¸š (MACD line à¸¢à¸±à¸‡à¸­à¸¢à¸¹à¹ˆà¹€à¸«à¸™à¸·à¸­ signal line) = à¸–à¸·à¸­à¸­à¸­à¹€à¸”à¸­à¸£à¹Œà¸•à¹ˆà¸­à¹„à¸›
    bool shouldHoldByMACD = enableMACD and macdTrendHold_1H and macdTrendHold_4H  // à¸–à¸·à¸­à¸­à¸­à¹€à¸”à¸­à¸£à¹Œà¸–à¹‰à¸² MACD à¸ˆà¸²à¸ TF 1H à¹à¸¥à¸° 4H à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸•à¸±à¸”à¸à¸¥à¸±à¸š
    
    // Exit conditions (split for readability)
    bool exitByStop = close < stopLoss and not shouldHoldByMACD
    bool exitByTrend = isDowntrend and ta.crossunder(close, slowSMA_30minutes) and not shouldHoldByMACD
    bool exitByTP = tp2Reached or tp3Reached
    // à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡: rejection à¸—à¸µà¹ˆà¹à¸™à¸§à¸•à¹‰à¸²à¸™ â†’ partial exit (à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ full exit)
    // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡ â†’ full exit (à¹€à¸”à¸´à¸¡)
    bool exitByRejection = hasRejectionAtResistance and not shouldHoldByMACD and not isStrongUptrend  // Full exit à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆà¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡
    exitLong := exitLongCalc or smartExitSignal or exitByStop or exitByTrend or exitByTP or exitByRejection
    
    // Partial exit at TP1 (50% à¸‚à¸­à¸‡ position) - à¸–à¹‰à¸²à¸–à¸¶à¸‡ TP à¹à¸¥à¸°à¸›à¸´à¸”à¸•à¹ˆà¸³à¸à¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ PA
    // à¸­à¸±à¸›à¹€à¸”à¸• tp1HitAlert à¹à¸¥à¸° tp2HitAlert à¸ªà¸³à¸«à¸£à¸±à¸š alert conditions
    tp1HitAlert := false
    tp2HitAlert := false
    
    // Partial exit logic (à¸£à¸§à¸¡ TP1 à¹à¸¥à¸° Rejection)
    bool doTP1PartialExit = tp1Reached and not tp2Reached and strategy.position_size > 0 and not tp1Exited
    bool doRejectionPartialExit = isStrongUptrend and hasRejectionAtResistance and strategy.position_size > 0 and not rejectionPartialExited and not shouldHoldByMACD
    if doTP1PartialExit or doRejectionPartialExit
        if doTP1PartialExit
            tp1HitAlert := true
            exitReason := priceActionExit ? "TP1 + PA" : "TP1"
            tp1Exited := true
        else
            rejectionPartialExited := true
            exitReason := "Rejection at Resistance (Partial)"
        if not na(entryPrice)
            exitPercent := ((close - entryPrice) / entryPrice) * 100
        strategy.close("Long_WaveA", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_WaveB", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_MajorWaveB", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_Fallback", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        // à¸›à¸´à¸” Scale-in Entry positions (50%)
        strategy.close("Long_WaveA_382", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_WaveB_382", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_Fallback_382", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_WaveA_50", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_WaveB_50", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_Fallback_50", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_WaveA_618", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_WaveB_618", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_Fallback_618", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_WaveA_786", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_WaveB_786", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        strategy.close("Long_Fallback_786", qty_percent=50, comment=exitReason + (doTP1PartialExit ? " Hit" : ""))
        if enableAlerts
            string alertMsg = doTP1PartialExit ? (priceActionExit ? "ðŸŸ¡ xon TP1 + PA Exit (50%): " : "ðŸŸ¡ xon TP1 Reached: ") : "ðŸŸ¡ xon Rejection Partial Exit (50%): "
            alert(alertMsg + syminfo.ticker + " at " + str.tostring(close), alert.freq_once_per_bar)
        if sendExitSignals
            string macdTrend = macdLine > signalLine ? "Bullish" : "Bearish"
            string exitType = doTP1PartialExit ? "TP1" : "Rejection"
            string aiData = createAIData("PARTIAL_EXIT", exitType, entryPrice, stopLossPrice, fibTP1, fibTP2, fibTP3, currentMajorWave, isImpulseWave, macdTrend, rsiValue, atrValue)
            string desc = "**Exit Price:** " + str.tostring(close, "#.##") + "\n**Profit:** " + str.tostring(exitPercent, "#.##") + "%\n" + (doTP1PartialExit ? "" : "**Reason:** Rejection at Resistance\n") + "**Closed:** 50%\n**Remaining:** 50%"
            sendDiscordAlert("ðŸŸ¡ xon " + exitType + " Partial Exit - " + syminfo.ticker, desc, "16776960", aiData)
    
    // à¸­à¸±à¸›à¹€à¸”à¸• tp2HitAlert à¹à¸¥à¸° tp3HitAlert à¸ªà¸³à¸«à¸£à¸±à¸š alert condition
    bool hasPosition = strategy.position_size > 0
    tp2HitAlert := tp2Reached and hasPosition
    bool tp3HitAlert = tp3Reached and hasPosition
    
    if exitLong
        exitPercent := not na(entryPrice) ? ((close - entryPrice) / entryPrice) * 100 : 0.0
        exitReason := tp3Reached ? "TP3" : tp2Reached ? "TP2" : tp1Reached ? "TP1" : rejectionAtResistance ? "Rejection" : atResistance ? "Resistance" : not na(entryPrice) ? "Stop/Exit" : "Exit"
        
        // à¸›à¸´à¸”à¸—à¸¸à¸ position (Multiple Entry Strategy + Scale-in Entry)
        strategy.close("Long_WaveA", comment=exitReason)
        strategy.close("Long_WaveB", comment=exitReason)
        strategy.close("Long_MajorWaveB", comment=exitReason)
        strategy.close("Long_Fallback", comment=exitReason)
        // à¸›à¸´à¸” Scale-in Entry positions
        strategy.close("Long_WaveA_382", comment=exitReason)
        strategy.close("Long_WaveB_382", comment=exitReason)
        strategy.close("Long_Fallback_382", comment=exitReason)
        strategy.close("Long_WaveA_50", comment=exitReason)
        strategy.close("Long_WaveB_50", comment=exitReason)
        strategy.close("Long_Fallback_50", comment=exitReason)
        strategy.close("Long_WaveA_618", comment=exitReason)
        strategy.close("Long_WaveB_618", comment=exitReason)
        strategy.close("Long_Fallback_618", comment=exitReason)
        strategy.close("Long_WaveA_786", comment=exitReason)
        strategy.close("Long_WaveB_786", comment=exitReason)
        strategy.close("Long_Fallback_786", comment=exitReason)
        highestPrice := na
        entryPrice := na
        entryTime := na
        entryIndex := na
        stopLossPrice := na
        tp1Exited := false
        // Reset HL tracking à¹à¸¥à¸° RSI tracking
        hlPrice := na
        hlIndex := na
        hlFirstCandleIndex := na
        hlFirstCandleOpen := na
        isSubWave := false
        rsiTested30 := false
        prevRSI := na
        
        // Reset cooldown: à¸›à¸´à¸”à¸à¸²à¸£à¹€à¸—à¸£à¸”à¹à¸¥à¹‰à¸§ = à¸ªà¸²à¸¡à¸²à¸£à¸–à¹€à¸‚à¹‰à¸²à¹ƒà¸«à¸¡à¹ˆà¹„à¸”à¹‰à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸à¸´à¸” Major Wave à¹ƒà¸«à¸¡à¹ˆ
        majorWaveCompleted := true
        
        // Reset Wave structure tracking (à¹€à¸¡à¸·à¹ˆà¸­ Major Wave à¸ˆà¸š)
        if lastEntryWaveType == "MajorWaveB_Long"
            waveAReached100Percent := false
            waveCCompleted := false
            waveAHighestPrice := na
        if enableAlerts
            alert(exitReason + " xon Exit: " + syminfo.ticker + " at " + str.tostring(close) + " (" + str.tostring(exitPercent, "#.##") + "%)", alert.freq_once_per_bar)
        if sendExitSignals
            string macdTrend = macdLine > signalLine ? "Bullish" : "Bearish"
            string aiData = createAIData("FULL_EXIT", exitReason, entryPrice, stopLossPrice, fibTP1, fibTP2, fibTP3, currentMajorWave, isImpulseWave, macdTrend, rsiValue, atrValue)
            string desc = "**Exit Price:** " + str.tostring(close, "#.##") + "\n**Profit:** " + str.tostring(exitPercent, "#.##") + "%\n**Reason:** " + exitReason + "\n**Closed:** 100%"
            sendDiscordAlert("ðŸ”´ xon Full Exit - " + syminfo.ticker, desc, exitPercent > 0 ? "3066993" : "15158332", aiData)
    else
        // Use strategy.exit for trailing stop with TP (TP3 > TP2 > TP1)
        float targetTP = enableFibonacci ? (not na(fibTP3) ? fibTP3 : not na(fibTP2) ? fibTP2 : not na(fibTP1) ? fibTP1 : na) : na
        if not na(targetTP)
            strategy.exit("Exit Long_WaveA", "Long_WaveA", stop=stopLoss, limit=targetTP, trail_price=highestPrice)
            strategy.exit("Exit Long_WaveB", "Long_WaveB", stop=stopLoss, limit=targetTP, trail_price=highestPrice)
            strategy.exit("Exit Long_Fallback", "Long_Fallback", stop=stopLoss, limit=targetTP, trail_price=highestPrice)
        else
            strategy.exit("Exit Long_WaveA", "Long_WaveA", stop=stopLoss, trail_price=highestPrice)
            strategy.exit("Exit Long_WaveB", "Long_WaveB", stop=stopLoss, trail_price=highestPrice)
            strategy.exit("Exit Long_Fallback", "Long_Fallback", stop=stopLoss, trail_price=highestPrice)

if strategy.position_size < 0
    if justEnteredShort
        lowestPrice := close
        justEnteredShort := false
        if na(entryPrice)
            entryPrice := close  // à¹€à¸à¹‡à¸šà¸£à¸²à¸„à¸²à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”
    else
        lowestPrice := math.min(lowestPrice, low)
    
    // Exit short if trend changes or trailing stop hit
    stopLoss := lowestPrice + (atrValue * 2.5)
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Rejection Candle à¸—à¸µà¹ˆà¹à¸™à¸§à¸£à¸±à¸š
    rejectionAtSupport := detectRejection and atSupport and bullishRejection
    
    // à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¸­à¸­à¸: Stop Loss, Rejection à¸—à¸µà¹ˆà¹à¸™à¸§à¸£à¸±à¸š, à¸«à¸£à¸·à¸­à¹à¸™à¸§à¸£à¸±à¸š
    exitShort := close > stopLoss or (isUptrend and ta.crossover(close, slowSMA_30minutes)) or rejectionAtSupport or (atSupport and checkSupportResistance)
    
    if exitShort
        // à¸„à¸³à¸™à¸§à¸“ % à¸—à¸µà¹ˆà¸­à¸­à¸
        if not na(entryPrice)
            exitPercent := ((entryPrice - close) / entryPrice) * 100  // à¸ªà¸³à¸«à¸£à¸±à¸š Short: profit = entry - exit
            if rejectionAtSupport
                exitReason := "Rejection"
            else if atSupport
                exitReason := "Support"
            else
                exitReason := "Stop/Exit"
        
        strategy.close("Short", comment=exitReason)
        strategy.close("Short_WaveA", comment=exitReason)
        strategy.close("Short_WaveB", comment=exitReason)
        strategy.close("Short_Fallback", comment=exitReason)
        lowestPrice := na
        entryPrice := na
        
        // Reset cooldown: à¸›à¸´à¸”à¸à¸²à¸£à¹€à¸—à¸£à¸”à¹à¸¥à¹‰à¸§ = à¸ªà¸²à¸¡à¸²à¸£à¸–à¹€à¸‚à¹‰à¸²à¹ƒà¸«à¸¡à¹ˆà¹„à¸”à¹‰à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸à¸´à¸” Major Wave à¹ƒà¸«à¸¡à¹ˆ
        majorWaveCompleted := true
        
        if enableAlerts
            alertMsg = exitReason + " EXIT SHORT: " + syminfo.ticker + " at " + str.tostring(close) + " (" + str.tostring(exitPercent, "#.##") + "%)"
            alert(alertMsg, alert.freq_once_per_bar)
    else
        // Use strategy.exit for trailing stop
        strategy.exit("Exit Short", "Short", stop=stopLoss, trail_price=lowestPrice, trail_offset=atrValue * 2.5)

// ============================================================================
// PLOTS
// ============================================================================
// à¸§à¸²à¸”à¹€à¸ªà¹‰à¸™ SMA (à¹€à¸‰à¸žà¸²à¸° SMA 7 à¹à¸¥à¸° SMA 21) - à¸ªà¸µà¸¡à¸´à¸™à¸´à¸¡à¸­à¸¥
plot(fastSMA_30minutes, color=color.new(color.gray, 30), linewidth=1, title="SMA Fast")
plot(slowSMA_30minutes, color=color.new(color.gray, 50), linewidth=1, title="SMA Slow")

// à¹à¸ªà¸”à¸‡à¸ªà¸±à¸à¸à¸²à¸“ Fibonacci Entry - Minimal (à¹„à¸¡à¹ˆà¸¡à¸µ text label)
// LONG Signals (à¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡)
// à¹à¸ªà¸”à¸‡à¸ªà¸±à¸à¸à¸²à¸“à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚ entry à¹€à¸›à¹‡à¸™ true à¹à¸¥à¸°à¹„à¸¡à¹ˆà¸¡à¸µ position à¸­à¸¢à¸¹à¹ˆ
bool showWaveASignal = waveAEntryCondition and strategy.position_size == 0
bool showWaveBSignal = waveBEntryCondition and strategy.position_size == 0
bool showMajorWaveBSignal = majorWaveBEntryCondition and strategy.position_size == 0
bool showFallbackSignal = fallbackEntryCondition and not waveAEntryCondition and not waveBEntryCondition and not majorWaveBEntryCondition and strategy.position_size == 0

// Debug signals - à¹à¸ªà¸”à¸‡à¸ªà¸±à¸à¸à¸²à¸“à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸šà¸²à¸‡à¸­à¸¢à¹ˆà¸²à¸‡à¹€à¸›à¹‡à¸™ true (à¹€à¸žà¸·à¹ˆà¸­ debug)
bool showPriceAtFib618 = priceAtFib618 and not na(fibRetracement618) and strategy.position_size == 0
bool showHasStrongConfirmation = hasStrongConfirmation and strategy.position_size == 0
bool showBasicCondition = hasLL and hasHH and priceAtFib618 and not na(fibRetracement618) and strategy.position_size == 0

plotshape(showWaveASignal, style=shape.circle, location=location.belowbar, 
         color=color.new(color.green, 0), size=size.small, title="Wave A Entry")
plotshape(showWaveBSignal, style=shape.circle, location=location.belowbar, 
         color=color.new(color.orange, 0), size=size.small, title="Wave B Entry")
plotshape(showMajorWaveBSignal, style=shape.diamond, location=location.belowbar, 
         color=color.new(color.blue, 0), size=size.normal, title="Major Wave B Entry (0.382)")
plotshape(showFallbackSignal, style=shape.triangleup, location=location.belowbar, 
         color=color.new(color.lime, 30), size=size.tiny, title="Fallback Entry")

// Debug plots - à¹à¸ªà¸”à¸‡à¸ªà¸±à¸à¸à¸²à¸“ debug (à¹à¸ªà¸”à¸‡à¹€à¸›à¹‡à¸™à¸ªà¸µà¹€à¸—à¸²à¹€à¸žà¸·à¹ˆà¸­à¹à¸¢à¸à¸ˆà¸²à¸à¸ªà¸±à¸à¸à¸²à¸“à¸ˆà¸£à¸´à¸‡)
plotshape(showPriceAtFib618 and not showWaveASignal and not showWaveBSignal and not showMajorWaveBSignal and not showFallbackSignal, 
         style=shape.xcross, location=location.belowbar, 
         color=color.new(color.gray, 50), size=size.tiny, title="Debug: Price at Fib 618")
plotshape(showBasicCondition and not showWaveASignal and not showWaveBSignal and not showMajorWaveBSignal and not showFallbackSignal, 
         style=shape.square, location=location.belowbar, 
         color=color.new(color.yellow, 70), size=size.tiny, title="Debug: Basic Condition")

// SHORT Signals (à¸”à¹‰à¸²à¸™à¸šà¸™)
// à¹à¸ªà¸”à¸‡à¸ªà¸±à¸à¸à¸²à¸“à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚ entry à¹€à¸›à¹‡à¸™ true à¹à¸¥à¸°à¹„à¸¡à¹ˆà¸¡à¸µ position à¸­à¸¢à¸¹à¹ˆ
bool showWaveAShortSignal = waveAShortEntryCondition and strategy.position_size == 0
bool showWaveBShortSignal = waveBShortEntryCondition and strategy.position_size == 0
bool showFallbackShortSignal = fallbackShortEntryCondition and not waveAShortEntryCondition and not waveBShortEntryCondition and strategy.position_size == 0

plotshape(showWaveAShortSignal, style=shape.circle, location=location.abovebar, 
         color=color.new(color.red, 0), size=size.small, title="Wave A Short")
plotshape(showWaveBShortSignal, style=shape.circle, location=location.abovebar, 
         color=color.new(color.purple, 0), size=size.small, title="Wave B Short")
plotshape(showFallbackShortSignal, style=shape.triangledown, location=location.abovebar, 
         color=color.new(color.maroon, 30), size=size.tiny, title="Fallback Short")

// à¹à¸ªà¸”à¸‡ Rejection Candles - à¸¡à¸´à¸™à¸´à¸¡à¸­à¸¥
plotshape(bearishRejection and strategy.position_size > 0, style=shape.xcross, location=location.abovebar, 
         color=color.new(color.gray, 50), size=size.tiny, title="Bearish Rejection (Exit Signal)")
plotshape(bullishRejection and strategy.position_size < 0, style=shape.xcross, location=location.belowbar, 
         color=color.new(color.gray, 50), size=size.tiny, title="Bullish Rejection (Exit Signal)")

// ============================================================================
// MACD PLOTS (à¸›à¸´à¸”à¸à¸²à¸£à¹à¸ªà¸”à¸‡à¸ªà¸±à¸à¸à¸²à¸“ - à¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¹€à¸—à¸£à¸”à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™)
// ============================================================================
// MACD à¹„à¸¡à¹ˆà¸•à¹‰à¸­à¸‡à¹à¸ªà¸”à¸‡à¸ªà¸±à¸à¸à¸²à¸“ (plot) - à¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¹€à¸—à¸£à¸”à¸•à¸²à¸¡à¹€à¸—à¸£à¸™à¸„à¸§à¸²à¸¡à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™
// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚: MACD line à¸•à¸±à¸”à¸‚à¸¶à¹‰à¸™à¹€à¸«à¸™à¸·à¸­ signal line à¹à¸¥à¸° MACD > 0 = à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¸—à¸µà¹ˆà¹à¸‚à¹‡à¸‡à¹à¸£à¸‡
// à¸ªà¸–à¸²à¸™à¸° MACD à¸ˆà¸°à¹à¸ªà¸”à¸‡à¹ƒà¸™ Dashboard à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™ (à¹ƒà¸«à¹‰à¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¹€à¸«à¹‡à¸™à¸§à¹ˆà¸² MACD à¸ªà¹ˆà¸‡à¸ªà¸±à¸à¸à¸²à¸“à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ)
// à¸«à¸²à¸à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸”à¸¹ MACD line à¹à¸¥à¸° histogram à¸šà¸™ subplot à¹à¸¢à¸ à¸„à¸§à¸£à¹ƒà¸Šà¹‰ Built-in MACD indicator à¸‚à¸­à¸‡ TradingView
// plotshape(showMACD and enableMACD and macdBullishCross, style=shape.triangleup, location=location.belowbar, 
//          color=color.new(color.green, 50), size=size.tiny, title="MACD Bullish Cross")
// plotshape(showMACD and enableMACD and macdBearishCross, style=shape.triangledown, location=location.abovebar, 
//          color=color.new(color.red, 50), size=size.tiny, title="MACD Bearish Cross")

// ============================================================================
// DIVERGENCE VISUAL PLOTS (à¸›à¸´à¸”à¸à¸²à¸£à¹à¸ªà¸”à¸‡à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸” - à¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¹€à¸—à¸£à¸”à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™)
// ============================================================================
// Divergence à¹„à¸¡à¹ˆà¹à¸ªà¸”à¸‡à¸šà¸™à¸à¸£à¸²à¸Ÿ - à¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¸à¸²à¸£à¹€à¸—à¸£à¸”à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™
// à¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µ LL à¹à¸£à¸ à¹à¸¥à¹‰à¸§à¸à¸£à¸²à¸Ÿà¹€à¸”à¹‰à¸‡à¸‚à¸¶à¹‰à¸™à¹„à¸› à¹à¸¥à¸°à¸ªà¸£à¹‰à¸²à¸‡ LL à¹ƒà¸«à¸¡à¹ˆ = divergence à¹€à¸à¸´à¸” = à¹à¸£à¸‡ divergence à¹€à¸‚à¹‰à¸² â†’ à¸—à¸³à¹ƒà¸«à¹‰à¹€à¸‚à¹‰à¸²à¹€à¸—à¸£à¸”à¹„à¸”à¹‰
// Positive Regular Divergence: LL à¹à¸£à¸ â†’ à¸£à¸²à¸„à¸²à¹€à¸”à¹‰à¸‡à¸‚à¸¶à¹‰à¸™ â†’ à¸ªà¸£à¹‰à¸²à¸‡ LL à¹ƒà¸«à¸¡à¹ˆ (à¹à¸•à¹ˆ indicator à¸ªà¸¹à¸‡à¸à¸§à¹ˆà¸² LL à¹à¸£à¸)
// Negative Regular Divergence: HH à¹à¸£à¸ â†’ à¸£à¸²à¸„à¸²à¹€à¸”à¹‰à¸‡à¸¥à¸‡ â†’ à¸ªà¸£à¹‰à¸²à¸‡ HH à¹ƒà¸«à¸¡à¹ˆ (à¹à¸•à¹ˆ indicator à¸•à¹ˆà¸³à¸à¸§à¹ˆà¸² HH à¹à¸£à¸)
// Divergence detection à¸¢à¸±à¸‡à¸—à¸³à¸‡à¸²à¸™à¸­à¸¢à¸¹à¹ˆ à¹à¸•à¹ˆà¹„à¸¡à¹ˆà¹à¸ªà¸”à¸‡à¸šà¸™à¸à¸£à¸²à¸Ÿ - à¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚à¹ƒà¸™ entry conditions à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™

// ============================================================================
// ALERT CONDITIONS (à¸ªà¸³à¸«à¸£à¸±à¸š Backtest à¹à¸¥à¸° Real Trading)
// ============================================================================
// Alert à¸ªà¸³à¸«à¸£à¸±à¸š LONG Entry Signals
alertcondition(waveAEntryCondition, title="Wave A Long Entry Signal", 
              message="ðŸŸ¢ WAVE A BUY: {{ticker}} at {{close}} - Wave 1 Entry at Fib 0.618")

alertcondition(waveBEntryCondition, title="Wave B Long Entry Signal", 
              message="ðŸŸ¢ WAVE Bâ†’C BUY: {{ticker}} at {{close}} - Wave B to C Entry at Fib 0.618")

alertcondition(fallbackEntryCondition, title="xon Fallback Long Entry", 
              message="ðŸŸ¢ xon Fallback Entry: {{ticker}} at {{close}} - Fibonacci Entry")

// Alert à¸ªà¸³à¸«à¸£à¸±à¸š SHORT Entry Signals
alertcondition(waveAShortEntryCondition, title="xon Wave A Short Entry", 
              message="ðŸ”´ xon Wave A Short Entry: {{ticker}} at {{close}} - Wave 1 Short at Fib 0.618")

alertcondition(waveBShortEntryCondition, title="xon Wave B Short Entry", 
              message="ðŸ”´ xon Wave Bâ†’C Short Entry: {{ticker}} at {{close}} - Wave B to C Short at Fib 0.618")

alertcondition(fallbackShortEntryCondition, title="xon Fallback Short Entry", 
              message="ðŸ”´ xon Fallback Short Entry: {{ticker}} at {{close}} - Fibonacci Short")

// Alert à¸ªà¸³à¸«à¸£à¸±à¸š Exit Signals
alertcondition(exitLong, title="xon Long Exit Signal", 
              message="ðŸ”´ xon Exit: {{ticker}} at {{close}} - Reason: {{strategy.order.comment}}")

// Alert à¸ªà¸³à¸«à¸£à¸±à¸š TP Hits
// tp1HitAlert à¹à¸¥à¸° tp2HitAlert à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹„à¸§à¹‰à¹à¸¥à¹‰à¸§à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Strategy Variables (à¸à¹ˆà¸­à¸™à¸«à¸™à¹‰à¸²à¸™à¸µà¹‰)
// à¸ˆà¸°à¸–à¸¹à¸à¸­à¸±à¸›à¹€à¸”à¸•à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Exit Rules (à¸šà¸£à¸£à¸—à¸±à¸” 1326-1359)

alertcondition(tp1HitAlert, title="xon TP1 Reached", 
              message="ðŸŸ¡ xon TP1 Reached: {{ticker}} at {{close}} - Partial Exit 50%")
alertcondition(tp2HitAlert, title="xon TP2 Reached", 
              message="ðŸŸ¢ xon TP2 Reached: {{ticker}} at {{close}} - Full Exit")


//Option to show Liquidity lines on the chart
show_previous_day_high_low= input(true,"Show Previous day High and Low",inline='Show prev day levels', group = 'Configuration')


var gStartOffset = 0
var gEndOffset  = 25

color_text_prev_high_low = input.color(color.rgb(19, 133, 133, 13), 'Color of previous day high and low'
  , group = 'Configuration')

english_language_selected = input(true, 'Show Labels in English'
  , group = 'Configuration')

show_internal_struc = input(false, 'Show Internal Structure'
  , group = 'Configuration')  // à¸›à¸´à¸”à¹€à¸žà¸·à¹ˆà¸­à¹à¸ªà¸”à¸‡à¹€à¸‰à¸žà¸²à¸°à¹‚à¸„à¸£à¸‡à¸ªà¸£à¹‰à¸²à¸‡à¹ƒà¸«à¸à¹ˆ

show_demand_supply_zones = input(true, 'Show Demand and Supply Zones'
  , group = 'Configuration')

color_demand_zone = input.color(color.new(#84ea9a, 44), 'Color of demand_zone and choch lines'
  , group = 'Configuration')

color_supply_zone = input.color(color.new(#e85252, 57), 'Color of supply_zone and choch lines'
  , group = 'Configuration')



//BEGIN ENGULFING candles
showEngulfing   = input(true, 'Mark Engulfing candles with arrows')

openBarPrevious = open[1]
closeBarPrevious = close[1]
openBarCurrent = open
closeBarCurrent = close


//If current bar open is less than equal to the previous bar close AND current bar open is less than previous bar open AND current bar close is greater than previous bar open THEN True
bullishEngulfing = (openBarCurrent <= closeBarPrevious) and (openBarCurrent < openBarPrevious) and (closeBarCurrent > openBarPrevious)
//If current bar open is greater than equal to previous bar close AND current bar open is greater than previous bar open AND current bar close is less than previous bar open THEN True
bearishEngulfing = (openBarCurrent >= closeBarPrevious) and (openBarCurrent > openBarPrevious) and (closeBarCurrent < openBarPrevious)
bullishEngColor = color.new(#4caf50, 0)
bearishEngcolor = color.new(#f23645, 0)

//bullishEngulfing/bearishEngulfing return a value of 1 or 0, if 1 then plot on chart, if 0 then don't plot

// à¸­à¸±à¸›à¹€à¸”à¸• hasEngulfingOB à¸ªà¸³à¸«à¸£à¸±à¸š Fibonacci Trading System
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: ob_btm à¹à¸¥à¸° ob_top à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¸—à¸µà¹ˆà¸šà¸£à¸£à¸—à¸±à¸” 1542-1543 à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Order Blocks Arrays
// à¸à¸²à¸£à¸­à¸±à¸›à¹€à¸”à¸•à¸ˆà¸°à¸—à¸³à¹ƒà¸™à¸ªà¹ˆà¸§à¸™ Order Blocks à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ ob_btm à¹à¸¥à¸° ob_top à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹à¸¥à¹‰à¸§

alertcondition(bullishEngulfing, title = "Bullish Engulfing", message = "[CurrencyPair] [TimeFrame], Bullish candle engulfing previous candle")
alertcondition(bearishEngulfing, title = "Bearish Engulfing", message = "[CurrencyPair] [TimeFrame], Bearish candle engulfing previous candle")

//END ENGULFING candles

// BEGIN EHPDA (disabled to reduce scope count, re-enable by removing this block comment)
//BEGIN EHPDA
//------------------------------------------------------------------------------
//Settings
//-----------------------------------------------------------------------------{
//show      = 'NDOG'  // Fixed value set to 'NDOG' (Daily timeframe) 
//
//showEh    = input(false, 'Show EHPDA: averages between New Week and New Day opening gaps')
//showLast  = input.int(10, 'Amount', minval = 1)
//ehpdaCss  = input(#25bcc7, 'Color of EHPDA')
//ogCssBull = #5b9cf600
//ogCssBear = #ba68c800
//ogCssBull = input.color(#5b9cf600, 'Bullish Gap Color', inline = 'ogcolor', group = 'Style')
//ogCssBear = input.color(#ba68c800, 'Bearish Gap Color', inline = 'ogcolor', group = 'Style')
//ehpdaCss  = input(#25bcc7, 'Color of EHPDA', inline = 'ehpda', group = 'Style')
//ehpdaLbl  = true
//
//-----------------------------------------------------------------------------}
//User Defined Types (UDTs)
//-----------------------------------------------------------------------------{
//type ogaps
//    float[] top
//    float[] btm
//    float[] avg
//    int[]   loc
//    int[]   sorted
//    line[]  avglines
//
//type ehpda_display
//    line  lvl
//    label lbl
//
//-----------------------------------------------------------------------------}
//Functions
//-----------------------------------------------------------------------------{
//t = time
//
//method set_avg_line(ogaps id, avg, css)=>
//    id.avglines.unshift(
//      line.new(t, avg, t + 1, avg, color = css, extend = extend.right, style = line.style_dotted, xloc = xloc.bar_time))
//
//method pop(ogaps id)=>
//    if id.avglines.size() > showLast
//        id.top.pop(), id.btm.pop(), id.loc.pop(), id.avg.pop()
//        id.avglines.pop().delete()
//
//method set_ehpda(ogaps id, arrayeh)=>
//    for i = 0 to id.avglines.size() - 2
//        getbtm = id.top.get(id.sorted.get(i))
//        gettop = id.btm.get(id.sorted.get(i + 1))
//        avg = math.avg(getbtm, gettop)
//
//        get_eh = arrayeh.get(i)
//        get_eh.lvl.set_xy1(id.loc.get(id.sorted.get(i)), avg)
//        get_eh.lvl.set_xy2(t, avg)
//        
//        if ehpdaLbl
//            get_eh.lbl.set_xy(t, avg)
//
//method tolast(array<ehpda_display> id)=>
//    for element in id
//        element.lvl.set_x2(t)
//        element.lbl.set_x(t)
//
//-----------------------------------------------------------------------------}
//Global Elements
//-----------------------------------------------------------------------------{
//var ogaps_ = ogaps.new(array.new_float(0)
//  , array.new_float(0)
//  , array.new_float(0)
//  , array.new_int(0)
//  , array.new_int(0)
//  , array.new_line(0))
//
//var ehpda = array.new<ehpda_display>(0)
//
//var tf = show == 'NWOG' ? 'W' : 'D'
//dtf = timeframe.change(tf)
//
//if barstate.isfirst
//    for i = 0 to showLast - 1
//        ehpda.push(ehpda_display.new(
//          line.new(na, na, na, na, color = ehpdaCss, style = line.style_dashed, xloc = xloc.bar_time),
//          label.new(na, na, str.format('EHPDA', tf), color = color(na), style = label.style_label_left, textcolor = ehpdaCss, size = size.small, xloc = xloc.bar_time)
//          ))
//
//-----------------------------------------------------------------------------}
//Detects opening gaps and set lines
//-----------------------------------------------------------------------------{
//if dtf
//    max = math.max(close[1], open)
//    min = math.min(close[1], open)
//    avg = math.avg(max, min)
//
//    ogaps_.top.unshift(max)
//    ogaps_.btm.unshift(min)
//    ogaps_.avg.unshift(avg)
//    ogaps_.loc.unshift(t)
//    
//    // Only keep the logic for dashed average line without boxes or colored lines
//    css = open > close[1] ? ogCssBull : ogCssBear
//    ogaps_.set_avg_line(avg, css)
//
//    ogaps_.pop()
//
//    ogaps_.sorted := ogaps_.avg.sort_indices()
//
//-----------------------------------------------------------------------------}
//Set event horizons
//-----------------------------------------------------------------------------{
//if showEh
//    if dtf and ogaps_.avglines.size() > 2
//        ogaps_.set_ehpda(ehpda)
//    else
//        ehpda.tolast()
//
//END EHPDA 


//LIQUIDITY FUNCTIONALITY
 
detectionGroup = 'Liquidity Detection'
detectionLength = 7
margin = 10 / 6.9
 
enableBuySide = false
buySideMargin = 2.3
buySideColor = color.new(#4caf50, 0)
 
enableSellSide = false
sellSideMargin = 2.3
sellSideColor = color.new(#0e98b7, 0)
 
enableLiquidityVoids = false
bullishVoidColor = color.new(#4caf50, 0)
bearishVoidColor = color.new(#f23645, 0)
enableLabel = false
 
mode_liquidity = 'Present'
visibleLevels = 3
enableLines = true
enableBoxes = false
 
//-----------------------------------------------------------------------------}
//General Calculations
//-----------------------------------------------------------------------------{
maxSize = 50
averageTrueRange = ta.atr(10)
atr200 = ta.atr(200)
isPresent = mode_liquidity == 'Present' ? last_bar_index - bar_index <= 500 : true
 
//-----------------------------------------------------------------------------}
//User Defined Types
//-----------------------------------------------------------------------------{
type CustomZZ 
    int[] directions
    int[] indices 
    float[] prices 
 
type CustomBar
    float open = open
    float high = high
    float low = low
    float close = close
    int index = bar_index
 
type LiquidityObject
    box levelBox
    box zoneBox
    box labelBox
    bool isZoneBroken
    bool isLevelBroken
    line levelLine
    line extendedLine
 
//-----------------------------------------------------------------------------}
//Variables
//-----------------------------------------------------------------------------{
var CustomZZ zigZag = CustomZZ.new(
 array.new<int>(maxSize, 0), 
 array.new<int>(maxSize, 0), 
 array.new<float>(maxSize, na)
 )
 
CustomBar barData = CustomBar.new()
 
var LiquidityObject[] buySideLiquidity = array.new<LiquidityObject>(1, LiquidityObject.new(box(na), box(na), box(na), false, false, line(na), line(na)))
var LiquidityObject[] sellSideLiquidity = array.new<LiquidityObject>(1, LiquidityObject.new(box(na), box(na), box(na), false, false, line(na), line(na)))
 
var voidBoxes = array.new_box()
 
var int zigzagDirection = na
var int pivotIndex1 = na
var float pivotPrice1 = na
var int pivotIndex2 = na
var float pivotPrice2 = na
 
//-----------------------------------------------------------------------------}
//Functions/methods
//-----------------------------------------------------------------------------{
method updateZigZag(CustomZZ zigZag, int dir, int index, float price) =>
    zigZag.directions.unshift(dir), zigZag.indices.unshift(index), zigZag.prices.unshift(price), zigZag.directions.pop(), zigZag.indices.pop(), zigZag.prices.pop()
 
max_bars_back(time, 1000)
 
//-----------------------------------------------------------------------------}
//Calculations
//-----------------------------------------------------------------------------{
pivotIndex2 := barData.index - 1
pivotHigh = ta.pivothigh(detectionLength, 1)
pivotLow = ta.pivotlow(detectionLength, 1)
 
if not na(pivotHigh)   
    zigzagDirection := zigZag.directions.get(0) 
    pivotIndex1 := zigZag.indices.get(0) 
    pivotPrice1 := zigZag.prices.get(0) 
    pivotPrice2 := nz(barData.high[1])
 
    if zigzagDirection < 1
        updateZigZag(zigZag, 1, pivotIndex2, pivotPrice2)
    else if zigzagDirection == 1 and pivotHigh > pivotPrice1 
        zigZag.indices.set(0, pivotIndex2), zigZag.prices.set(0, pivotPrice2)
    
    if isPresent
        count = 0
        startPrice = 0.
        startIndex = 0
        minPrice = 0.
        maxPrice = 10e6
 
        for i = 0 to maxSize - 1
            if zigZag.directions.get(i) == 1 
                if zigZag.prices.get(i) > pivotHigh + (averageTrueRange / margin)
                    break
                else if zigZag.prices.get(i) > pivotHigh - (averageTrueRange / margin) and zigZag.prices.get(i) < pivotHigh + (averageTrueRange / margin)
                    count += 1
                    startIndex := zigZag.indices.get(i)
                    startPrice := zigZag.prices.get(i)
                    if zigZag.prices.get(i) > minPrice
                        minPrice := zigZag.prices.get(i)
                    if zigZag.prices.get(i) < maxPrice 
                        maxPrice := zigZag.prices.get(i)
 
        if count > 2
            getBuySide = buySideLiquidity.get(0)
 
            if startIndex == getBuySide.levelBox.get_left()
                getBuySide.levelBox.set_top(math.avg(minPrice, maxPrice) + (averageTrueRange / margin))
                getBuySide.levelBox.set_rightbottom(barData.index + 10, math.avg(minPrice, maxPrice) - (averageTrueRange / margin))
            else
                buySideLiquidity.unshift(LiquidityObject.new(box.new(startIndex, math.avg(minPrice, maxPrice) + (averageTrueRange / margin), barData.index + 10, math.avg(minPrice, maxPrice) - (averageTrueRange / margin), bgcolor=color(na), border_color=color(na)), box.new(na, na, na, na, bgcolor=color(na), border_color=color(na)),box.new(startIndex, startPrice, barData.index + 10, startPrice, text='Liquidity zone', text_size=size.tiny, text_halign=text.align_left, text_valign=text.align_bottom, text_color=color.new(buySideColor, 25), bgcolor=color(na), border_color=color(na)),false, false,line.new(startIndex, startPrice, barData.index - 1, startPrice, color=color.new(buySideColor, 0)),line.new(barData.index - 1, startPrice, na, startPrice, color=color.new(buySideColor, 0), style=line.style_dotted)))
 
                //alert('buyside liquidity level detected/updated for ' + syminfo.ticker)
 
            if buySideLiquidity.size() > visibleLevels
                getLast = buySideLiquidity.pop()
                getLast.levelBox.delete()
                getLast.zoneBox.delete()
                getLast.labelBox.delete()
                getLast.levelLine.delete()
                getLast.extendedLine.delete()               
 
if not na(pivotLow)
    zigzagDirection := zigZag.directions.get(0) 
    pivotIndex1 := zigZag.indices.get(0) 
    pivotPrice1 := zigZag.prices.get(0) 
    pivotPrice2 := nz(barData.low[1])
    
    if zigzagDirection > -1
        updateZigZag(zigZag, -1, pivotIndex2, pivotPrice2)
    else if zigzagDirection == -1 and pivotLow < pivotPrice1 
        zigZag.indices.set(0, pivotIndex2), zigZag.prices.set(0, pivotPrice2)
    
    if isPresent
        count = 0
        startPrice = 0.
        startIndex = 0
        minPrice = 0.
        maxPrice = 10e6
 
        for i = 0 to maxSize - 1
            if zigZag.directions.get(i) == -1 
                if zigZag.prices.get(i) < pivotLow - (averageTrueRange / margin)
                    break
                else if zigZag.prices.get(i) > pivotLow - (averageTrueRange / margin) and zigZag.prices.get(i) < pivotLow + (averageTrueRange / margin)
                    count += 1
                    startIndex := zigZag.indices.get(i)
                    startPrice := zigZag.prices.get(i)
                    if zigZag.prices.get(i) > minPrice
                        minPrice := zigZag.prices.get(i)
                    if zigZag.prices.get(i) < maxPrice 
                        maxPrice := zigZag.prices.get(i)
 
        if count > 2
            getSellSide = sellSideLiquidity.get(0)
 
            if startIndex == getSellSide.levelBox.get_left()
                getSellSide.levelBox.set_top(math.avg(minPrice, maxPrice) + (averageTrueRange / margin))
                getSellSide.levelBox.set_rightbottom(barData.index + 10, math.avg(minPrice, maxPrice) - (averageTrueRange / margin))
            else
                sellSideLiquidity.unshift(LiquidityObject.new(box.new(startIndex, math.avg(minPrice, maxPrice) + (averageTrueRange / margin), barData.index + 10, math.avg(minPrice, maxPrice) - (averageTrueRange / margin), bgcolor=color(na), border_color=color(na)),box.new(na, na, na, na, bgcolor=color(na), border_color=color(na)),box.new(startIndex, startPrice, barData.index + 10, startPrice, text='Liquidity zone', text_size=size.tiny, text_halign=text.align_left, text_valign=text.align_top, text_color=color.new(sellSideColor, 25), bgcolor=color(na), border_color=color(na)),false,false,line.new(startIndex, startPrice, barData.index - 1, startPrice, color=color.new(sellSideColor, 0)),line.new(barData.index - 1, startPrice, na, startPrice, color=color.new(sellSideColor, 0), style=line.style_dotted)))  
 
                alert('sellside liquidity level detected/updated for ' + syminfo.ticker)
 
            if sellSideLiquidity.size() > visibleLevels
                getLast = sellSideLiquidity.pop()
                getLast.levelBox.delete()
                getLast.zoneBox.delete()
                getLast.labelBox.delete()
                getLast.levelLine.delete()            
                getLast.extendedLine.delete()               
 
for i = 0 to buySideLiquidity.size() - 1
    liqItem = buySideLiquidity.get(i)
    
    if not liqItem.isLevelBroken
        liqItem.extendedLine.set_x2(barData.index)
 
        if barData.high > line.get_y1(liqItem.levelLine)
            liqItem.isLevelBroken := true
            liqItem.isZoneBroken := true
            //alert('buyside liquidity level breached for ' + syminfo.ticker)
            //alert('Price crossed buyside liquidity level')
 
    else if liqItem.isZoneBroken
        if barData.low > line.get_y1(liqItem.levelLine) - buySideMargin * averageTrueRange and barData.high < line.get_y1(liqItem.levelLine) + buySideMargin * averageTrueRange
            liqItem.extendedLine.set_x2(barData.index + 1)
        else
            liqItem.isZoneBroken := false
 
for i = 0 to sellSideLiquidity.size() - 1
    liqItem = sellSideLiquidity.get(i)
 
    if not liqItem.isLevelBroken
        liqItem.extendedLine.set_x2(barData.index)
 
        if barData.low < line.get_y1(liqItem.levelLine)
            liqItem.isLevelBroken := true
            liqItem.isZoneBroken := true
            //alert('sellside liquidity level breached for ' + syminfo.ticker)
            alert('Price crossed sellside liquidity level')
 
    else if liqItem.isZoneBroken
        if barData.low > line.get_y1(liqItem.levelLine) - sellSideMargin * averageTrueRange and barData.high < line.get_y1(liqItem.levelLine) + sellSideMargin * averageTrueRange
            liqItem.extendedLine.set_x2(barData.index + 1)
        else
            liqItem.isZoneBroken := false
 
if enableLiquidityVoids and isPresent
    isBullish = barData.low - barData.high[2] > atr200 and barData.low > barData.high[2] and barData.close[1] > barData.high[2]
    isBearish = barData.low[2] - barData.high > atr200 and barData.high < barData.low[2] and barData.close[1] < barData.low[2]
 
    if isBullish 
        levels = 13
        if isBullish[1] 
            step = math.abs(barData.low - barData.low[1]) / levels
            for i = 0 to levels - 1
                array.push(voidBoxes, box.new(barData.index - 2, barData.low[1] + i * step, barData.index, barData.low[1] + (i + 1) * step, border_color=na, bgcolor=color.new(bullishVoidColor, 90)))
        else   
            step = math.abs(barData.low - barData.high[2]) / levels
            for i = 0 to levels - 1
                if enableLabel and i == 0
                    array.push(voidBoxes, box.new(barData.index - 2, barData.high[2] + i * step, barData.index, barData.high[2] + (i + 1) * step, text='Liquidity Void   ', text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_bottom, text_color=na, border_color=na, bgcolor=color.new(bullishVoidColor, 90)))
                else
                    array.push(voidBoxes, box.new(barData.index - 2, barData.high[2] + i * step, barData.index, barData.high[2] + (i + 1) * step, border_color=na, bgcolor=color.new(bullishVoidColor, 90)))
 
    if isBearish
        levels = 13
        if isBearish[1]
            step = math.abs(barData.high[1] - barData.high) / levels
            for i = 0 to levels - 1
                array.push(voidBoxes, box.new(barData.index - 2, barData.high + i * step, barData.index, barData.high + (i + 1) * step, border_color=na, bgcolor=color.new(bearishVoidColor, 90)))
        else
            step = math.abs(barData.low[2] - barData.high) / levels
            for i = 0 to levels - 1
                if enableLabel and i == levels - 1
                    array.push(voidBoxes, box.new(barData.index - 2, barData.high + i * step, barData.index, barData.high + (i + 1) * step, text='Liquidity Void   ', text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_top, text_color=na, border_color=na, bgcolor=color.new(bearishVoidColor, 90)))
                else
                    array.push(voidBoxes, box.new(barData.index - 2, barData.high + i * step, barData.index, barData.high + (i + 1) * step, border_color=na, bgcolor=color.new(bearishVoidColor, 90)))
 
if voidBoxes.size() > 0
    qt = voidBoxes.size()
    for bn = qt - 1 to 0
        if bn < voidBoxes.size()
            currentBox = voidBoxes.get(bn)
            averagePrice = math.avg(currentBox.get_bottom(), currentBox.get_top())
 
            if math.sign(barData.close[1] - averagePrice) != math.sign(barData.close - averagePrice) or math.sign(barData.close[1] - averagePrice) != math.sign(barData.low - averagePrice) or math.sign(barData.close[1] - averagePrice) != math.sign(barData.high - averagePrice)
                voidBoxes.remove(bn)
            else
                currentBox.set_right(barData.index + 1)
 
                if barData.index - currentBox.get_left() > 21
                    currentBox.set_text_color(color.new(color.gray, 25))
 
 
 
//END LIQUIDITY FUNCTIONALITY
//Set Labels text according language selected (English or Portuguese)
demand_lbl_txt = ""
if (english_language_selected == false)
    demand_lbl_txt := "Zona de Compra"
else
    demand_lbl_txt := "Demand/Buy Zone"    

supply_lbl_txt = ""
if (english_language_selected == false)
    supply_lbl_txt := "Zona de Venda"
else
    supply_lbl_txt := "Supply/Sell Zone"

strong_high_lbl = ""
if (english_language_selected == false)
    strong_high_lbl := "Alto Forte"
else
    strong_high_lbl := "Strong High"

strong_low_lbl = ""
if (english_language_selected == false)
    strong_low_lbl := "Baixo Forte"
else
    strong_low_lbl := "Strong Low"


weak_low_lbl = ""
if (english_language_selected == false)
    weak_low_lbl := "Baixo Fraco"
else
    weak_low_lbl := "Weak Low"

weak_high_lbl = ""
if (english_language_selected == false)
    weak_high_lbl := "Alto Fraco"
else
    weak_high_lbl := "Weak High"

previous_day_high_lbl = ""
if (english_language_selected == false)
    previous_day_high_lbl := "PreÃ§o MÃ¡ximo do dia Anterior"
else
    previous_day_high_lbl := "Previous Day Highest Price"

previous_day_low_lbl = ""
if (english_language_selected == false)
    previous_day_low_lbl := "PreÃ§o Minimo do dia Anterior"
else
    previous_day_low_lbl := "Previous Day Lowest Price"

//       Functions 
f_drawLine(_y, _c, _w=1) => line.new(bar_index, _y, bar_index, _y, color=_c, width=_w)



f_updateStickyLevels(_levels) =>
    for _line in _levels
        line.set_x1(_line, bar_index + gStartOffset)
        line.set_x2(_line, bar_index + gEndOffset)

f_moveLevel(_from, _to, _level, _index) =>
    array.push(_to, _level)
    array.remove(_from, _index)




f_clearLevels(_levels) =>
    while array.size(_levels) > 0
        for [_index, _line] in _levels
            line.delete(array.remove(_levels, _index))

f_isHigherTimeframe(_timeframe) => timeframe.in_seconds() <= timeframe.in_seconds(_timeframe)



color TRANSP_COLOR = #ffffff00

//Tooltips
string TOOLTIP          = 'Allows to display historical Structure'
string STYLE        = 'color theme'
string COLOR_CANDLES = 'Display additional candles'


mode = 'Historical'
style = 'Colored'
show_trend = false


//Internal Structure
show_internals = show_internal_struc
show_ibull =  'All'
swing_ibull_css = color_demand_zone


//Bear Structure
show_ibear = 'All'
swing_ibear_css = color_supply_zone
ifilter_confluence = false


//Swing Structure
show_Structure = true

//Bull Structure
show_bull = 'All'
swing_bull_css = color_demand_zone

//Bear Structure
show_bear = 'All'
swing_bear_css =  color_supply_zone

//Swings
show_swings = true
length = 50
show_hl_swings = true


//Order Blocks Variables

show_iob = false
iob_showlast = 5
show_ob = true
ob_showlast = 5
ob_filter = 'Atr'
ibull_ob_css = color_demand_zone
ibear_ob_css = color_supply_zone
bull_ob_css = color_demand_zone
bear_ob_css = color_supply_zone


//Imbalances / Gaps

show_fvg = true
fvg_auto = true
fvg_tf = ''
bull_fvg_css = color.new(#b980ef, 48)
bear_fvg_css = color.new(#b980ef, 55)
fvg_extend = 5


//Previous day/week high/low

//Daily
show_pdhl = show_previous_day_high_low
pdhl_style = 'Â·Â·Â·Â·'
pdhl_css = #ffffff

//Premium and Discount zones

// à¸‹à¹ˆà¸­à¸™ Supply zones à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡ (à¹à¸•à¹ˆà¸¢à¸±à¸‡à¹ƒà¸Šà¹‰ logic à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š rejection)
// à¸–à¹‰à¸²à¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡ â†’ à¸‹à¹ˆà¸­à¸™ Supply zones à¹à¸•à¹ˆà¸¢à¸±à¸‡à¹ƒà¸Šà¹‰ atResistance logic
show_sd = show_demand_supply_zones and not isStrongUptrend  // à¸‹à¹ˆà¸­à¸™ Supply à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡
premium_css = color_supply_zone
discount_css = color_demand_zone

//Functions
n = bar_index

atr_main = ta.atr(200)
cmean_range = ta.cum(high - low) / n

//HL Output function
hl() => [high, low]

//Get ohlc values function
get_ohlc()=> [close[1], open[1], high, low, high[2], low[2]]

//Display Structure function
display_Structure(x, y, txt, css, dashed, down, lbl_size)=>
    structure_line = line.new(x, y, n, y
      , color = css
      , style = dashed ? line.style_dashed : line.style_solid)

    structure_lbl = label.new(int(math.avg(x, n)), y, txt
      , color = TRANSP_COLOR
      , textcolor = css
      , style = down ? label.style_label_down : label.style_label_up
      , size = lbl_size)

    if mode == 'Present'
        line.delete(structure_line[1])
        label.delete(structure_lbl[1])

//Swings detection/measurements
swings_calc(len)=>
    var os = 0
    
    upper = ta.highest(len)
    lower = ta.lowest(len)

    os := high[len] > upper ? 0 : low[len] < lower ? 1 : os[1]

    top = os == 0 and os[1] != 0 ? high[len] : 0
    btm = os == 1 and os[1] != 1 ? low[len] : 0

    [top, btm]

//Order block coordinates function
ob_coord(use_max, loc, target_top, target_btm, target_left, target_type)=>
    min = 99999999.
    max = 0.
    idx = 1

    ob_threshold = ob_filter == 'Atr' ? atr_main : cmean_range 

    //Search for highest/lowest high within the structure interval and get range
    if use_max
        for i = 1 to (n - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                max := math.max(high[i], max)
                min := max == high[i] ? low[i] : min
                idx := max == high[i] ? i : idx
    else
        for i = 1 to (n - loc)-1
            if (high[i] - low[i]) < ob_threshold[i] * 2
                min := math.min(low[i], min)
                max := min == low[i] ? high[i] : max
                idx := min == low[i] ? i : idx

    array.unshift(target_top, max)
    array.unshift(target_btm, min)
    array.unshift(target_left, time[idx])
    array.unshift(target_type, use_max ? -1 : 1)

//Set order blocks
display_ob(boxes, target_top, target_btm, target_left, target_type, show_last, swing, size)=>
    for i = 0 to math.min(show_last-1, size-1)
        get_box = array.get(boxes, i)

        box.set_lefttop(get_box, array.get(target_left, i), array.get(target_top, i))
        box.set_rightbottom(get_box, array.get(target_left, i), array.get(target_btm, i))
        box.set_extend(get_box, extend.right)

        color css = na
        
        if swing 
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
                border_css = array.get(target_type, i) == 1 ? #b2b5be : #5d606b
            else
                css := array.get(target_type, i) == 1 ? bull_ob_css : bear_ob_css
                

            box.set_border_color(get_box, css)
            box.set_bgcolor(get_box, css)
        else
            if style == 'Monochrome'
                css := array.get(target_type, i) == 1 ? color.new(#b2b5be, 80) : color.new(#5d606b, 80)
            else
                css := array.get(target_type, i) == 1 ? ibull_ob_css : ibear_ob_css
            
            box.set_border_color(get_box, css)
            box.set_bgcolor(get_box, css)
        
//Line Style function
get_line_style(style) =>
    out = switch style
        'âŽ¯âŽ¯âŽ¯'  => line.style_solid
        '----' => line.style_dashed
        'Â·Â·Â·Â·' => line.style_dotted

//Set line and labels for previous high and lows
define_previous_days_prices(h, l, tf, css)=>
    var line high_line = line.new(na,na,na,na, xloc=xloc.bar_time, color=css, style=get_line_style(pdhl_style))

    var label high_lbl = label.new(na,na, xloc=xloc.bar_time, text=str.format(previous_day_high_lbl, tf), color=TRANSP_COLOR, textcolor=color_text_prev_high_low, size=size.small, style=label.style_label_left)

    var line low_line = line.new(na,na,na,na, xloc=xloc.bar_time, color=css, style=get_line_style(pdhl_style))

    var label low_lbl = label.new(na,na, xloc=xloc.bar_time, text=str.format(previous_day_low_lbl, tf), color=TRANSP_COLOR, textcolor=color_text_prev_high_low, size=size.small, style=label.style_label_left)

    hy = ta.valuewhen(h != h[1], h, 1)
    hx = ta.valuewhen(h == high, time, 1)

    ly = ta.valuewhen(l != l[1], l, 1)
    lx = ta.valuewhen(l == low, time, 1)

    if barstate.islast
        ext = time + (time - time[1])*20

        //High
        line.set_xy1(high_line, hx, hy)
        line.set_xy2(high_line, ext, hy)

        label.set_xy(high_lbl, ext, hy)

        //Low
        line.set_xy1(low_line, lx, ly)
        line.set_xy2(low_line, ext, ly)

        label.set_xy(low_lbl, ext, ly)

//-----------------------------------------------------------------------------}
//Global variables
//-----------------------------------------------------------------------------{
var trend = 0
var itrend = 0

var top_y = 0.
var top_x = 0
var btm_y = 0.
var btm_x = 0

var itop_y = 0.
var itop_x = 0
var ibtm_y = 0.
var ibtm_x = 0

var trail_up = high
var trail_dn = low
var trail_up_x = 0
var trail_dn_x = 0

var top_cross = true
var btm_cross = true
var itop_cross = true
var ibtm_cross = true

var txt_top = ''
var txt_btm = ''

//Alerts - à¸›à¸£à¸°à¸à¸²à¸¨à¸•à¸±à¸§à¹à¸›à¸£à¸ªà¸³à¸«à¸£à¸±à¸š CHOCH/BOS alerts (à¸›à¸£à¸°à¸à¸²à¸¨à¸à¹ˆà¸­à¸™à¹ƒà¸Šà¹‰à¸‡à¸²à¸™)
bool bull_choch_alert = false 
bool bull_bos_alert = false 
bool bear_choch_alert = false 
bool bear_bos_alert = false 

bull_ichoch_alert = false 
bull_ibos_alert   = false 

bear_ichoch_alert = false 
bear_ibos_alert   = false 

bull_iob_break = false 
bear_iob_break = false

bull_ob_break = false 
bear_ob_break = false

eqh_alert = false 
eql_alert = false 

//Structure colors
var bull_css = style == 'Monochrome' ? #b2b5be 
  : swing_bull_css

var bear_css = style == 'Monochrome' ? #b2b5be 
  : swing_bear_css

var ibull_css = style == 'Monochrome' ? #b2b5be 
  : swing_ibull_css

var ibear_css = style == 'Monochrome' ? #b2b5be 
  : swing_ibear_css

//Swings
[top, btm] = swings_calc(length)

[itop, ibtm] = swings_calc(5)

// ============================================================================
// DIVERGENCE DETECTION LOGIC (à¸¢à¹‰à¸²à¸¢à¸¡à¸²à¸«à¸¥à¸±à¸‡ swings_calc à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸Šà¹‰ btm à¹à¸¥à¸° top)
// ============================================================================
// à¹€à¸à¹‡à¸š pivot points à¹à¸¥à¸° indicator values à¹€à¸¡à¸·à¹ˆà¸­à¸žà¸š pivot
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: à¹ƒà¸Šà¹‰ pivot points à¸ˆà¸²à¸ top/btm à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¹à¸¥à¹‰à¸§ (à¸ˆà¸²à¸ swings_calc)
// btm à¹à¸¥à¸° top à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸—à¸µà¹ˆ bar_index - length (length = 50)
// à¸”à¸±à¸‡à¸™à¸±à¹‰à¸™ indicator values à¸—à¸µà¹ˆ pivot point = indicator[length] (à¸–à¹‰à¸² bar_index > length)
// Divergence Detection - DISABLED to reduce local scopes
// enableDivergence can still be toggled but detection logic is removed to save ~80 scopes
hasPositiveRegularDivergence := false
hasNegativeRegularDivergence := false
hasPositiveHiddenDivergence := false
hasNegativeHiddenDivergence := false

//-----------------------------------------------------------------------------}
//Pivot High
//-----------------------------------------------------------------------------{
var line extend_top = na

var label extend_top_lbl = label.new(na, na, color=TRANSP_COLOR, textcolor=bear_css, style=label.style_label_down, size=size.small)

if top
    top_cross := true
    txt_top := top > top_y ? 'HH' : 'LH'

    if show_swings
        top_lbl = label.new(n-length, top, txt_top
          , color = TRANSP_COLOR
          , textcolor = bear_css
          , style = label.style_label_down
          , size = size.small)

        if mode == 'Present'
            label.delete(top_lbl[1])

    //Extend recent top to last bar
    line.delete(extend_top[1])
    extend_top := line.new(n-length, top, n, top
      , color = bear_css)

    top_y := top
    top_x := n - length

    trail_up := top
    trail_up_x := n - length

if itop
    itop_cross := true

    itop_y := itop
    itop_x := n - 5

//Trailing maximum
trail_up := math.max(high, trail_up)
trail_up_x := trail_up == high ? n : trail_up_x

//Set top extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_top, trail_up_x, trail_up)
    line.set_xy2(extend_top, n + 20, trail_up)

    label.set_x(extend_top_lbl, n + 20)
    label.set_y(extend_top_lbl, trail_up)
    label.set_text(extend_top_lbl, trend < 0 ? strong_high_lbl : weak_high_lbl)

//-----------------------------------------------------------------------------}
//Pivot Low
//-----------------------------------------------------------------------------{
var line extend_btm = na 

var label extend_btm_lbl = label.new(na, na, color=TRANSP_COLOR, textcolor=bull_css, style=label.style_label_up, size=size.small)

if btm
    btm_cross := true
    txt_btm := btm < btm_y ? 'LL' : 'HL'
    
    if show_swings
        btm_lbl = label.new(n - length, btm, txt_btm
          , color = TRANSP_COLOR
          , textcolor = bull_css
          , style = label.style_label_up
          , size = size.small)

        if mode == 'Present'
            label.delete(btm_lbl[1])
    
    //Extend recent btm to last bar
    line.delete(extend_btm[1])
    extend_btm := line.new(n - length, btm, n, btm
      , color = bull_css)

    btm_y := btm
    btm_x := n-length

    trail_dn := btm
    trail_dn_x := n-length

if ibtm
    ibtm_cross := true

    ibtm_y := ibtm
    ibtm_x := n - 5

//Trailing minimum
trail_dn := math.min(low, trail_dn)
trail_dn_x := trail_dn == low ? n : trail_dn_x

//Set btm extension label/line
if barstate.islast and show_hl_swings
    line.set_xy1(extend_btm, trail_dn_x, trail_dn)
    line.set_xy2(extend_btm, n + 20, trail_dn)

    label.set_x(extend_btm_lbl, n + 20)
    label.set_y(extend_btm_lbl, trail_dn)
    label.set_text(extend_btm_lbl, trend > 0 ? strong_low_lbl : weak_low_lbl)

//-----------------------------------------------------------------------------}
//Fibonacci Trading System - à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸š LL à¹à¸¥à¸° HH à¸ˆà¸²à¸ Swing Points
//-----------------------------------------------------------------------------}
if btm
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ LL (Lower Low) à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
    if na(prevBtmY) or btm < prevBtmY
        fibLL := btm
        fibLLIndex := btm_x
        // à¹€à¸à¹‡à¸š time à¸‚à¸­à¸‡ fibLL à¹‚à¸”à¸¢à¹ƒà¸Šà¹‰ time[length] (à¹€à¸¡à¸·à¹ˆà¸­ btm à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸—à¸µà¹ˆ btm_x = n - length)
        // btm à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸—à¸µà¹ˆ bar index = n - length, à¸”à¸±à¸‡à¸™à¸±à¹‰à¸™ time = time[length]
        fibLLTime := time[length]
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ HL (Higher Low) à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (à¸ªà¸³à¸«à¸£à¸±à¸š Trailing Stop à¹à¸¥à¸° Wave B SL)
    // HL = btm > prevBtmY (à¸£à¸²à¸„à¸²à¸•à¹ˆà¸³à¸ªà¸¸à¸”à¹ƒà¸«à¸¡à¹ˆà¸ªà¸¹à¸‡à¸à¸§à¹ˆà¸²à¸•à¹ˆà¸³à¸ªà¸¸à¸”à¹€à¸à¹ˆà¸²)
    if not na(prevBtmY) and btm > prevBtmY
        // à¹€à¸à¹‡à¸š HL à¸ªà¸³à¸«à¸£à¸±à¸šà¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™ Stop Loss à¸‚à¸­à¸‡ Wave 2/Wave B
        fibHL := btm
        fibHLIndex := btm_x
        
        // à¸–à¹‰à¸²à¸¡à¸µ position à¸­à¸¢à¸¹à¹ˆ à¹ƒà¸«à¹‰à¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™ Trailing Stop
        if strategy.position_size > 0
            // à¹€à¸à¹‡à¸š HL à¸ªà¸³à¸«à¸£à¸±à¸š Trailing Stop
            hlPrice := btm
            hlIndex := btm_x
            // à¸«à¸²à¹à¸—à¹ˆà¸‡à¸—à¸µà¹ˆ 1 à¸‚à¸­à¸‡ HL (à¸™à¸±à¸šà¸ˆà¸²à¸à¸‹à¹‰à¸²à¸¢) - à¹ƒà¸Šà¹‰ btm_x à¹€à¸›à¹‡à¸™à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™
            // btm_x = bar index à¸—à¸µà¹ˆ btm à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™ (n - length)
            // à¹à¸—à¹ˆà¸‡à¸—à¸µà¹ˆ 1 à¸‚à¸­à¸‡ HL = à¹à¸—à¹ˆà¸‡à¸—à¸µà¹ˆ btm_x (à¹à¸—à¹ˆà¸‡à¸—à¸µà¹ˆ btm à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™)
            hlFirstCandleIndex := btm_x
            // à¹€à¸à¹‡à¸šà¸£à¸²à¸„à¸²à¹€à¸›à¸´à¸”à¸‚à¸­à¸‡à¹à¸—à¹ˆà¸‡à¸—à¸µà¹ˆ 1 à¸‚à¸­à¸‡ HL
            // btm_x = n - length, à¸”à¸±à¸‡à¸™à¸±à¹‰à¸™ open = open[length]
            if bar_index > length
                hlFirstCandleOpen := open[length]
            else
                hlFirstCandleOpen := open
        
        // à¹€à¸à¹‡à¸š LL à¸‚à¸­à¸‡ Wave 1 à¸ˆà¸²à¸à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡ trend (à¹€à¸à¹‡à¸šà¸„à¸£à¸±à¹‰à¸‡à¹à¸£à¸à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™ - à¹„à¸¡à¹ˆ reset)
        // à¸ªà¸³à¸«à¸£à¸±à¸š bullish CHOCH: à¹€à¸à¹‡à¸š LL à¸à¹ˆà¸­à¸™ CHOCH (à¹ƒà¸Šà¹‰ btm_y à¸«à¸£à¸·à¸­ trail_dn à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¸à¹ˆà¸­à¸™ CHOCH)
        // à¸ªà¸³à¸«à¸£à¸±à¸š bearish CHOCH: à¹€à¸à¹‡à¸š LL à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ CHOCH (à¸–à¹‰à¸²à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ)
        if firstWaveStored == false
            // Bullish CHOCH: à¹€à¸à¹‡à¸š LL à¸à¹ˆà¸­à¸™ CHOCH (à¹ƒà¸Šà¹‰ btm_y à¸«à¸£à¸·à¸­ trail_dn à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¸à¹ˆà¸­à¸™ CHOCH)
            // à¹à¸•à¹ˆà¸–à¹‰à¸² CHOCH à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¹à¸¥à¹‰à¸§ à¹à¸¥à¸°à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ firstWaveLL à¹ƒà¸«à¹‰à¹ƒà¸Šà¹‰ btm à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™ (à¸‹à¸¶à¹ˆà¸‡à¸­à¸²à¸ˆà¹€à¸›à¹‡à¸™ LL à¸à¹ˆà¸­à¸™ CHOCH)
            if chochDetected == true and trend == 1 and na(firstWaveLL)
                // à¹ƒà¸Šà¹‰ btm à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™ (à¸‹à¸¶à¹ˆà¸‡à¹€à¸›à¹‡à¸™ LL à¸à¹ˆà¸­à¸™ CHOCH à¸–à¹‰à¸² trend à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸ˆà¸²à¸ -1 à¹€à¸›à¹‡à¸™ 1)
                // à¸«à¸£à¸·à¸­à¹ƒà¸Šà¹‰ trail_dn (lowest point à¸à¹ˆà¸­à¸™ CHOCH) à¸–à¹‰à¸²à¸¡à¸µ
                // à¹ƒà¸Šà¹‰ trail_dn (lowest point à¸à¹ˆà¸­à¸™ CHOCH) à¸–à¹‰à¸²à¸¡à¸µ à¹à¸¥à¸°à¸•à¹ˆà¸³à¸à¸§à¹ˆà¸² btm à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™
                // trail_dn à¸–à¸¹à¸à¹€à¸à¹‡à¸šà¹„à¸§à¹‰à¹€à¸¡à¸·à¹ˆà¸­ btm à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸à¹ˆà¸­à¸™ CHOCH (trend < 0)
                if not na(trail_dn) and (na(btm) or trail_dn <= btm) and trail_dn_x > 0
                    firstWaveLL := trail_dn  // à¹ƒà¸Šà¹‰ lowest point à¸à¹ˆà¸­à¸™ CHOCH (à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡ Wave 1)
                    firstWaveLLIndex := trail_dn_x
                    if trail_dn_x > 0 and math.abs(bar_index - trail_dn_x) < 500
                        firstWaveLLTime := time[bar_index - trail_dn_x]
                    else
                        firstWaveLLTime := time[length]
                else
                    // à¸–à¹‰à¸²à¹„à¸¡à¹ˆà¸¡à¸µ trail_dn à¹ƒà¸«à¹‰à¹ƒà¸Šà¹‰ btm à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™ (à¸‹à¸¶à¹ˆà¸‡à¸­à¸²à¸ˆà¹€à¸›à¹‡à¸™ LL à¸à¹ˆà¸­à¸™ CHOCH)
                    firstWaveLL := btm
                    firstWaveLLIndex := btm_x
                    firstWaveLLTime := time[length]
                // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸¡à¸µà¸—à¸±à¹‰à¸‡ LL à¹à¸¥à¸° HH à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡ (à¸ªà¸³à¸«à¸£à¸±à¸š bullish CHOCH)
                if not na(firstWaveLL) and not na(firstWaveHH) and firstWaveHH > firstWaveLL
                    firstWaveStored := true  // à¹€à¸à¹‡à¸šà¸„à¸£à¸šà¹à¸¥à¹‰à¸§ - à¹„à¸¡à¹ˆ reset à¸­à¸µà¸
            // Bearish CHOCH: à¹€à¸à¹‡à¸š LL à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ CHOCH (à¸–à¹‰à¸² CHOCH à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¹à¸¥à¹‰à¸§)
            else if chochDetected == true and trend == -1 and not na(firstWaveHH) and na(firstWaveLL)
                firstWaveLL := btm
                firstWaveLLIndex := btm_x
                firstWaveLLTime := time[length]
                // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸¡à¸µà¸—à¸±à¹‰à¸‡ HH à¹à¸¥à¸° LL à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡ (à¸ªà¸³à¸«à¸£à¸±à¸š bearish CHOCH - à¹à¸•à¹ˆà¸ªà¸³à¸«à¸£à¸±à¸š bearish HH > LL à¹„à¸¡à¹ˆà¸ˆà¸£à¸´à¸‡)
                // à¸ªà¸³à¸«à¸£à¸±à¸š bearish CHOCH: firstWaveHH (à¸à¹ˆà¸­à¸™ CHOCH) > firstWaveLL (à¸«à¸¥à¸±à¸‡ CHOCH) à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ - à¸•à¹‰à¸­à¸‡à¹à¸à¹‰ logic
                if not na(firstWaveLL) and not na(firstWaveHH)
                    firstWaveStored := true  // à¹€à¸à¹‡à¸šà¸„à¸£à¸šà¹à¸¥à¹‰à¸§ - à¹„à¸¡à¹ˆ reset à¸­à¸µà¸
            // à¹€à¸à¹‡à¸š LL à¸ªà¸³à¸«à¸£à¸±à¸š Wave 1 (CHOCH à¹à¸£à¸) à¸–à¹‰à¸²à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸„à¸¢à¹€à¸à¹‡à¸š (à¸à¸£à¸“à¸µà¸—à¸µà¹ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸à¸´à¸” CHOCH)
            else if isFirstWave == true and chochDetected == false and na(firstWaveLL)
                firstWaveLL := btm
                firstWaveLLIndex := btm_x
                firstWaveLLTime := time[length]
                // à¸¢à¸±à¸‡à¹„à¸¡à¹ˆ set firstWaveStored à¸ˆà¸™à¸à¸§à¹ˆà¸²à¸ˆà¸°à¸¡à¸µà¸—à¸±à¹‰à¸‡ LL à¹à¸¥à¸° HH
        
        if showFibonacci and enableFibonacci
            if not na(fibLLLabel)
                label.delete(fibLLLabel)
            fibLLLabel := label.new(btm_x, btm, "LL\n" + str.tostring(btm, "#.##"), color=color.new(color.gray, 90), textcolor=color.new(color.gray, 20), size=size.small, style=label.style_label_up, xloc=xloc.bar_index)
    prevBtmY := btm

if top
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ HH (Higher High) à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
    if na(prevTopY) or top > prevTopY
        fibHH := top
        fibHHIndex := top_x
        // à¹€à¸à¹‡à¸š time à¸‚à¸­à¸‡ fibHH à¹‚à¸”à¸¢à¹ƒà¸Šà¹‰ time[length] (à¹€à¸¡à¸·à¹ˆà¸­ top à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸—à¸µà¹ˆ top_x = n - length)
        // top à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸—à¸µà¹ˆ bar index = n - length, à¸”à¸±à¸‡à¸™à¸±à¹‰à¸™ time = time[length]
        fibHHTime := time[length]
        
        // à¹€à¸à¹‡à¸š HH à¸‚à¸­à¸‡ Wave 1 à¸ˆà¸²à¸à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡ trend (à¹€à¸à¹‡à¸šà¸„à¸£à¸±à¹‰à¸‡à¹à¸£à¸à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™ - à¹„à¸¡à¹ˆ reset)
        // à¸ªà¸³à¸«à¸£à¸±à¸š bullish CHOCH: à¹€à¸à¹‡à¸š HH à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ CHOCH (à¸–à¹‰à¸² CHOCH à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¹à¸¥à¹‰à¸§)
        // à¸ªà¸³à¸«à¸£à¸±à¸š bearish CHOCH: à¹€à¸à¹‡à¸š HH à¸à¹ˆà¸­à¸™ CHOCH (à¹ƒà¸Šà¹‰ top_y à¸«à¸£à¸·à¸­ trail_up à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¸à¹ˆà¸­à¸™ CHOCH)
        if firstWaveStored == false
            // Bullish CHOCH: à¹€à¸à¹‡à¸š HH à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ CHOCH (à¸–à¹‰à¸² CHOCH à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¹à¸¥à¹‰à¸§ à¹à¸¥à¸°à¸¡à¸µ LL à¹à¸¥à¹‰à¸§)
            if chochDetected == true and trend == 1 and not na(firstWaveLL) and na(firstWaveHH)
                firstWaveHH := top
                firstWaveHHIndex := top_x
                // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸¡à¸µà¸—à¸±à¹‰à¸‡ LL à¹à¸¥à¸° HH à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡ (à¸ªà¸³à¸«à¸£à¸±à¸š bullish CHOCH - à¸•à¹‰à¸­à¸‡ HH > LL)
                if not na(firstWaveLL) and not na(firstWaveHH) and firstWaveHH > firstWaveLL
                    firstWaveStored := true  // à¹€à¸à¹‡à¸šà¸„à¸£à¸šà¹à¸¥à¹‰à¸§ - à¹„à¸¡à¹ˆ reset à¸­à¸µà¸
            // Bearish CHOCH: à¹€à¸à¹‡à¸š HH à¸à¹ˆà¸­à¸™ CHOCH (à¹ƒà¸Šà¹‰ top_y à¸«à¸£à¸·à¸­ trail_up à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¸à¹ˆà¸­à¸™ CHOCH)
            else if chochDetected == true and trend == -1 and na(firstWaveHH)
                // à¹ƒà¸Šà¹‰ top à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™ (à¸‹à¸¶à¹ˆà¸‡à¸­à¸²à¸ˆà¹€à¸›à¹‡à¸™ HH à¸à¹ˆà¸­à¸™ CHOCH à¸–à¹‰à¸² trend à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸ˆà¸²à¸ 1 à¹€à¸›à¹‡à¸™ -1)
                // à¸«à¸£à¸·à¸­à¹ƒà¸Šà¹‰ trail_up (highest point à¸à¹ˆà¸­à¸™ CHOCH) à¸–à¹‰à¸²à¸¡à¸µ
                if not na(trail_up) and trail_up > top
                    firstWaveHH := trail_up  // à¹ƒà¸Šà¹‰ highest point à¸à¹ˆà¸­à¸™ CHOCH
                    firstWaveHHIndex := trail_up_x
                else
                    firstWaveHH := top
                    firstWaveHHIndex := top_x
                if na(firstWaveLLTime) and na(firstWaveLL)
                    firstWaveLLTime := time[length]  // à¸–à¹‰à¸²à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ firstWaveLLTime à¹à¸¥à¸° firstWaveLL à¹ƒà¸Šà¹‰ time[length] à¹€à¸”à¸µà¸¢à¸§à¸à¸±à¸™
                // à¸¢à¸±à¸‡à¹„à¸¡à¹ˆ set firstWaveStored à¸ˆà¸™à¸à¸§à¹ˆà¸²à¸ˆà¸°à¸¡à¸µà¸—à¸±à¹‰à¸‡ HH à¹à¸¥à¸° LL (à¸ªà¸³à¸«à¸£à¸±à¸š bearish HH < LL)
            // à¹€à¸à¹‡à¸š HH à¸ªà¸³à¸«à¸£à¸±à¸š Wave 1 (CHOCH à¹à¸£à¸) à¸–à¹‰à¸²à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸„à¸¢à¹€à¸à¹‡à¸š (à¸à¸£à¸“à¸µà¸—à¸µà¹ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹€à¸à¸´à¸” CHOCH)
            else if isFirstWave == true and chochDetected == false and na(firstWaveHH)
                firstWaveHH := top
                firstWaveHHIndex := top_x
                if na(firstWaveLLTime) and na(firstWaveLL)
                    firstWaveLLTime := time[length]  // à¸–à¹‰à¸²à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ firstWaveLLTime à¹à¸¥à¸° firstWaveLL à¹ƒà¸Šà¹‰ time[length] à¹€à¸”à¸µà¸¢à¸§à¸à¸±à¸™
                // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸¡à¸µà¸—à¸±à¹‰à¸‡ LL à¹à¸¥à¸° HH à¹à¸¥à¹‰à¸§à¸«à¸£à¸·à¸­à¸¢à¸±à¸‡ (à¸ªà¸³à¸«à¸£à¸±à¸š uptrend à¸•à¹‰à¸­à¸‡ HH > LL)
                if not na(firstWaveLL) and not na(firstWaveHH) and firstWaveHH > firstWaveLL
                    firstWaveStored := true  // à¹€à¸à¹‡à¸šà¸„à¸£à¸šà¹à¸¥à¹‰à¸§ - à¹„à¸¡à¹ˆ reset à¸­à¸µà¸
        
        if showFibonacci and enableFibonacci
            if not na(fibHHLabel)
                label.delete(fibHHLabel)
            fibHHLabel := label.new(top_x, top, "HH\n" + str.tostring(top, "#.##"), color=color.new(color.gray, 90), textcolor=color.new(color.gray, 20), size=size.small, style=label.style_label_down, xloc=xloc.bar_index)
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ LH (Lower High) à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ (à¸ªà¸³à¸«à¸£à¸±à¸š Wave B Short SL)
    // LH = top < prevTopY (à¸£à¸²à¸„à¸²à¸ªà¸¹à¸‡à¸ªà¸¸à¸”à¹ƒà¸«à¸¡à¹ˆà¸•à¹ˆà¸³à¸à¸§à¹ˆà¸²à¸ªà¸¹à¸‡à¸ªà¸¸à¸”à¹€à¸à¹ˆà¸²)
    if not na(prevTopY) and top < prevTopY
        // à¹€à¸à¹‡à¸š LH à¸ªà¸³à¸«à¸£à¸±à¸šà¹ƒà¸Šà¹‰à¹€à¸›à¹‡à¸™ Stop Loss à¸‚à¸­à¸‡ Wave 2/Wave B (Short)
        fibLH := top
        fibLHIndex := top_x
    
    prevTopY := top

//-----------------------------------------------------------------------------}
//Order Blocks Arrays
//-----------------------------------------------------------------------------{
var iob_top = array.new_float(0)
var iob_btm = array.new_float(0)
var iob_left = array.new_int(0)
var iob_type = array.new_int(0)

var ob_top = array.new_float(0)
var ob_btm = array.new_float(0)
var ob_left = array.new_int(0)
var ob_type = array.new_int(0)

//-----------------------------------------------------------------------------}
//Pivot High BOS and Choch
//-----------------------------------------------------------------------------{
//Filtering
var bull_concordant = true

if ifilter_confluence
    bull_concordant := high - math.max(close, open) > math.min(close, open - low)

//Detect internal bullish Structure
if ta.crossover(close, itop_y) and itop_cross and top_y != itop_y and bull_concordant
    bool choch = na
    
    if itrend < 0
        choch := true
        bull_ichoch_alert := false
    else 
        bull_ibos_alert := false
    
    txt = ""
    if(english_language_selected == false)
        txt := choch ? 'AlteraÃ§Ã£o de CarÃ¡ter' : 'Quebra Estrutura'
    else
        txt := choch ? 'CHoCH' : 'BOS'    

    if show_internals
        if show_ibull == 'All' or (show_ibull == 'BOS' and not choch) or (show_ibull == 'CHoCH' and choch)
            display_Structure(itop_x, itop_y, txt, ibull_css, true, true, size.tiny)
    
    //Internal Order Block - à¹€à¸£à¸µà¸¢à¸à¸à¹ˆà¸­à¸™ reset itop_cross
    if show_iob and ta.crossover(close, itop_y) and itop_cross
        ob_coord(false, itop_x, iob_top, iob_btm, iob_left, iob_type)
    
    itop_cross := false
    itrend := 1

//Detect bullish Structure
if ta.crossover(close, top_y) and top_cross
    bool choch = na
    
    if trend < 0
        choch := true
        // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸£à¸²à¸„à¸²à¸”à¸±à¸™à¹€à¸«à¸™à¸·à¸­ SMA7/21 à¸ªà¸³à¸«à¸£à¸±à¸š CHOCH
        bool priceAboveSMA = close > fastSMA and close > slowSMA
        if priceAboveSMA
            bull_choch_alert := true
        else
            bull_choch_alert := false  // à¸–à¹‰à¸²à¸£à¸²à¸„à¸²à¹„à¸¡à¹ˆà¸”à¸±à¸™à¹€à¸«à¸™à¸·à¸­ SMA7/21 = à¹„à¸¡à¹ˆà¹ƒà¸Šà¹ˆ CHOCH
        // Bullish CHOCH: à¹€à¸à¹‡à¸š Wave 1 à¸ˆà¸²à¸à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡ trend (LL à¸à¹ˆà¸­à¸™ CHOCH)
        // à¹ƒà¸Šà¹‰ trail_dn (lowest point à¸à¹ˆà¸­à¸™ CHOCH) à¹€à¸›à¹‡à¸™ firstWaveLL
        // trail_dn à¸–à¸¹à¸à¹€à¸à¹‡à¸šà¹„à¸§à¹‰à¹€à¸¡à¸·à¹ˆà¸­ btm à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸à¹ˆà¸­à¸™ CHOCH (trend < 0)
        if firstWaveStored == false and na(firstWaveLL) and not na(trail_dn)
            firstWaveLL := trail_dn
            if trail_dn_x > 0 and math.abs(bar_index - trail_dn_x) < 500
                firstWaveLLIndex := trail_dn_x
                firstWaveLLTime := time[bar_index - trail_dn_x]
            else if trail_dn_x > 0
                firstWaveLLIndex := trail_dn_x
                firstWaveLLTime := time[length]
            else
                firstWaveLLIndex := bar_index - length
                firstWaveLLTime := time[length]
    else 
        bull_bos_alert := true

    txt = ""
    if(english_language_selected == false)
        txt := choch ? 'AlteraÃ§Ã£o CarÃ¡ter' : 'Quebra Estrutura'
    else
        txt := choch ? 'CHoCH' : 'Break of Structure'    
    //txt = choch ? 'AlteraÃ§Ã£o de CarÃ¡ter' : 'Quebra Estrutura'
   

    if show_Structure
        if show_bull == 'All' or (show_bull == 'BOS' and not choch) or (show_bull == 'CHoCH' and choch)
            display_Structure(top_x, top_y, txt, color_demand_zone, false, true, size.small)
    
    //Order Block - à¹€à¸£à¸µà¸¢à¸à¸à¹ˆà¸­à¸™ reset top_cross
    // à¸‹à¹ˆà¸­à¸™ Supply zones à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡ à¹à¸•à¹ˆà¸¢à¸±à¸‡à¹ƒà¸Šà¹‰ logic à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š rejection
    if show_ob and show_demand_supply_zones and not isStrongUptrend and ta.crossover(close, top_y) and top_cross
        ob_coord(false, top_x, ob_top, ob_btm, ob_left, ob_type)
    
    top_cross := false
    trend := 1

//-----------------------------------------------------------------------------}
//Pivot Low BOS and CHoCH
//-----------------------------------------------------------------------------{
var bear_concordant = true

if ifilter_confluence
    bear_concordant := high - math.max(close, open) < math.min(close, open - low)

//Detect internal bearish Structure
if ta.crossunder(close, ibtm_y) and ibtm_cross and btm_y != ibtm_y and bear_concordant
    bool choch = false
    
    if itrend > 0
        choch := true
        bear_ichoch_alert := true
    else 
        bear_ibos_alert := true
    
    txt = ""
    if(english_language_selected == false)
        txt := choch ? 'AlteraÃ§Ã£o CarÃ¡ter' : 'Quebra Estrutura'
    else
        txt := choch ? 'CHoCH' : 'Break of Structure'    
    //txt = choch ? 'AlteraÃ§Ã£o de CarÃ¡ter' : 'QUEBRA DE ESTRUTURA'

    if show_internals
        if show_ibear == 'All' or (show_ibear == 'BOS' and not choch) or (show_ibear == 'CHoCH' and choch)
            display_Structure(ibtm_x, ibtm_y, txt, ibear_css, true, false, size.small)
    
    //Internal Order Block - à¹€à¸£à¸µà¸¢à¸à¸à¹ˆà¸­à¸™ reset ibtm_cross
    if show_iob and ta.crossunder(close, ibtm_y) and ibtm_cross
        ob_coord(true, ibtm_x, iob_top, iob_btm, iob_left, iob_type)
    
    ibtm_cross := false
    itrend := -1

//Detect bearish Structure
if ta.crossunder(close, btm_y) and btm_cross
    bool choch = na
    
    if trend > 0
        choch := true
        bear_choch_alert := true
    else 
        bear_bos_alert := true

    txt = ""
    if(english_language_selected == false)
        txt := choch ? 'AlteraÃ§Ã£o CarÃ¡ter' : 'Quebra Estrutura'
    else
        txt := choch ? 'CHoch' : 'Break of Structure'    
    
    //txt = choch ? 'AlteraÃ§Ã£o de CarÃ¡ter' : 'QUEBRA DE ESTRUTURA'
    
    if show_Structure
        if show_bear == 'All' or (show_bear == 'BOS' and not choch) or (show_bear == 'CHoCH' and choch)
            display_Structure(btm_x, btm_y, txt, color_supply_zone, true, false, size.small)
    
    //Order Block - à¹€à¸£à¸µà¸¢à¸à¸à¹ˆà¸­à¸™ reset btm_cross
    if show_ob and show_demand_supply_zones and ta.crossunder(close, btm_y) and btm_cross
        ob_coord(true, btm_x, ob_top, ob_btm, ob_left, ob_type)
    
    btm_cross := false
    trend := -1

//-----------------------------------------------------------------------------}
//Fibonacci Trading System - à¸•à¸£à¸§à¸ˆà¸ˆà¸±à¸š CHOCH (Change of Character)
//-----------------------------------------------------------------------------}
// à¹€à¸à¹‡à¸š Wave 1 à¸ˆà¸²à¸à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡ trend (à¹„à¸¡à¹ˆ reset)
// à¸ªà¸³à¸«à¸£à¸±à¸š bullish CHOCH: Wave 1 = LL (à¸à¹ˆà¸­à¸™ CHOCH) â†’ HH (à¸«à¸¥à¸±à¸‡ CHOCH)
// à¸ªà¸³à¸«à¸£à¸±à¸š bearish CHOCH: Wave 1 = HH (à¸à¹ˆà¸­à¸™ CHOCH) â†’ LL (à¸«à¸¥à¸±à¸‡ CHOCH)

// Multi-Timeframe CHOCH Detection - à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š CHOCH à¹ƒà¸™à¹à¸•à¹ˆà¸¥à¸° timeframe à¹‚à¸”à¸¢à¸•à¸£à¸‡ (à¸—à¸³à¸‡à¸²à¸™à¸—à¸¸à¸ bar)
// à¹ƒà¸Šà¹‰ request.security à¹€à¸žà¸·à¹ˆà¸­à¸”à¸¶à¸‡ bull_choch_alert à¹à¸¥à¸° bear_choch_alert à¸ˆà¸²à¸à¹à¸•à¹ˆà¸¥à¸° timeframe
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: request.security à¸•à¹‰à¸­à¸‡à¹ƒà¸Šà¹‰ lookahead=barmerge.lookahead_off à¹€à¸žà¸·à¹ˆà¸­à¸«à¸¥à¸µà¸à¹€à¸¥à¸µà¹ˆà¸¢à¸‡ repainting
// CHOCH Detection à¸ˆà¸²à¸ TF 1H, 4H, 15M, à¹à¸¥à¸° 5M (à¹ƒà¸Šà¹‰à¹€à¸‰à¸žà¸²à¸° TF à¹€à¸«à¸¥à¹ˆà¸²à¸™à¸µà¹‰à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¸™à¸±à¸šà¹€à¸§à¸Ÿ)
bool bull_choch_5M = request.security(syminfo.tickerid, "5", bull_choch_alert, lookahead=barmerge.lookahead_off)
bool bear_choch_5M = request.security(syminfo.tickerid, "5", bear_choch_alert, lookahead=barmerge.lookahead_off)
bool bull_choch_15M = request.security(syminfo.tickerid, "15", bull_choch_alert, lookahead=barmerge.lookahead_off)
bool bear_choch_15M = request.security(syminfo.tickerid, "15", bear_choch_alert, lookahead=barmerge.lookahead_off)
bool bull_choch_1H = request.security(syminfo.tickerid, "60", bull_choch_alert, lookahead=barmerge.lookahead_off)
bool bear_choch_1H = request.security(syminfo.tickerid, "60", bear_choch_alert, lookahead=barmerge.lookahead_off)
bool bull_choch_4H = request.security(syminfo.tickerid, "240", bull_choch_alert, lookahead=barmerge.lookahead_off)
bool bear_choch_4H = request.security(syminfo.tickerid, "240", bear_choch_alert, lookahead=barmerge.lookahead_off)
bool bull_choch_1D = request.security(syminfo.tickerid, "D", bull_choch_alert, lookahead=barmerge.lookahead_off)
bool bear_choch_1D = request.security(syminfo.tickerid, "D", bear_choch_alert, lookahead=barmerge.lookahead_off)
bool bull_choch_30M = request.security(syminfo.tickerid, "30", bull_choch_alert, lookahead=barmerge.lookahead_off)
bool bear_choch_30M = request.security(syminfo.tickerid, "30", bear_choch_alert, lookahead=barmerge.lookahead_off)

bool choch5M = bull_choch_5M or bear_choch_5M
bool choch15M = bull_choch_15M or bear_choch_15M
bool choch1H = bull_choch_1H or bear_choch_1H
bool choch4H = bull_choch_4H or bear_choch_4H
bool choch1D = bull_choch_1D or bear_choch_1D
bool choch30M = bull_choch_30M or bear_choch_30M

// à¸„à¸³à¸™à¸§à¸“ trend à¸ªà¸³à¸«à¸£à¸±à¸šà¹à¸•à¹ˆà¸¥à¸° timeframe
int trend_1D = choch1D ? (bull_choch_1D ? 1 : -1) : 0
int trend_30M = choch30M ? (bull_choch_30M ? 1 : -1) : 0

// à¸­à¸±à¸žà¹€à¸”à¸— trendFromCHOCH à¸ªà¸³à¸«à¸£à¸±à¸š Dashboard
if choch1D
    trendFromCHOCH_1D := trend_1D
if choch30M
    trendFromCHOCH_30M := trend_30M

// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š CHOCH à¹ƒà¸™ timeframe à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™
if bull_choch_alert or bear_choch_alert
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¹€à¸›à¹‡à¸™ CHOCH à¹à¸£à¸ (Wave 1) à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
    if not chochDetected
        isFirstWave := true
        wave1Completed := false
        // à¹€à¸à¹‡à¸š Wave 1 à¸ˆà¸²à¸à¸ˆà¸¸à¸”à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸‚à¸­à¸‡ trend (à¹€à¸à¹‡à¸šà¸„à¸£à¸±à¹‰à¸‡à¹à¸£à¸à¹€à¸—à¹ˆà¸²à¸™à¸±à¹‰à¸™ - à¹„à¸¡à¹ˆ reset)
        // à¸ªà¸³à¸«à¸£à¸±à¸š bullish CHOCH (trend < 0 à¸à¸¥à¸²à¸¢à¹€à¸›à¹‡à¸™ trend = 1): Wave 1 = LL (à¸à¹ˆà¸­à¸™ CHOCH) â†’ HH (à¸«à¸¥à¸±à¸‡ CHOCH)
        // à¸ªà¸³à¸«à¸£à¸±à¸š bearish CHOCH (trend > 0 à¸à¸¥à¸²à¸¢à¹€à¸›à¹‡à¸™ trend = -1): Wave 1 = HH (à¸à¹ˆà¸­à¸™ CHOCH) â†’ LL (à¸«à¸¥à¸±à¸‡ CHOCH)
        if firstWaveStored == false
            // à¹€à¸à¹‡à¸š Wave 1 à¸ˆà¸²à¸ LL à¹à¸¥à¸° HH à¸—à¸µà¹ˆà¸¡à¸µà¸­à¸¢à¸¹à¹ˆà¸à¹ˆà¸­à¸™ CHOCH (à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹„à¸”à¹‰ Wave 1 à¸—à¸µà¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡)
            // à¹à¸•à¹ˆà¸–à¹‰à¸²à¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¸¡à¸µ fibLL/fibHH à¹ƒà¸«à¹‰à¸£à¸­à¹€à¸à¹‡à¸šà¹€à¸¡à¸·à¹ˆà¸­à¸¡à¸µ btm/top à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™
            if bull_choch_alert and not na(fibLL) and not na(fibLLIndex)
                // Bullish CHOCH: Wave 1 à¹€à¸£à¸´à¹ˆà¸¡à¸ˆà¸²à¸ LL (à¸à¹ˆà¸­à¸™ CHOCH)
                firstWaveLL := fibLL
                firstWaveLLIndex := fibLLIndex
                if math.abs(bar_index - fibLLIndex) < 500
                    firstWaveLLTime := time[bar_index - fibLLIndex]
                else
                    firstWaveLLTime := time
                // HH à¸ˆà¸°à¸–à¸¹à¸à¹€à¸à¹‡à¸šà¹€à¸¡à¸·à¹ˆà¸­ top à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ CHOCH
            else if bear_choch_alert and not na(fibHH) and not na(fibHHIndex)
                // Bearish CHOCH: Wave 1 à¹€à¸£à¸´à¹ˆà¸¡à¸ˆà¸²à¸ HH (à¸à¹ˆà¸­à¸™ CHOCH)
                firstWaveHH := fibHH
                firstWaveHHIndex := fibHHIndex
                // LL à¸ˆà¸°à¸–à¸¹à¸à¹€à¸à¹‡à¸šà¹€à¸¡à¸·à¹ˆà¸­ btm à¹€à¸à¸´à¸”à¸‚à¸¶à¹‰à¸™à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ CHOCH
            // à¹„à¸¡à¹ˆ set firstWaveStored à¸ˆà¸™à¸à¸§à¹ˆà¸²à¸ˆà¸°à¸¡à¸µà¸—à¸±à¹‰à¸‡ LL à¹à¸¥à¸° HH
    
    chochDetected := true
    chochPrice := close
    chochIndex := bar_index
    
    if choch5M
        if not chochDetected_5M
            chochDetected_5M := true
            chochPrice_5M := request.security(syminfo.tickerid, "5", close, lookahead=barmerge.lookahead_off)
            chochIndex_5M := bar_index
        trendFromCHOCH_5M := bull_choch_5M ? 1 : -1
    if choch15M
        if not chochDetected_15M
            chochDetected_15M := true
            chochPrice_15M := request.security(syminfo.tickerid, "15", close, lookahead=barmerge.lookahead_off)
            chochIndex_15M := bar_index
        trendFromCHOCH_15M := bull_choch_15M ? 1 : -1
    if choch1H
        if not chochDetected_1H
            chochDetected_1H := true
            chochPrice_1H := request.security(syminfo.tickerid, "60", close, lookahead=barmerge.lookahead_off)
            chochIndex_1H := bar_index
        trendFromCHOCH_1H := bull_choch_1H ? 1 : -1
    if choch4H
        if not chochDetected_4H
            chochDetected_4H := true
            chochPrice_4H := request.security(syminfo.tickerid, "240", close, lookahead=barmerge.lookahead_off)
            chochIndex_4H := bar_index
        trendFromCHOCH_4H := bull_choch_4H ? 1 : -1
    if choch1D
        if not chochDetected_1D
            chochDetected_1D := true
            chochPrice_1D := request.security(syminfo.tickerid, "D", close, lookahead=barmerge.lookahead_off)
            chochIndex_1D := bar_index
        trendFromCHOCH_1D := bull_choch_1D ? 1 : -1
    if choch30M
        if not chochDetected_30M
            chochDetected_30M := true
            chochPrice_30M := request.security(syminfo.tickerid, "30", close, lookahead=barmerge.lookahead_off)
            chochIndex_30M := bar_index
        trendFromCHOCH_30M := bull_choch_30M ? 1 : -1

if showFibonacci and enableFibonacci and (choch5M or choch15M)
    if not na(chochLabel)
        label.delete(chochLabel)
    string chochText = chochDetected_5M ? "CHOCH 5M" : (chochDetected_15M ? "CHOCH 15M" : "CHOCH")
    color chochTextColor = chochDetected_5M ? color.new(color.yellow, 0) : (chochDetected_15M ? color.new(color.orange, 0) : color.new(color.gray, 20))
    chochLabel := label.new(bar_index, close, chochText, color=color.new(color.gray, 90), textcolor=chochTextColor, size=size.small, style=label.style_label_center, xloc=xloc.bar_index)

//-----------------------------------------------------------------------------}
//Order Blocks
//-----------------------------------------------------------------------------{
//Set order blocks
var iob_boxes = array.new_box(0)
var ob_boxes = array.new_box(0)

//Delete internal order blocks box coordinates if top/bottom is broken
for element in iob_type
    index = array.indexof(iob_type, element)
    if index >= 0 and index < array.size(iob_btm) and index < array.size(iob_top)
        if close < array.get(iob_btm, index) and element == 1
            if index < array.size(iob_top) and index < array.size(iob_btm) and index < array.size(iob_left) and index < array.size(iob_type)
                array.remove(iob_top, index) 
                array.remove(iob_btm, index) 
                array.remove(iob_left, index) 
                array.remove(iob_type, index)
                bull_iob_break := true

        else if close > array.get(iob_top, index) and element == -1
            if index < array.size(iob_top) and index < array.size(iob_btm) and index < array.size(iob_left) and index < array.size(iob_type)
                array.remove(iob_top, index) 
                array.remove(iob_btm, index)
                array.remove(iob_left, index) 
                array.remove(iob_type, index)
                bear_iob_break := true

//Delete internal order blocks box coordinates if top/bottom is broken
for element in ob_type
    index = array.indexof(ob_type, element)
    if index >= 0 and index < array.size(ob_btm) and index < array.size(ob_top)
        if close < array.get(ob_btm, index) and element == 1
            if index < array.size(ob_top) and index < array.size(ob_btm) and index < array.size(ob_left) and index < array.size(ob_type)
                array.remove(ob_top, index) 
                array.remove(ob_btm, index) 
                array.remove(ob_left, index) 
                array.remove(ob_type, index)
                bull_ob_break := true

        else if close > array.get(ob_top, index) and element == -1
            if index < array.size(ob_top) and index < array.size(ob_btm) and index < array.size(ob_left) and index < array.size(ob_type)
                array.remove(ob_top, index) 
                array.remove(ob_btm, index)
                array.remove(ob_left, index) 
                array.remove(ob_type, index)
                bear_ob_break := true

iob_size = array.size(iob_type)
ob_size = array.size(ob_type)

if barstate.isfirst
    if show_iob
        for i = 0 to iob_showlast-1
            array.push(iob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))
    if show_ob
        for i = 0 to ob_showlast-1
            array.push(ob_boxes, box.new(na,na,na,na, xloc = xloc.bar_time))

if iob_size > 0 and barstate.islast
    display_ob(iob_boxes, iob_top, iob_btm, iob_left, iob_type, iob_showlast, false, iob_size)

if ob_size > 0 and barstate.islast
    display_ob(ob_boxes, ob_top, ob_btm, ob_left, ob_type, ob_showlast, true, ob_size)

// à¸­à¸±à¸›à¹€à¸”à¸• hasEngulfingOB à¸ªà¸³à¸«à¸£à¸±à¸š Fibonacci Trading System (à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ ob_btm à¹à¸¥à¸° ob_top à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹à¸¥à¹‰à¸§)
hasEngulfingOB := false
if requireEngulfingOB and bullishEngulfing and array.size(ob_btm) > 0
    for j = 0 to math.min(lookbackBars, array.size(ob_btm) - 1)
        if j < array.size(ob_btm) and j < array.size(ob_top)
            obBottom = array.get(ob_btm, j)
            obTop = array.get(ob_top, j)
            if not na(obBottom) and not na(obTop) and low >= obBottom and high <= obTop
                hasEngulfingOB := true
                break

// à¸­à¸±à¸›à¹€à¸”à¸• atResistance à¸ªà¸³à¸«à¸£à¸±à¸š Exit Conditions (à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ ob_top, ob_btm, ob_type à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹à¸¥à¹‰à¸§)
// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸­à¸¢à¸¹à¹ˆà¸—à¸µà¹ˆà¹à¸™à¸§à¸•à¹‰à¸²à¸™ (Resistance) à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
if checkSupportResistance and strategy.position_size > 0
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Fibonacci Extension Levels (TP1, TP2) à¹à¸¥à¸° Order Block à¹€à¸›à¹‡à¸™à¹à¸™à¸§à¸•à¹‰à¸²à¸™
    atResistance := (not na(fibTP1) and high >= fibTP1 * 0.995 and high <= fibTP1 * 1.005) or (not na(fibTP2) and high >= fibTP2 * 0.995 and high <= fibTP2 * 1.005)
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Order Block (Bearish OB = Resistance)
    if not atResistance and array.size(ob_top) > 0
        for i = 0 to math.min(5, array.size(ob_top) - 1)
            if i < array.size(ob_type) and i < array.size(ob_btm) and array.get(ob_type, i) == -1
                obTop = array.get(ob_top, i)
                obBottom = array.get(ob_btm, i)
                if not na(obTop) and not na(obBottom) and high >= obBottom and high <= obTop
                    atResistance := true
                    break

//-----------------------------------------------------------------------------}
//Imbalances
//-----------------------------------------------------------------------------{
var bullish_fvg_max = array.new_box(0)
var bullish_fvg_min = array.new_box(0)

var bearish_fvg_max = array.new_box(0)
var bearish_fvg_min = array.new_box(0)

float bullish_fvg_avg = na
float bearish_fvg_avg = na

bullish_fvg_cnd = false
bearish_fvg_cnd = false

[src_c1, src_o1, src_h, src_l, src_h2, src_l2] =
  request.security(syminfo.tickerid, fvg_tf, get_ohlc())

if show_fvg
    delta_per = (src_c1 - src_o1) / src_o1 * 100
    change_tf = timeframe.change(fvg_tf)
    threshold = fvg_auto ? ta.cum(math.abs(change_tf ? delta_per : 0)) / n * 2 : 0

    //FVG conditions
    bullish_fvg_cnd := src_l > src_h2 and src_c1 > src_h2 and delta_per > threshold and change_tf
    bearish_fvg_cnd := src_h < src_l2 and src_c1 < src_l2 and -delta_per > threshold and change_tf

    //FVG Areas
    if bullish_fvg_cnd
        array.unshift(bullish_fvg_max, box.new(n-1, src_l, n + fvg_extend, math.avg(src_l, src_h2), border_color = bull_fvg_css, bgcolor = bull_fvg_css))
        array.unshift(bullish_fvg_min, box.new(n-1, math.avg(src_l, src_h2), n + fvg_extend, src_h2, border_color = bull_fvg_css, bgcolor = bull_fvg_css))
    
    if bearish_fvg_cnd
        array.unshift(bearish_fvg_max, box.new(n-1, src_h, n + fvg_extend, math.avg(src_h, src_l2), border_color = bear_fvg_css, bgcolor = bear_fvg_css))
        array.unshift(bearish_fvg_min, box.new(n-1, math.avg(src_h, src_l2), n + fvg_extend, src_l2, border_color = bear_fvg_css, bgcolor = bear_fvg_css))

    for bx in bullish_fvg_min
        if low < box.get_bottom(bx)
            box.delete(bx)
            idx = array.indexof(bullish_fvg_min, bx)
            if idx >= 0 and idx < array.size(bullish_fvg_max)
                box.delete(array.get(bullish_fvg_max, idx))
    
    for bx in bearish_fvg_max
        if high > box.get_top(bx)
            box.delete(bx)
            idx = array.indexof(bearish_fvg_max, bx)
            if idx >= 0 and idx < array.size(bearish_fvg_min)
                box.delete(array.get(bearish_fvg_min, idx))

// à¸­à¸±à¸›à¹€à¸”à¸• hasFVG à¸ªà¸³à¸«à¸£à¸±à¸š Fibonacci Trading System (à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ bullish_fvg_min à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹à¸¥à¹‰à¸§)
// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š FVG, OB (à¸­à¸¢à¸¹à¹ˆà¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡ FVG), à¹à¸¥à¸° Demand (à¸­à¸¢à¸¹à¹ˆà¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡ FVG)
// à¸«à¸¡à¸²à¸¢à¹€à¸«à¸•à¸¸: fvgTop, fvgBottom, hasOBBelowFVG, hasDemandBelowFVG à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹„à¸§à¹‰à¹à¸¥à¹‰à¸§à¸—à¸µà¹ˆà¸šà¸£à¸£à¸—à¸±à¸” 966-969 (à¸à¹ˆà¸­à¸™à¸ªà¹ˆà¸§à¸™à¸—à¸µà¹ˆà¹ƒà¸Šà¹‰à¸‡à¸²à¸™)

if requireFVG and array.size(bullish_fvg_min) > 0
    hasFVG := false
    hasOBBelowFVG := false
    hasDemandBelowFVG := false
    fvgTop := na
    fvgBottom := na
    
    for i = 0 to math.min(lookbackBars, array.size(bullish_fvg_min) - 1)
        fvgBox = array.get(bullish_fvg_min, i)
        if not na(fvgBox)
            hasFVG := true
            fvgTop := box.get_top(fvgBox)
            fvgBottom := box.get_bottom(fvgBox)
            
            // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸¡à¸µ OB (Order Block) à¹à¸¥à¸° Demand Zone à¸­à¸¢à¸¹à¹ˆà¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡ FVG à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
            if array.size(ob_btm) > 0 and not na(fvgBottom)
                for j = 0 to math.min(lookbackBars, array.size(ob_btm) - 1)
                    if j < array.size(ob_btm) and j < array.size(ob_top) and j < array.size(ob_type) and array.get(ob_type, j) == 1
                        obTop = array.get(ob_top, j)
                        obBottom = array.get(ob_btm, j)
                        if not na(obTop) and not na(obBottom) and obTop < fvgBottom
                            hasOBBelowFVG := true
                            hasDemandBelowFVG := true
                            break
                    if hasOBBelowFVG
                        break
            break

// à¸­à¸±à¸›à¹€à¸”à¸• atSupport à¸ªà¸³à¸«à¸£à¸±à¸š Short Exit Conditions (à¸«à¸¥à¸±à¸‡à¸ˆà¸²à¸ ob_top, ob_btm, ob_type à¸–à¸¹à¸à¸›à¸£à¸°à¸à¸²à¸¨à¹à¸¥à¹‰à¸§)
// à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸§à¹ˆà¸²à¸­à¸¢à¸¹à¹ˆà¸—à¸µà¹ˆà¹à¸™à¸§à¸£à¸±à¸š (Support) à¸«à¸£à¸·à¸­à¹„à¸¡à¹ˆ
if checkSupportResistance and strategy.position_size < 0
    atSupport := false  // Reset à¸à¹ˆà¸­à¸™à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹ƒà¸«à¸¡à¹ˆ
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Fibonacci Retracement Levels (0.5, 0.618) à¹à¸¥à¸° Order Block à¹€à¸›à¹‡à¸™à¹à¸™à¸§à¸£à¸±à¸š
    atSupport := (not na(fibRetracement50) and low >= fibRetracement50 * 0.995 and low <= fibRetracement50 * 1.005) or (not na(fibRetracement618) and low >= fibRetracement618 * 0.995 and low <= fibRetracement618 * 1.005)
    
    // à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š Order Block (Bullish OB = Support)
    if not atSupport and array.size(ob_top) > 0
        for i = 0 to math.min(5, array.size(ob_top) - 1)
            if i < array.size(ob_type) and i < array.size(ob_btm) and array.get(ob_type, i) == 1
                obTop = array.get(ob_top, i)
                obBottom = array.get(ob_btm, i)
                if not na(obTop) and not na(obBottom) and low >= obBottom and low <= obTop
                    atSupport := true
                    break

//-----------------------------------------------------------------------------}
//Previous day/week high/lows
//-----------------------------------------------------------------------------{
//Daily high/low
[pdh, pdl] = request.security(syminfo.tickerid, 'D', hl()
  , lookahead = barmerge.lookahead_on)


//Display Daily
if show_pdhl
    define_previous_days_prices(pdh, pdl, 'D', pdhl_css)



//Premium and Discount Zones

var premium = box.new(na, na, na, na, bgcolor=color.new(premium_css, 80), border_color=na)

var premium_lbl = label.new(na, na, text=supply_lbl_txt, color=TRANSP_COLOR, textcolor=color_supply_zone, style=label.style_label_down, size=size.normal)

var discount = box.new(na, na, na, na, bgcolor=color.new(discount_css, 80), border_color=na)

var discount_lbl = label.new(na, na, text=demand_lbl_txt, color=TRANSP_COLOR, textcolor=color_demand_zone, style=label.style_label_up, size=size.normal)

//Show Premium and Discount Areas
// à¸‹à¹ˆà¸­à¸™ Supply zones (Premium) à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡ à¹à¸•à¹ˆà¸¢à¸±à¸‡à¹à¸ªà¸”à¸‡ Demand zones (Discount)
if barstate.islast and show_demand_supply_zones
    avg = math.avg(trail_up, trail_dn)

    // à¸‹à¹ˆà¸­à¸™ Supply zones (Premium) à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸—à¸£à¸™à¸‚à¸²à¸‚à¸¶à¹‰à¸™à¹à¸‚à¹‡à¸‡à¹à¸£à¸‡
    if not isStrongUptrend
        box.set_lefttop(premium, math.max(top_x, btm_x), trail_up)
        box.set_rightbottom(premium, n, .95 * trail_up + .05 * trail_dn)
        label.set_xy(premium_lbl, int(math.avg(math.max(top_x, btm_x), n)), trail_up)
    else
        // à¸‹à¹ˆà¸­à¸™ Supply zones à¹à¸•à¹ˆà¸¢à¸±à¸‡à¹ƒà¸Šà¹‰ logic
        box.set_lefttop(premium, na, na)
        box.set_rightbottom(premium, na, na)
    
    box.set_lefttop(discount, math.max(top_x, btm_x), .95 * trail_dn + .05 * trail_up)
    box.set_rightbottom(discount, n, trail_dn)
    label.set_xy(discount_lbl, int(math.avg(math.max(top_x, btm_x), n)), trail_dn)

//-----------------------------------------------------------------------------}
//Trend Definition
//-----------------------------------------------------------------------------{
var color trend_css = na



if style == 'Colored'
    trend_css := itrend == 1 ? bull_css : bear_css
else if style == 'Monochrome'
    trend_css := itrend == 1 ? #b2b5be : #5d606b



//-----------------------------------------------------------------------------}
// Definition of Possible Alerts
//-----------------------------------------------------------------------------{

//alertcondition(bull_bos_alert, 'Bullish BOS', 'Quebra de Estrutura Bullish')

// SUPPLY/DEMAND + SWING BOXES (disabled to reduce scope count, remove this block comment to re-enable)
//      INDICATOR SETTINGS
//swing_length = input.int(10, title = 'Swing High/Low Length', group = 'Settings', minval = 1, maxval = 50)
//history_of_demand_to_keep = input.int(20, title = 'History To Keep', minval = 5, maxval = 50)
//box_width = input.float(2.5, title = 'Supply/Demand Box Width', group = 'Settings', minval = 1, maxval = 10, step = 0.5)

//      INDICATOR VISUAL SETTINGS
//show_zigzag = input.bool(false, title = 'Show Zig Zag', group = 'Visual Settings', inline = '1')
//show_price_action_labels = input.bool(false, title = 'Show Price Action Labels', group = 'Visual Settings', inline = '2')
//
//supply_color = input.color(color.new(#EDEDED,70), title = 'Supply', group = 'Visual Settings', inline = '3')
//supply_outline_color = input.color(color.new(color.white,75), title = 'Outline', group = 'Visual Settings', inline = '3')
//
//demand_color = input.color(color.new(#00FFFF,70), title = 'Demand', group = 'Visual Settings', inline = '4')
//demand_outline_color = input.color(color.new(color.white,75), title = 'Outline', group = 'Visual Settings', inline = '4')
//
//bos_label_color = input.color(color.white, title = 'BOS Label', group = 'Visual Settings', inline = '5')
//poi_label_color = input.color(color.white, title = 'POI Label', group = 'Visual Settings', inline = '7')
//
//swing_type_color = input.color(color.black, title = 'Price Action Label', group = 'Visual Settings', inline = '8')
//zigzag_color = input.color(color.new(#000000,0), title = 'Zig Zag', group = 'Visual Settings', inline = '9')

//
//END SETTINGS
//


